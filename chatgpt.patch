diff --git a/src/js/main.mjs b/src/js/main.mjs
index 5fa30b3f99ce9d5ec844f713d34d74517cc9c377..1358c3d59375b29b7eb364933efaa6715da59e24 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -317,114 +317,114 @@ function computeDepthSpeedSegmentsForPayload(payloadKg, context, options = {}) {
       }
       if (!Number.isFinite(selectedSpeedMpm) || selectedSpeedMpm < 0) selectedSpeedMpm = 0;
       speed_mpm = selectedSpeedMpm;
     }
 
     const speed_ms = speed_mpm / 60;
     if (!Number.isFinite(speed_ms)) continue;
 
     segments.push({
       depth_start: depthStart,
       depth_end: depthEnd,
       speed_ms: Math.max(0, speed_ms)
     });
   }
 
   segments.sort((a, b) => (b.depth_start || 0) - (a.depth_start || 0));
   return segments;
 }
 
 const CSV_BUTTON_SPECS = {
   csv_el_layer: {
     filename: () => 'electric-layer.csv',
     columns: [
       'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
       'post_on_drum_m', 'post_deployed_m', 'max_tension_theoretical_kgf',
-      'max_tension_required_kgf', 'tau_avail_kNm', 'max_motor_torque_Nm',
+      'max_tension_required_kgf', 'tau_gb_required_kNm', 'tau_gb_avail_kNm', 'max_motor_torque_Nm',
       'motor_rpm_at_start', 'line_speed_at_start_mpm',
       'tension_theoretical_start_kgf', 'tension_required_start_kgf', 'avail_tension_kgf'
     ],
     header: [
       'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
       'post_on_drum_m', 'post_deployed_m', 'max_tension_theoretical_kgf',
-      'max_tension_required_kgf', 'tau_avail_kNm', 'max_motor_torque_Nm',
+      'max_tension_required_kgf', 'tau_gb_required_kNm', 'tau_gb_avail_kNm', 'max_motor_torque_Nm',
       'motor_rpm_at_start', 'line_speed_at_start_mpm',
       'tension_theoretical_start_kgf', 'tension_required_start_kgf', 'avail_tension_kgf'
     ],
     getRows: () => lastElLayer
   },
   csv_el_wraps: {
     filename: () => 'electric-wraps.csv',
     columns: [
       'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
       'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
-      'tension_required_kgf', 'tau_avail_kNm', 'motor_torque_Nm', 'motor_rpm',
+      'tension_required_kgf', 'tau_gb_required_kNm', 'tau_gb_avail_kNm', 'motor_torque_Nm', 'motor_rpm',
       'line_speed_mpm', 'avail_tension_kgf'
     ],
     header: [
       'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
       'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
-      'tension_required_kgf', 'tau_avail_kNm', 'motor_torque_Nm', 'motor_rpm',
+      'tension_required_kgf', 'tau_gb_required_kNm', 'tau_gb_avail_kNm', 'motor_torque_Nm', 'motor_rpm',
       'line_speed_mpm', 'avail_tension_kgf'
     ],
     getRows: () => lastElWraps
   },
   csv_hy_layer: {
     filename: () => 'hydraulic-layer.csv',
     columns: [
       'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
       'post_on_drum_m', 'post_deployed_m', 'hyd_P_required_psi',
       'hyd_speed_power_mpm', 'hyd_speed_flow_mpm', 'hyd_speed_available_mpm',
-      'hyd_hp_req', 'hyd_hp_sys', 'hyd_tau_avail_kNm',
+      'hyd_hp_req', 'hyd_hp_sys', 'tau_gb_required_kNm', 'tau_gb_avail_kNm',
       'hyd_tension_theoretical_start_kgf', 'hyd_tension_required_start_kgf',
       'hyd_avail_tension_kgf'
     ],
     header: [
       'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
       'post_on_drum_m', 'post_deployed_m', 'hyd_P_required_psi',
       'hyd_speed_power_mpm', 'hyd_speed_flow_mpm', 'hyd_speed_available_mpm',
-      'hyd_hp_req', 'hyd_hp_sys', 'hyd_tau_avail_kNm',
+      'hyd_hp_req', 'hyd_hp_sys', 'tau_gb_required_kNm', 'tau_gb_avail_kNm',
       'hyd_tension_theoretical_start_kgf', 'hyd_tension_required_start_kgf',
       'hyd_avail_tension_kgf'
     ],
     getRows: () => lastHyLayer
   },
   csv_hy_wraps: {
     filename: () => 'hydraulic-wraps.csv',
     columns: [
       'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
       'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
       'tension_required_kgf', 'hyd_P_required_psi', 'hyd_speed_power_mpm',
       'hyd_speed_flow_mpm', 'hyd_speed_available_mpm', 'hyd_hp_req',
-      'hyd_hp_sys', 'hyd_tau_avail_kNm', 'hyd_avail_tension_kgf'
+      'hyd_hp_sys', 'tau_gb_required_kNm', 'tau_gb_avail_kNm', 'hyd_avail_tension_kgf'
     ],
     header: [
       'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
       'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
       'tension_required_kgf', 'hyd_P_required_psi', 'hyd_speed_power_mpm',
       'hyd_speed_flow_mpm', 'hyd_speed_available_mpm', 'hyd_hp_req',
-      'hyd_hp_sys', 'hyd_tau_avail_kNm', 'hyd_avail_tension_kgf'
+      'hyd_hp_sys', 'tau_gb_required_kNm', 'tau_gb_avail_kNm', 'hyd_avail_tension_kgf'
     ],
     getRows: () => lastHyWraps
   }
 };
 
 const SYSTEM_TYPE_SELECT_ID = 'system_type_select';
 const DEFAULT_SYSTEM_TYPE = 'electric';
 
 // ---- Wire up events once DOM is ready ----
 document.addEventListener('DOMContentLoaded', () => {
   setupInputPersistence();
 
   setupComponentSelectors();
 
   setupCollapsibleToggles();
 
   setupDriveModeControls();
 
   setupCsvDownloads();
 
   setupPlotResizeToggles();
 
   setupManualRefreshControls();
 
   setupAutoRecompute();
@@ -1225,53 +1225,57 @@ function computeAll() {
     const torque_per_hmotor_maxP = torque_per_motor_from_pressure_Pa(dP_Pa, h_hmot_cc); // N·m per motor at max P
     const torque_at_drum_maxP_factor = Math.max(gr1, 1) * Math.max(gr2, 1) * Math.max(motors, 1);
 
     // Generate wraps from geometry
     const { rows, summary, meta } = calcLayers(cfg);
 
     const wrapsNoteEl = /** @type {HTMLTableCellElement|null} */ (document.getElementById('wraps_note'));
     if (wrapsNoteEl) {
       const calcWraps = meta && Number.isFinite(meta.wraps_per_layer_calc) ? meta.wraps_per_layer_calc : undefined;
       const display = (typeof calcWraps === 'number') ? calcWraps.toFixed(1) : '–';
       wrapsNoteEl.textContent = `Leave blank or set to 0 to use calculated wraps (always truncated to .0/.5). Auto-calculated wraps per layer: ${display}.`;
     }
 
     // Per-wrap calculations (electric + hydraulic)
     for (const r of rows) {
       // Base tension and torque at drum
       const theoretical_tension = tension_kgf(r.deployed_len_m, payload_kg, cable_w_kgpm);
       const required_tension = +(theoretical_tension).toFixed(1);
       r.tension_theoretical_kgf = theoretical_tension;
       r.tension_kgf = required_tension;
       const tension_N = required_tension * G;
       const radius_m = (r.layer_dia_in * M_PER_IN) / 2;
       const drum_T = tension_N * radius_m;
       const motors_safe = Math.max(motors, 1);
       const gear_product_safe = Math.max(gear_product, 1e-9);
+      const gr2_safe = Math.max(gr2, 1e-9);
       const torque_per_hmotor_required = drum_T / (gear_product_safe * motors_safe);
       const drum_torque_required = torque_per_hmotor_required * gear_product_safe * motors_safe;
       r.torque_Nm = +drum_torque_required.toFixed(1);
+      const tauGbRequiredNm = drum_torque_required / (gr2_safe * motors_safe);
+      r.tau_gb_required_kNm = +(tauGbRequiredNm / 1000).toFixed(2);
+      r.tau_gb_avail_kNm = null;
 
       // ----- ELECTRIC per wrap -----
       if (electricEnabled) {
         const motorTorque_e = r.torque_Nm / (denom_mech || 1);
         r.motor_torque_Nm = +motorTorque_e.toFixed(2);
 
         // RPM limited by available power per motor and capped by motor max rpm
         let rpm_power_e = 0;
         if (P_per_motor_W > 0 && motorTorque_e > 0) {
           rpm_power_e = (P_per_motor_W / motorTorque_e) * 60 / (2 * Math.PI);
         } else if (P_per_motor_W > 0 && motorTorque_e === 0) {
           rpm_power_e = Number.POSITIVE_INFINITY;
         } else {
           rpm_power_e = 0;
         }
         const rpm_capped_e = Math.min(Number.isFinite(motor_max_rpm) ? motor_max_rpm : Infinity, rpm_power_e);
         r.motor_rpm = +((Number.isFinite(rpm_capped_e) ? rpm_capped_e : 0)).toFixed(1);
 
         // Line speed at drum
         r.line_speed_mpm = +line_speed_mpm_from_motor_rpm(r.motor_rpm, gr1, gr2, r.layer_dia_in).toFixed(2);
 
         // Available line tension from motor torque cap
         r.avail_tension_kgf = elec_available_tension_kgf(motor_tmax, gr1, gr2, motors, radius_m);
       } else {
         r.motor_torque_Nm = 0;
@@ -1323,50 +1327,56 @@ function computeAll() {
         const rpm_power_drum = Number.isFinite(speed_power_mpm) && speed_power_mpm > 0
           ? speed_power_mpm / safe_drum_circumference
           : Number.isFinite(speed_power_mpm) && speed_power_mpm === 0
             ? 0
             : NaN;
 
         let speed_avail_mpm = Math.min(speed_power_mpm, speed_flow_mpm);
         if (!Number.isFinite(speed_avail_mpm) || speed_avail_mpm < 0) speed_avail_mpm = 0;
         const rpm_available_drum = Number.isFinite(speed_avail_mpm)
           ? speed_avail_mpm / safe_drum_circumference
           : NaN;
 
         let hp_used_at_available = 0;
         if (speed_avail_mpm > 0 && P_power_psi > 0) {
           // Power used at the actual available speed
           const drum_rpm_needed = speed_avail_mpm / Math.max(Math.PI * Math.max(D_m, 1e-9), 1e-9);
           const motor_rpm_needed = drum_rpm_needed * (Math.max(gr1, 1) * Math.max(gr2, 1));
           const gpm_per_motor_needed = (motor_rpm_needed * h_hmot_cc) / CC_PER_GAL;
           const gpm_total_needed = Math.max(motors, 1) * gpm_per_motor_needed;
           const gpm_used = Math.min(gpm_total_needed, q_tot_gpm);
           hp_used_at_available = hp_from_psi_and_gpm(P_power_psi, gpm_used);
           if (hp_used_at_available > hp_tot_usable) hp_used_at_available = hp_tot_usable;
         }
 
         r.hyd_P_required_psi = Math.round(P_req_psi);
+        const tauGbAvailNm = torque_per_motor_from_pressure_Pa(P_req_psi * PSI_TO_PA, h_hmot_cc)
+          * motors_safe
+          * Math.max(gr1, 1);
+        r.tau_gb_avail_kNm = Number.isFinite(tauGbAvailNm)
+          ? +(tauGbAvailNm / 1000).toFixed(2)
+          : null;
         r.hyd_speed_power_mpm = +speed_power_mpm.toFixed(2);
         r.hyd_speed_flow_mpm = +speed_flow_mpm.toFixed(2);
         r.hyd_speed_available_mpm = +speed_avail_mpm.toFixed(2);
         r.hyd_hp_used_at_available = +hp_used_at_available.toFixed(2);
         r.hyd_elec_input_hp_used = +((h_emotor_eff > 0 ? r.hyd_hp_used_at_available / h_emotor_eff : 0)).toFixed(2);
         r.hyd_drum_rpm_flow = Number.isFinite(rpm_flow_drum)
           ? +Math.max(0, rpm_flow_drum).toFixed(1)
           : 0;
         r.hyd_drum_rpm_power = Number.isFinite(rpm_power_drum)
           ? +Math.max(0, rpm_power_drum).toFixed(1)
           : null;
         r.hyd_drum_rpm_available = Number.isFinite(rpm_available_drum)
           ? +Math.max(0, rpm_available_drum).toFixed(1)
           : 0;
       } else {
         r.hyd_drum_torque_maxP_Nm = 0;
         r.hyd_avail_tension_kgf = 0;
         r.hyd_P_required_psi = 0;
         r.hyd_speed_power_mpm = 0;
         r.hyd_speed_flow_mpm = 0;
         r.hyd_speed_available_mpm = 0;
         r.hyd_hp_used_at_available = 0;
         r.hyd_elec_input_hp_used = 0;
         r.hyd_drum_rpm_flow = 0;
         r.hyd_drum_rpm_power = 0;
@@ -1395,51 +1405,56 @@ function computeAll() {
       motors,
       motor_max_rpm,
       motor_tmax,
       P_per_motor_W,
       denom_mech,
       gear_product,
       electricEnabled,
       hydraulicEnabled,
       hydraulic: {
         h_strings,
         h_emotor_hp,
         h_emotor_eff,
         h_emotor_rpm,
         h_pump_cc,
         h_max_psi,
         h_hmot_cc,
         h_hmot_rpm_cap,
         torque_per_hmotor_maxP,
         torque_at_drum_maxP_factor,
         q_tot_gpm,
         rpm_flow_per_motor: rpm_flow_per_motor_available
       }
     });
 
     // ---- Render tables ----
-    renderElectricTables(lastElLayer, lastElWraps, q('tbody_el_layer'), q('tbody_el_wraps'));
+    renderElectricTables(
+      lastElLayer,
+      lastElWraps,
+      q('tbody_el_layer'),
+      q('tbody_el_wraps')
+    );
     renderHydraulicTables(lastHyLayer, lastHyWraps, q('tbody_hy_layer'), q('tbody_hy_wraps'));
 
     renderInputSummary();
     renderLatexFragments(document.body);
 
     updateCsvButtonStates();
 
     // ---- Draw plots ----
     redrawPlots();
   } catch (e) {
     console.error(e);
     if (errBox) errBox.textContent = 'ERROR: ' + (e && e.message ? e.message : e);
     clearMinimumSystemHp();
     lastElLayer = lastElWraps = lastHyLayer = lastHyWraps = [];
     lastDrumState = null;
     lastDepthProfileContext = null;
     clearDrumVisualization();
     clearPlots();
     updateCsvButtonStates();
     renderInputSummary();
     renderLatexFragments(document.body);
   }
 }
 
 // ---- Plot redraw helper (uses decoupled plotting modules) ----
