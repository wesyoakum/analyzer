diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index 0457c35d946e864d5d4a8e09b370a1694edd0866..0cc41821adeea92aaa1285a08a5a1f8cde412dc0 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -1,28 +1,28 @@
 // ===== drum-visual.mjs â€” render drum cross-section + summary =====
 
-import { svgEl, IN_PER_MM } from './utils.mjs';
+import { svgEl, IN_PER_MM, isWhole } from './utils.mjs';
 
 const FALLBACK_COLORS = {
   accent: { r: 44, g: 86, b: 163 },
   accentLight: { r: 237, g: 242, b: 255 },
   ink500: { r: 85, g: 99, b: 125 },
   ink700: { r: 47, g: 59, b: 84 },
   ink900: { r: 20, g: 34, b: 56 },
   paper: { r: 255, g: 255, b: 255 }
 };
 
 const FALLBACK_HEX = {
   accent: '#2c56a3',
   accentLight: '#edf2ff',
   ink500: '#55637d',
   ink700: '#2f3b54',
   ink900: '#142238',
   paper: '#ffffff'
 };
 
 const SVG_BASE_HEIGHT = 360;
 const SVG_MARGIN = 28;
 
 /**
  * Parse a CSS color string into RGB components.
  * Supports #rgb[a], #rrggbb[aa], and rgb()/rgba().
@@ -230,75 +230,92 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
 
     svg.appendChild(svgEl('rect', {
       ...flangeRectAttrs,
       x: (spoolLeft - flangeWidthPx).toFixed(2)
     }));
 
     svg.appendChild(svgEl('rect', {
       ...flangeRectAttrs,
       x: spoolRight.toFixed(2)
     }));
   }
 
   const axisColor = rgbToCss(ink700Rgb, 0.18);
   svg.appendChild(svgEl('line', {
     x1: spoolLeft.toFixed(2),
     y1: centerY.toFixed(2),
     x2: spoolRight.toFixed(2),
     y2: centerY.toFixed(2),
     stroke: axisColor,
     'stroke-width': strokeWidthAttr,
     'vector-effect': 'non-scaling-stroke',
     'stroke-dasharray': '6 6'
   }));
 
   const cableRadiusPx = cable_dia_in > 0 ? (cable_dia_in / 2) * scale : 0;
+  const theoreticalWrapsPerLayer = meta && Number.isFinite(meta.wraps_per_layer_used)
+    ? meta.wraps_per_layer_used
+    : (cable_dia_in > 0 ? (Math.max(flange_to_flange_in || 0, 0) / Math.max(cable_dia_in, 1e-9)) : 0);
 
   const wrapsByLayer = new Map();
   for (const row of rows) {
     wrapsByLayer.set(row.layer_no, (wrapsByLayer.get(row.layer_no) || 0) + 1);
   }
 
   if (cableRadiusPx > 0 && coreWidthPx > 0) {
     layersForViz.forEach(layer => {
-      const wraps = wrapsByLayer.get(layer.layer_no) || 0;
-      if (wraps <= 0) return;
+      const actualWraps = wrapsByLayer.get(layer.layer_no) || 0;
+      if (actualWraps <= 0) return;
       const centerOffsetPx = layer.center_radius_in * scale;
       const topY = centerY - centerOffsetPx;
       const bottomY = centerY + centerOffsetPx;
 
-      const spacingIn = wraps > 1
-        ? (Math.max(flange_to_flange_in || 0, 0) - Math.max(cable_dia_in, 0)) / (wraps - 1)
+      const wrapSlots = Number.isFinite(theoreticalWrapsPerLayer) && theoreticalWrapsPerLayer > 0
+        ? theoreticalWrapsPerLayer
+        : actualWraps;
+      const spacingDivisor = wrapSlots > 1 ? wrapSlots - 1 : 0;
+      const spacingIn = spacingDivisor > 0
+        ? (Math.max(flange_to_flange_in || 0, 0) - Math.max(cable_dia_in, 0)) / spacingDivisor
         : 0;
       const spacingPx = Math.max(spacingIn, 0) * scale;
       const startFromLeft = (layer.layer_no % 2) === 1;
       const startCx = startFromLeft
         ? spoolLeft + cableRadiusPx
         : spoolRight - cableRadiusPx;
       const delta = startFromLeft ? spacingPx : -spacingPx;
 
-      for (let w = 0; w < wraps; w++) {
+      let wrapsToDraw = actualWraps;
+      if (
+        Number.isFinite(theoreticalWrapsPerLayer) &&
+        isWhole(theoreticalWrapsPerLayer) &&
+        (layer.layer_no % 2 === 0)
+      ) {
+        const evenLayerMax = Math.max(Math.round(theoreticalWrapsPerLayer) - 1, 0);
+        wrapsToDraw = Math.min(wrapsToDraw, evenLayerMax);
+      }
+
+      for (let w = 0; w < wrapsToDraw; w++) {
         const cx = startCx + w * delta;
         if (cx - cableRadiusPx < spoolLeft - 1e-3) continue;
         if (cx + cableRadiusPx > spoolRight + 1e-3) continue;
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: topY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
         }));
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: bottomY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
         }));
       }
     });
