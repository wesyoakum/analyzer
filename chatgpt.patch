diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index df5bbe36df4006b05beed4539ee3b429e6b006a9..cb8dd9b577f5804545dab65007a0ca58dc868795 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -238,90 +238,102 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
       x: spoolRight.toFixed(2)
     }));
   }
 
   const axisColor = rgbToCss(ink700Rgb, 0.18);
   svg.appendChild(svgEl('line', {
     x1: spoolLeft.toFixed(2),
     y1: centerY.toFixed(2),
     x2: spoolRight.toFixed(2),
     y2: centerY.toFixed(2),
     stroke: axisColor,
     'stroke-width': strokeWidthAttr,
     'vector-effect': 'non-scaling-stroke',
     'stroke-dasharray': '6 6'
   }));
 
   const cableRadiusPx = cable_dia_in > 0 ? (cable_dia_in / 2) * scale : 0;
 
   const wrapsPerLayerUsed = meta && Number.isFinite(meta.wraps_per_layer_used)
     ? meta.wraps_per_layer_used
     : null;
   const wrapsPerLayerFraction = wrapsPerLayerUsed !== null
     ? Math.abs(wrapsPerLayerUsed - Math.round(wrapsPerLayerUsed))
     : 0;
   const isHalfWrapPattern = wrapsPerLayerUsed !== null && Math.abs(wrapsPerLayerFraction - 0.5) < 1e-6;
+  const isWholeWrapPattern = wrapsPerLayerUsed !== null && Math.abs(wrapsPerLayerFraction) < 1e-6;
 
   const wrapsByLayer = new Map();
   for (const row of rows) {
     wrapsByLayer.set(row.layer_no, (wrapsByLayer.get(row.layer_no) || 0) + 1);
   }
 
   if (cableRadiusPx > 0 && coreWidthPx > 0) {
     const leftTangent = spoolLeft + cableRadiusPx;
     const rightTangent = spoolRight - cableRadiusPx;
     const availableWidth = Math.max(0, coreWidthPx - 2 * cableRadiusPx);
 
     layersForViz.forEach(layer => {
       const wraps = wrapsByLayer.get(layer.layer_no) || 0;
       if (wraps <= 0) return;
       const centerOffsetPx = layer.center_radius_in * scale;
       const topY = centerY - centerOffsetPx;
       const bottomY = centerY + centerOffsetPx;
 
       /** @type {number[]} */
       const centers = [];
-      if (wraps === 1) {
-        if (isHalfWrapPattern && (layer.layer_no % 2 === 0)) {
-          centers.push(rightTangent);
-        } else {
-          centers.push(leftTangent);
-        }
-      } else if (isHalfWrapPattern) {
+      if (isHalfWrapPattern) {
         const denom = Math.max(wraps - 0.5, 1e-6);
         const gap = availableWidth / denom;
         const start = (layer.layer_no % 2 === 0)
           ? leftTangent + gap / 2
           : leftTangent;
         for (let w = 0; w < wraps; w++) {
           centers.push(start + w * gap);
         }
+      } else if (
+        isWholeWrapPattern &&
+        wrapsPerLayerUsed > 1 &&
+        availableWidth > 0
+      ) {
+        const baseWraps = Math.max(0, Math.round(wrapsPerLayerUsed));
+        const gap = availableWidth / Math.max(baseWraps - 1, 1e-6);
+        const start = (layer.layer_no % 2 === 0)
+          ? leftTangent + gap / 2
+          : leftTangent;
+        for (let w = 0; w < wraps; w++) {
+          centers.push(start + w * gap);
+        }
       } else {
         const gap = wraps > 1 ? availableWidth / (wraps - 1) : 0;
         const start = leftTangent;
-        for (let w = 0; w < wraps; w++) {
-          centers.push(start + w * gap);
+        if (wraps === 1) {
+          centers.push(start);
+        } else {
+          for (let w = 0; w < wraps; w++) {
+            centers.push(start + w * gap);
+          }
         }
       }
 
       centers.forEach(cx => {
         if (cx - cableRadiusPx < spoolLeft - 1e-3) return;
         if (cx + cableRadiusPx > spoolRight + 1e-3) return;
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: topY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
         }));
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: bottomY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
