diff --git a/src/js/component-selectors.mjs b/src/js/component-selectors.mjs
index b9ec472e3b97c020fc53a842d31b4ee369a939f9..b7e84dc6d0fcbe9d9427b80315497117ee631504 100644
--- a/src/js/component-selectors.mjs
+++ b/src/js/component-selectors.mjs
@@ -866,104 +866,154 @@ const SELECT_CONFIGS = [
     selectId: 'hydraulic_pump_select',
     options: HYDRAULIC_PUMP_OPTIONS,
     type: 'hydraulic-pump',
     label: 'Hydraulic Pump',
     fieldMap: FIELD_MAPS.hydraulicPump
   },
   {
     selectId: 'hydraulic_motor_select',
     options: HYDRAULIC_MOTOR_OPTIONS,
     type: 'hydraulic-motor',
     label: 'Hydraulic Motor',
     fieldMap: FIELD_MAPS.hydraulicMotor
   },
   {
     selectId: 'system_select',
     options: SYSTEM_OPTIONS,
     type: 'system',
     label: 'System',
     fieldMap: FIELD_MAPS.system,
     initialSkipEvents: false
   }
 ];
 
 const watchedInputs = new Set();
 const CREATE_NEW_VALUE = '__component_create_new__';
+const SAVE_CURRENT_VALUE = '__component_save_current__';
+const SAVE_CURRENT_LABEL = 'Save Current Preset';
 const COMPONENT_STORAGE_PREFIX = 'analyzer.components.';
 /** @type {Map<string, ComponentOption[]>} */
 const memoryCustomOptions = new Map();
 let cachedComponentStorage;
 
 function isPlainObject(value) {
   return typeof value === 'object' && value !== null && !Array.isArray(value);
 }
 
+function mergePresetMetadata(...sources) {
+  /** @type {Record<string, unknown>} */
+  const result = {};
+  sources.forEach(source => {
+    if (!isPlainObject(source)) {
+      return;
+    }
+    Object.entries(source).forEach(([key, value]) => {
+      if (key === 'fieldMap' && isPlainObject(value)) {
+        const existingFieldMap =
+          isPlainObject(result.fieldMap) ? { .../** @type {Record<string, unknown>} */ (result.fieldMap) } : {};
+        result.fieldMap = { ...existingFieldMap, .../** @type {Record<string, unknown>} */ (value) };
+        return;
+      }
+      result[key] = value;
+    });
+  });
+  return result;
+}
+
+function buildMetadataForConfig(option, config) {
+  const metadata = mergePresetMetadata(option && isPlainObject(option.metadata) ? option.metadata : {});
+  if (option && typeof option.pn === 'string' && option.pn) {
+    if (typeof metadata.pn !== 'string' || !metadata.pn) {
+      metadata.pn = option.pn;
+    }
+  }
+  if (config && typeof config.type === 'string' && config.type) {
+    metadata.type = config.type;
+  }
+  if (config && typeof config.label === 'string' && config.label) {
+    metadata.label = config.label;
+  }
+  if (config && isPlainObject(config.fieldMap)) {
+    const entries = Object.entries(config.fieldMap).filter(([, optionKey]) => typeof optionKey === 'string' && optionKey);
+    if (entries.length) {
+      const fieldMap =
+        isPlainObject(metadata.fieldMap) ? { .../** @type {Record<string, string>} */ (metadata.fieldMap) } : {};
+      entries.forEach(([inputId, optionKey]) => {
+        fieldMap[inputId] = /** @type {string} */ (optionKey);
+      });
+      metadata.fieldMap = fieldMap;
+    }
+  }
+  return metadata;
+}
+
 function cloneOption(option) {
   const clone = { ...option };
   if (isPlainObject(option.metadata)) {
     clone.metadata = { ...option.metadata };
   }
   if (isPlainObject(option.data)) {
     clone.data = { ...option.data };
   }
   return clone;
 }
 
 function rememberCustomOptions(type, options) {
   if (!type) return;
   const list = Array.isArray(options) ? options.map(cloneOption) : [];
   memoryCustomOptions.set(type, list);
 }
 
 function getRememberedCustomOptions(type) {
   if (!type) return [];
   const existing = memoryCustomOptions.get(type);
   return existing ? existing.map(cloneOption) : [];
 }
 
 function persistCustomOptions(type) {
   if (!type) return;
   const storage = getComponentStorage();
   if (!storage) return;
   try {
     const snapshot = memoryCustomOptions.get(type) ?? [];
     storage.setItem(`${COMPONENT_STORAGE_PREFIX}${type}`, JSON.stringify(snapshot));
   } catch (err) {
     console.warn(`Unable to persist custom ${type} options:`, err);
   }
 }
 
 function refreshSelectsForType(type) {
   if (!type) return;
   const snapshot = getRememberedCustomOptions(type);
   SELECT_CONFIGS.forEach(config => {
     if (config.type !== type) return;
     config.customOptions = snapshot.map(cloneOption);
     const selectEl = /** @type {HTMLSelectElement|null} */ (document.getElementById(config.selectId));
     if (!selectEl) return;
     const prior = selectEl.value;
     populateSelectOptions(selectEl, config, { selectedValue: prior });
+    selectEl.dispatchEvent(new Event('component:options-refreshed'));
   });
 }
 
 function replaceCustomOptions(type, options, { persist = true } = {}) {
   if (!type) return;
   rememberCustomOptions(type, options);
   refreshSelectsForType(type);
   if (persist) {
     persistCustomOptions(type);
   }
 }
 
 function optionIdentity(option) {
   if (!option) return null;
   if (typeof option.id === 'string' && option.id.length) {
     return `id:${option.id}`;
   }
   if (typeof option.pn === 'string' && option.pn.length) {
     return `pn:${option.pn.toLowerCase()}`;
   }
   return null;
 }
 
 function mergeCustomOptionLists(existing, incoming) {
   const result = Array.isArray(existing) ? existing.map(cloneOption) : [];
@@ -1170,59 +1220,80 @@ function collectValuesForConfig(config) {
     }
   });
   return result;
 }
 
 function populateSelectOptions(selectEl, config, { selectedValue } = {}) {
   const prior = selectedValue !== undefined ? selectedValue : selectEl.value;
   selectEl.innerHTML = '';
   const manualOpt = document.createElement('option');
   manualOpt.value = '';
   manualOpt.textContent = 'Custom (manual input)';
   selectEl.appendChild(manualOpt);
 
   allOptions(config).forEach(option => {
     const opt = document.createElement('option');
     opt.value = option.pn;
     opt.textContent = describeOption(config, option);
     selectEl.appendChild(opt);
   });
 
   const createOpt = document.createElement('option');
   createOpt.value = CREATE_NEW_VALUE;
   createOpt.textContent = 'Create New';
   selectEl.appendChild(createOpt);
 
-  if (prior && prior !== CREATE_NEW_VALUE && findOption(config, prior)) {
+  const saveOpt = document.createElement('option');
+  saveOpt.value = SAVE_CURRENT_VALUE;
+  saveOpt.textContent = SAVE_CURRENT_LABEL;
+  saveOpt.dataset.componentPresetSave = '1';
+  saveOpt.disabled = true;
+  selectEl.appendChild(saveOpt);
+
+  if (prior && prior !== CREATE_NEW_VALUE && prior !== SAVE_CURRENT_VALUE && findOption(config, prior)) {
     selectEl.value = prior;
   } else if (prior === '') {
     selectEl.value = '';
   } else {
     selectEl.value = '';
   }
 }
 
+function ensureSavePresetOption(selectEl) {
+  /** @type {HTMLOptionElement|null} */
+  let option = selectEl.querySelector(`option[value="${SAVE_CURRENT_VALUE}"]`);
+  if (!option) {
+    option = document.createElement('option');
+    option.value = SAVE_CURRENT_VALUE;
+    option.textContent = SAVE_CURRENT_LABEL;
+    option.dataset.componentPresetSave = '1';
+    option.disabled = true;
+    selectEl.appendChild(option);
+  }
+  return option;
+}
+
 async function handleCreateNew(config, selectEl) {
   const label = config.label || 'component';
   const pnInput = window.prompt(`Enter a part number for the new ${label} preset:`);
   if (pnInput == null) {
     return null;
   }
   const pn = pnInput.trim();
   if (!pn) {
     window.alert('A part number is required to create a preset.');
     return null;
   }
 
   const existing = allOptions(config).find(opt => opt.pn.toLowerCase() === pn.toLowerCase());
   if (existing) {
     window.alert(`A preset with part number "${pn}" already exists.`);
     return null;
   }
 
   const descriptionInput = window.prompt(`Enter a description for ${pn}:`);
   const description = descriptionInput == null ? '' : descriptionInput.trim();
 
   const values = collectValuesForConfig(config);
   const metadata = { pn };
   if (config.type) {
     metadata.type = config.type;
@@ -1426,91 +1497,267 @@ function applySelection(config, pn, { skipEvents = false } = {}) {
   });
 }
 
 export function setupComponentSelectors() {
   const initializedTypes = new Set();
   SELECT_CONFIGS.forEach(config => {
     const type = config.type;
     if (!type || initializedTypes.has(type)) return;
     const loaded = loadCustomOptions(type);
     rememberCustomOptions(type, loaded);
     initializedTypes.add(type);
   });
 
   SELECT_CONFIGS.forEach(config => {
     const selectEl = /** @type {HTMLSelectElement|null} */ (document.getElementById(config.selectId));
     if (!selectEl) return;
 
     const customOptions = getRememberedCustomOptions(config.type);
     config.customOptions = customOptions;
 
     const initialValue = selectEl.value;
     const { initialSkipEvents = true } = config;
 
     populateSelectOptions(selectEl, config, { selectedValue: initialValue });
 
+    let isSavingPreset = false;
+    let saveOption = ensureSavePresetOption(selectEl);
+    const updateSaveOptionState = () => {
+      saveOption = ensureSavePresetOption(selectEl);
+      if (!saveOption) {
+        return;
+      }
+      if (isSavingPreset) {
+        saveOption.disabled = true;
+        saveOption.textContent = 'Savingâ€¦';
+        return;
+      }
+      saveOption.textContent = SAVE_CURRENT_LABEL;
+      const option = findOption(config, selectEl.value);
+      const isServerPreset = Boolean(option && typeof option.id === 'string' && option.id);
+      const shouldEnable = isServerPreset && !selectEl.disabled;
+      saveOption.disabled = !shouldEnable;
+      if (isServerPreset && option && typeof option.id === 'string') {
+        saveOption.dataset.presetId = option.id;
+      } else {
+        delete saveOption.dataset.presetId;
+      }
+    };
+
+    selectEl.addEventListener('component:options-refreshed', () => {
+      saveOption = ensureSavePresetOption(selectEl);
+      updateSaveOptionState();
+    });
+
     Object.keys(config.fieldMap).forEach(inputId => attachWatcher(inputId));
 
     let previousValue = selectEl.value && selectEl.value !== CREATE_NEW_VALUE ? selectEl.value : '';
     let suppressNext = false;
 
     const ensureOptionApplied = (value, { skipEvents = false } = {}) => {
       applySelection(config, value, { skipEvents });
     };
 
+    const performSaveCurrentPreset = async () => {
+      if (isSavingPreset) {
+        return;
+      }
+      const option = findOption(config, selectEl.value);
+      if (!option || typeof option.id !== 'string' || !option.id) {
+        return;
+      }
+
+      const descriptor = option.name && option.name !== option.pn ? `${option.name} (${option.pn})` : option.pn;
+      const label = config.label || 'component';
+      const confirmMessage = [
+        `Save the current ${label} settings to preset "${descriptor}"?`,
+        'This will overwrite the version stored on the server.'
+      ].join('\n\n');
+      const confirmed = window.confirm(confirmMessage);
+      if (!confirmed) {
+        return;
+      }
+
+      isSavingPreset = true;
+      const wasSelectDisabled = selectEl.disabled;
+      selectEl.disabled = true;
+      updateSaveOptionState();
+
+      try {
+        const values = collectValuesForConfig(config);
+        const payloadMetadata = buildMetadataForConfig(option, config);
+        const payload = {
+          id: option.id,
+          name: option.name ?? option.pn,
+          ...(option.description ? { description: option.description } : {}),
+          data: values,
+          metadata: payloadMetadata
+        };
+
+        let response;
+        try {
+          response = await fetch('/api/presets', {
+            method: 'POST',
+            headers: {
+              'Content-Type': 'application/json'
+            },
+            body: JSON.stringify(payload)
+          });
+        } catch (err) {
+          const message = err instanceof Error ? err.message : String(err);
+          window.alert(`Unable to save preset: ${message}`);
+          return;
+        }
+
+        if (!response.ok) {
+          let message = 'Failed to save preset.';
+          try {
+            const errorBody = await response.json();
+            if (errorBody?.error?.message) {
+              message = errorBody.error.message;
+              if (Array.isArray(errorBody.error.details) && errorBody.error.details.length) {
+                message = `${message}\n- ${errorBody.error.details.join('\n- ')}`;
+              }
+            }
+          } catch (err) {
+            // Ignore JSON parsing errors; fall back to generic message.
+          }
+          window.alert(message);
+          return;
+        }
+
+        let body;
+        try {
+          body = await response.json();
+        } catch (err) {
+          window.alert('Failed to parse server response when saving preset.');
+          return;
+        }
+
+        const preset = body?.preset;
+        if (!preset || typeof preset.id !== 'string') {
+          window.alert('Server response did not include the updated preset.');
+          return;
+        }
+
+        const presetData =
+          preset && typeof preset.data === 'object' && preset.data !== null && !Array.isArray(preset.data)
+            ? preset.data
+            : values;
+        const serverMetadata =
+          preset.metadata && typeof preset.metadata === 'object' && !Array.isArray(preset.metadata)
+            ? preset.metadata
+            : undefined;
+        const mergedMetadata = mergePresetMetadata(option.metadata, payloadMetadata, serverMetadata);
+        if (option.pn && (typeof mergedMetadata.pn !== 'string' || !mergedMetadata.pn)) {
+          mergedMetadata.pn = option.pn;
+        }
+        if (config.type && (!mergedMetadata.type || typeof mergedMetadata.type !== 'string')) {
+          mergedMetadata.type = config.type;
+        }
+        if (config.label && (!mergedMetadata.label || typeof mergedMetadata.label !== 'string')) {
+          mergedMetadata.label = config.label;
+        }
+
+        const normalizedOptionData = normalizePresetDataForOption(presetData, mergedMetadata?.fieldMap);
+        /** @type {ComponentOption} */
+        const updatedOption = {
+          pn: mergedMetadata.pn && typeof mergedMetadata.pn === 'string' ? mergedMetadata.pn : option.pn,
+          name: preset.name ?? option.name ?? option.pn,
+          ...(preset.description ? { description: preset.description } : option.description ? { description: option.description } : {}),
+          ...normalizedOptionData,
+          id: option.id,
+          metadata: isPlainObject(mergedMetadata) ? { ...mergedMetadata } : undefined,
+          data: isPlainObject(presetData) ? { ...presetData } : undefined
+        };
+        if (typeof preset.updatedAt === 'string') {
+          updatedOption.updatedAt = preset.updatedAt;
+        } else if (option.updatedAt) {
+          updatedOption.updatedAt = option.updatedAt;
+        }
+
+        if (config.type) {
+          upsertCustomOption(config.type, updatedOption);
+        }
+
+        const updatedPn = updatedOption.pn ?? option.pn;
+        if (updatedPn) {
+          previousValue = updatedPn;
+          selectEl.value = updatedPn;
+        }
+      } finally {
+        isSavingPreset = false;
+        selectEl.disabled = wasSelectDisabled;
+        updateSaveOptionState();
+      }
+    };
+
     selectEl.addEventListener('change', async () => {
       if (suppressNext) {
         suppressNext = false;
         previousValue = selectEl.value;
         ensureOptionApplied(selectEl.value);
+        updateSaveOptionState();
         return;
       }
 
       const value = selectEl.value;
+      if (value === SAVE_CURRENT_VALUE) {
+        const revertValue = previousValue || '';
+        selectEl.value = revertValue;
+        await performSaveCurrentPreset();
+        updateSaveOptionState();
+        return;
+      }
+
       if (value === CREATE_NEW_VALUE) {
         selectEl.value = previousValue;
         const createdPn = await handleCreateNew(config, selectEl);
         if (createdPn) {
           previousValue = createdPn;
           suppressNext = true;
           selectEl.value = createdPn;
           ensureOptionApplied(createdPn);
           selectEl.dispatchEvent(new Event('change', { bubbles: true }));
         } else {
           ensureOptionApplied(previousValue);
         }
+        updateSaveOptionState();
         return;
       }
 
       previousValue = value;
       ensureOptionApplied(value);
+      updateSaveOptionState();
     });
 
     // Apply persisted selection if present
     if (selectEl.value) {
       ensureOptionApplied(selectEl.value, { skipEvents: initialSkipEvents });
     }
+
+    updateSaveOptionState();
   });
 
   void fetchAndApplyServerPresets();
 }
 
 async function fetchAndApplyServerPresets() {
   if (typeof window === 'undefined' || typeof window.fetch !== 'function') {
     return;
   }
 
   let response;
   try {
     response = await fetch('/api/presets');
   } catch (err) {
     console.warn('Unable to fetch presets from server:', err);
     return;
   }
 
   if (!response.ok) {
     console.warn('Failed to load presets from server.');
     return;
   }
 
   let body;
   try {
