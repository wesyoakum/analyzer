diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index 22f61e1b9635e3827d4b14b23338e25d3518be3d..753804b0ce651d89b3b14f0212bb1a87cae57baf 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -210,80 +210,114 @@ function drawSpeedProfile(svg, segments, depthMin, depthMax, speedMin, speedMax,
 
   niceTicks(depthMin, depthMax, 8).ticks.forEach(dx => {
     if (dx < depthMin - 1e-9 || dx > depthMax + 1e-9) return;
     const X = sx(dx);
     svg.appendChild(svgEl('line', { x1: X, y1: MT, x2: X, y2: H - MB, stroke: '#eee' }));
     const t = svgEl('text', { x: X, y: H - 8, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' });
     t.textContent = formatDepthLabel(dx);
     svg.appendChild(t);
   });
   niceTicks(speedMin, speedMax, 6).ticks.forEach(v => {
     if (v < speedMin - 1e-9 || v > speedMax + 1e-9) return;
     const Y = sy(v);
     svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#eee' }));
     const t = svgEl('text', { x: ML - 6, y: Y + 4, 'text-anchor': 'end', 'font-size': '12', fill: '#444' });
     t.textContent = String(Math.round(v * 100) / 100);
     svg.appendChild(t);
   });
 
   svg.appendChild(svgEl('text', { x: ML + innerW / 2, y: H - 4, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' }))
     .textContent = 'Depth (m)';
   svg.appendChild(svgEl('text', {
     x: 18, y: MT + innerH / 2, transform: `rotate(-90,18,${MT + innerH / 2})`,
     'text-anchor': 'middle', 'font-size': '12', fill: '#444'
   })).textContent = 'Speed (m/s)';
 
+  const inlineLabels = [];
   extraProfiles.forEach(profile => {
     if (!profile || !Array.isArray(profile.segments)) return;
     const strokeColor = profile.color || '#555';
     const defaultDash = '6 4';
     const strokeDash = (profile.strokeDasharray === undefined) ? defaultDash : profile.strokeDasharray;
     const strokeWidth = Number.isFinite(profile.strokeWidth) ? profile.strokeWidth : 2;
+    let labelPlaced = false;
     profile.segments.forEach(seg => {
       if (!seg || !Number.isFinite(seg.speed_ms)) return;
       const depthEnd = Math.min(seg.depth_start, seg.depth_end);
       const depthStart = Math.max(seg.depth_start, seg.depth_end);
       if (Math.max(depthStart, depthEnd) < depthMin - 1e-9) return;
       if (Math.min(depthStart, depthEnd) > depthMax + 1e-9) return;
       if (seg.speed_ms < speedMin - 1e-9 || seg.speed_ms > speedMax + 1e-9) return;
       const x0 = sx(depthEnd);
       const x1 = sx(depthStart);
       if (Math.abs(x1 - x0) < 1e-6) return;
       const y = sy(seg.speed_ms);
       const attrs = {
         x1: x0,
         y1: y,
         x2: x1,
         y2: y,
         stroke: strokeColor,
         'stroke-width': strokeWidth
       };
       if (strokeDash) attrs['stroke-dasharray'] = strokeDash;
       svg.appendChild(svgEl('line', attrs));
+
+      if (!labelPlaced && profile.inlineLabel) {
+        const span = Math.abs(x1 - x0);
+        if (span >= 6) {
+          const midX = (x0 + x1) / 2;
+          const clampedX = Math.min(Math.max(midX, ML + 24), W - MR - 24);
+          const labelYRaw = y - 8;
+          const clampedY = Math.min(Math.max(labelYRaw, MT + 12), H - MB - 12);
+          inlineLabels.push({
+            text: profile.inlineLabel,
+            x: clampedX,
+            y: clampedY,
+            color: profile.inlineLabelColor || strokeColor
+          });
+          labelPlaced = true;
+        }
+      }
     });
   });
 
+  inlineLabels.forEach(label => {
+    const textAttrs = {
+      x: label.x,
+      y: label.y,
+      'text-anchor': 'middle',
+      'dominant-baseline': 'middle',
+      'font-size': '12',
+      fill: label.color,
+      style: 'paint-order: stroke; stroke: #fff; stroke-width: 3px;'
+    };
+    const textEl = svgEl('text', textAttrs);
+    textEl.textContent = label.text;
+    svg.appendChild(textEl);
+  });
+
   segments.forEach(S => {
     if (!Number.isFinite(S.speed_ms)) return;
     if (S.speed_ms < speedMin - 1e-9 || S.speed_ms > speedMax + 1e-9) return;
     const depthEnd = Math.min(S.depth_start, S.depth_end);
     const depthStart = Math.max(S.depth_start, S.depth_end);
     if (Math.max(depthStart, depthEnd) < depthMin - 1e-9) return;
     if (Math.min(depthStart, depthEnd) > depthMax + 1e-9) return;
     const x0 = sx(depthEnd);
     const x1 = sx(depthStart);
     if (Math.abs(x1 - x0) < 1e-6) return;
     const y = sy(S.speed_ms);
     const strokeColor = (Number.isFinite(ratedSpeedMs) && isAvailableBelowRated(ratedSpeedMs, S.speed_ms))
       ? EXCEED_COLOR
       : accentColor;
     svg.appendChild(svgEl('line', {
       x1: x0,
       y1: y,
       x2: x1,
       y2: y,
       stroke: strokeColor,
       'stroke-width': 4.8
     }));
   });
 
   segments.forEach(S => {
