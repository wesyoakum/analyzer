diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index b0e01d8351365040ec20dfd8de54c47a31d9217f..0f5cd2374d7095c3f3e9871e1299f4d4b8d4ef6c 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -73,50 +73,57 @@ export function drawDepthProfiles(svgSpeed, svgTension, {
     ? ['avail_tension_kgf', 't_avail_kgf', 'tAvail']
     : ['Tavail,start', 'Tavail_start', 'tavail_start', 'tavail_start_kgf', 'hyd_avail_tension_kgf'];
 
   // Build wrap intervals [depth_start, depth_end] with values
   const deadEnd = Number.isFinite(dead_end_m) ? Math.max(0, dead_end_m) : 0;
   const segments = wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd, scenario);
 
   // Sort deep to shallow by start depth
   segments.sort((a, b) => (b.depth_start || 0) - (a.depth_start || 0));
 
   // Extents
   const maxDepth = segments.length
     ? Math.max(...segments.map(S => Math.max(S.depth_start || 0, S.depth_end || 0)))
     : 0;
   const maxSpeedFromCandidates = segments.length
     ? Math.max(0, ...segments.map(S => {
         if (!Array.isArray(S.candidate_speeds_ms) || !S.candidate_speeds_ms.length) {
           return S.speed_ms || 0;
         }
         return Math.max(0, ...S.candidate_speeds_ms.map(C => C.value_ms), S.speed_ms || 0);
       }))
     : 0;
   const ratedSpeedMs = Number.isFinite(rated_speed_ms) ? Math.max(0, rated_speed_ms) : null;
   const maxAvailT = Math.max(0, ...segments.map(S => S.avail_tension_kgf || 0));
   const toNumber = val => {
+    if (val === null || val === undefined) return NaN;
+    if (typeof val === 'string') {
+      const trimmed = val.trim();
+      if (!trimmed) return NaN;
+      const parsed = Number(trimmed);
+      return Number.isFinite(parsed) ? parsed : NaN;
+    }
     const num = Number(val);
     return Number.isFinite(num) ? num : NaN;
   };
 
   let depthMin = toNumber(depth_xmin);
   if (!Number.isFinite(depthMin) || depthMin < 0) depthMin = 0;
 
   let depthMax = toNumber(depth_xmax);
   const autoDepthMax = Math.max(depthMin + 0.1, maxDepth);
   if (Number.isFinite(depthMax)) {
     depthMax = Math.max(depthMin + 0.1, depthMax);
   } else {
     depthMax = autoDepthMax;
   }
   if (depthMax <= depthMin) depthMax = depthMin + 1;
 
   let speedMin = toNumber(speed_ymin);
   if (!Number.isFinite(speedMin) || speedMin < 0) speedMin = 0;
 
   let speedMax = toNumber(speed_ymax);
   const autoSpeedMax = Math.max(speedMin + 0.1, 1, maxSpeedFromCandidates, ratedSpeedMs || 0);
   if (Number.isFinite(speedMax)) {
     speedMax = Math.max(speedMin + 0.1, speedMax);
   } else {
     speedMax = autoSpeedMax;
