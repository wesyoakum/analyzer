diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index c9888a015917d9c91fd566315bc8056887895458..599a67fb96823d8d84dfee75107497ee6a268fcb 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -43,51 +43,53 @@ function getAccentColor() {
  * @param {SVGSVGElement} svgSpeed
  * @param {SVGSVGElement} svgTension
  * @param {Object} opts
  * @param {'electric'|'hydraulic'} opts.scenario
  * @param {Array<Object>} opts.elWraps
  * @param {Array<Object>} opts.hyWraps
  * @param {number} opts.payload_kg
  * @param {number} opts.cable_w_kgpm
  * @param {number} [opts.dead_end_m=0]
  */
 export function drawDepthProfiles(svgSpeed, svgTension, {
   scenario = 'electric',
   elWraps = [],
   hyWraps = [],
   payload_kg = 0,
   cable_w_kgpm = 0,
   dead_end_m = 0,
   rated_speed_ms = null,
   operating_depth_m = null,
   rated_swl_kgf = null,
   depth_xmin = 0,
   depth_xmax = null,
   speed_ymin = 0,
   speed_ymax = null,
   tension_ymin = 0,
-  tension_ymax = null
+  tension_ymax = null,
+  speed_primary_label = null,
+  speed_extra_profiles = []
 } = {}) {
   const wraps = (scenario === 'electric') ? (elWraps || []) : (hyWraps || []);
   const speedField = (scenario === 'electric')
     ? 'line_speed_mpm'
     : ['vavail', 'vAvail', 'v_available', 'v_available_mpm', 'v_avail', 'hyd_speed_available_mpm'];
   const tensionField = (scenario === 'electric')
     ? ['avail_tension_kgf', 't_avail_kgf', 'tAvail']
     : ['Tavail,start', 'Tavail_start', 'tavail_start', 'tavail_start_kgf', 'hyd_avail_tension_kgf'];
 
   // Build wrap intervals [depth_start, depth_end] with values
   const deadEnd = Number.isFinite(dead_end_m) ? Math.max(0, dead_end_m) : 0;
   const segments = wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd, scenario);
 
   // Sort deep to shallow by start depth
   segments.sort((a, b) => (b.depth_start || 0) - (a.depth_start || 0));
 
   // Extents
   const maxDepth = segments.length
     ? Math.max(...segments.map(S => Math.max(S.depth_start || 0, S.depth_end || 0)))
     : 0;
   const maxSpeedFromCandidates = segments.length
     ? Math.max(0, ...segments.map(S => {
         if (!Array.isArray(S.candidate_speeds_ms) || !S.candidate_speeds_ms.length) {
           return S.speed_ms || 0;
         }
@@ -136,97 +138,136 @@ export function drawDepthProfiles(svgSpeed, svgTension, {
     speedMax = autoSpeedMax;
   }
   if (speedMax <= speedMin) speedMax = speedMin + 1;
 
   const tensionDepth = Math.max(maxDepth, depthMax);
   const maxTheoT = payload_kg + cable_w_kgpm * tensionDepth;
   const maxReqT = maxTheoT * TENSION_SAFETY_FACTOR;
 
   let tensionMin = toNumber(tension_ymin);
   if (!Number.isFinite(tensionMin) || tensionMin < 0) tensionMin = 0;
 
   let tensionMax = toNumber(tension_ymax);
   const swlTarget = Number.isFinite(ratedSwl) ? ratedSwl * 1.5 : 0;
   const autoTensionBase = Math.max(tensionMin + 1, maxReqT, maxAvailT, swlTarget);
   const autoTensionMax = autoTensionBase * 1.05;
   if (Number.isFinite(tensionMax)) {
     tensionMax = Math.max(tensionMin + 1, tensionMax);
   } else {
     tensionMax = autoTensionMax;
   }
   if (tensionMax <= tensionMin) tensionMax = tensionMin + 1;
 
   const accentColor = getAccentColor();
 
   // Render both
-  drawSpeedProfile(svgSpeed, segments, depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs);
+  drawSpeedProfile(svgSpeed, segments, depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs, {
+    primaryLabel: speed_primary_label,
+    extraProfiles: Array.isArray(speed_extra_profiles) ? speed_extra_profiles : []
+  });
   drawTensionProfile(svgTension, segments, depthMin, depthMax, tensionMin, tensionMax, payload_kg, cable_w_kgpm, accentColor);
 }
 
 // ---------- Speed vs Depth ----------
-function drawSpeedProfile(svg, segments, depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs = null) {
+function drawSpeedProfile(svg, segments, depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs = null, options = {}) {
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const ML = 64, MR = 18, MT = 18, MB = 46;
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
   const H = svg.viewBox.baseVal.height || svg.clientHeight || 540;
   const innerW = W - ML - MR, innerH = H - MT - MB;
 
   const clampDepth = d => Math.min(Math.max(d, depthMin), depthMax);
   const clampSpeed = v => Math.min(Math.max(v, speedMin), speedMax);
   const depthSpan = Math.max(1e-9, depthMax - depthMin);
   const speedSpan = Math.max(1e-9, speedMax - speedMin);
 
   const sx = d => ML + (clampDepth(d) - depthMin) / depthSpan * innerW;
   const sy = v => MT + (1 - (clampSpeed(v) - speedMin) / speedSpan) * innerH;
 
+  const extraProfiles = Array.isArray(options.extraProfiles) ? options.extraProfiles : [];
+  const legendEntries = [];
+  if (options.primaryLabel) {
+    legendEntries.push({ label: options.primaryLabel, color: accentColor });
+  }
+  extraProfiles.forEach(profile => {
+    if (!profile || !profile.label) return;
+    legendEntries.push({ label: profile.label, color: profile.color || '#555' });
+  });
+
   svg.appendChild(svgEl('rect', { x: ML, y: MT, width: innerW, height: innerH, fill: '#fff', stroke: '#ccc' }));
 
   niceTicks(depthMin, depthMax, 8).ticks.forEach(dx => {
     if (dx < depthMin - 1e-9 || dx > depthMax + 1e-9) return;
     const X = sx(dx);
     svg.appendChild(svgEl('line', { x1: X, y1: MT, x2: X, y2: H - MB, stroke: '#eee' }));
     const t = svgEl('text', { x: X, y: H - 8, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' });
     t.textContent = formatDepthLabel(dx);
     svg.appendChild(t);
   });
   niceTicks(speedMin, speedMax, 6).ticks.forEach(v => {
     if (v < speedMin - 1e-9 || v > speedMax + 1e-9) return;
     const Y = sy(v);
     svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#eee' }));
     const t = svgEl('text', { x: ML - 6, y: Y + 4, 'text-anchor': 'end', 'font-size': '12', fill: '#444' });
     t.textContent = String(Math.round(v * 100) / 100);
     svg.appendChild(t);
   });
 
   svg.appendChild(svgEl('text', { x: ML + innerW / 2, y: H - 4, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' }))
     .textContent = 'Depth (m)';
   svg.appendChild(svgEl('text', {
     x: 18, y: MT + innerH / 2, transform: `rotate(-90,18,${MT + innerH / 2})`,
     'text-anchor': 'middle', 'font-size': '12', fill: '#444'
   })).textContent = 'Speed (m/s)';
 
+  extraProfiles.forEach(profile => {
+    if (!profile || !Array.isArray(profile.segments)) return;
+    const strokeColor = profile.color || '#555';
+    profile.segments.forEach(seg => {
+      if (!seg || !Number.isFinite(seg.speed_ms)) return;
+      const depthEnd = Math.min(seg.depth_start, seg.depth_end);
+      const depthStart = Math.max(seg.depth_start, seg.depth_end);
+      if (Math.max(depthStart, depthEnd) < depthMin - 1e-9) return;
+      if (Math.min(depthStart, depthEnd) > depthMax + 1e-9) return;
+      if (seg.speed_ms < speedMin - 1e-9 || seg.speed_ms > speedMax + 1e-9) return;
+      const x0 = sx(depthEnd);
+      const x1 = sx(depthStart);
+      if (Math.abs(x1 - x0) < 1e-6) return;
+      const y = sy(seg.speed_ms);
+      svg.appendChild(svgEl('line', {
+        x1: x0,
+        y1: y,
+        x2: x1,
+        y2: y,
+        stroke: strokeColor,
+        'stroke-width': 2,
+        'stroke-dasharray': '6 4'
+      }));
+    });
+  });
+
   segments.forEach(S => {
     if (!Number.isFinite(S.speed_ms)) return;
     if (S.speed_ms < speedMin - 1e-9 || S.speed_ms > speedMax + 1e-9) return;
     const depthEnd = Math.min(S.depth_start, S.depth_end);
     const depthStart = Math.max(S.depth_start, S.depth_end);
     if (Math.max(depthStart, depthEnd) < depthMin - 1e-9) return;
     if (Math.min(depthStart, depthEnd) > depthMax + 1e-9) return;
     const x0 = sx(depthEnd);
     const x1 = sx(depthStart);
     if (Math.abs(x1 - x0) < 1e-6) return;
     const y = sy(S.speed_ms);
     const strokeColor = (Number.isFinite(ratedSpeedMs) && isAvailableBelowRated(ratedSpeedMs, S.speed_ms))
       ? EXCEED_COLOR
       : accentColor;
     svg.appendChild(svgEl('line', {
       x1: x0,
       y1: y,
       x2: x1,
       y2: y,
       stroke: strokeColor,
       'stroke-width': 4.8
     }));
   });
 
   segments.forEach(S => {
@@ -283,50 +324,73 @@ function drawSpeedProfile(svg, segments, depthMin, depthMax, speedMin, speedMax,
           y2: axisY,
           stroke: EXCEED_COLOR,
           'stroke-width': 2,
           'stroke-dasharray': '4 6'
         }));
 
         const labelText = formatDepthLabel(limit.depth);
         if (labelText) {
           const label = svgEl('text', {
             x,
             y: axisY + 20,
             'text-anchor': 'middle',
             'font-size': '12',
             fill: EXCEED_COLOR
           });
           label.textContent = `${labelText} m`;
           svg.appendChild(label);
         }
       }
     }
   }
 
   if (speedMin <= 0 && speedMax >= 0) {
     svg.appendChild(svgEl('line', { x1: ML, y1: sy(0), x2: W - MR, y2: sy(0), stroke: '#bbb', 'stroke-dasharray': '4 4' }));
   }
+
+  if (legendEntries.length) {
+    const legendGroup = svgEl('g', {});
+    const legendX = W - MR - 180;
+    let offsetY = 0;
+    legendEntries.forEach(entry => {
+      const g = svgEl('g', { transform: `translate(${legendX},${MT + 16 + offsetY})` });
+      g.appendChild(svgEl('line', {
+        x1: 0,
+        y1: 0,
+        x2: 22,
+        y2: 0,
+        stroke: entry.color || '#555',
+        'stroke-width': 3
+      }));
+      const text = svgEl('text', { x: 28, y: 4, 'font-size': '12', fill: '#333' });
+      text.textContent = entry.label;
+      g.appendChild(text);
+      legendGroup.appendChild(g);
+      offsetY += 18;
+    });
+    svg.appendChild(legendGroup);
+  }
 }
 
 function findRatedDepthLimit(segments, ratedSpeedMs) {
   if (!Array.isArray(segments) || !Number.isFinite(ratedSpeedMs) || ratedSpeedMs <= 0) return null;
   const ranges = segments
     .filter(S => Number.isFinite(S.speed_ms))
     .map(S => ({
       d0: Math.min(S.depth_start, S.depth_end),
       d1: Math.max(S.depth_start, S.depth_end),
       speed: S.speed_ms
     }))
     .sort((a, b) => a.d0 - b.d0);
 
   if (!ranges.length) return null;
 
   let deepestReach = null;
   let hasReachable = false;
 
   for (const range of ranges) {
     if (isRatedBelowAvailable(ratedSpeedMs, range.speed)) {
       hasReachable = true;
       deepestReach = (deepestReach === null) ? range.d1 : Math.max(deepestReach, range.d1);
       continue;
     }
 
