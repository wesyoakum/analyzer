diff --git a/src/js/persist-inputs.mjs b/src/js/persist-inputs.mjs
index 2e4ffa0300ea473f8399cc8881eabc4005d7c909..ccd9ef4bdc0d0b6fd385a66497a1a6c3e8f699f3 100644
--- a/src/js/persist-inputs.mjs
+++ b/src/js/persist-inputs.mjs
@@ -1,26 +1,26 @@
-const DEFAULT_STORAGE_KEY = 'analyzer.inputs.v2';
+export const DEFAULT_STORAGE_KEY = 'analyzer.inputs.v2';
 const SKIP_INPUT_TYPES = new Set([
   'button',
   'file',
   'hidden',
   'image',
   'password',
   'reset',
   'submit'
 ]);
 
 function isPersistable(el) {
   if (!el || !el.id || el.disabled) return false;
   if (el.dataset && el.dataset.persist === 'off') return false;
   if (el.tagName === 'INPUT' && SKIP_INPUT_TYPES.has(el.type)) return false;
   return true;
 }
 
 function readValue(el) {
   if (!el) return undefined;
   if (el.tagName === 'INPUT') {
     const type = el.type;
     if (type === 'checkbox') {
       return el.checked;
     }
     if (type === 'radio') {
@@ -165,26 +165,95 @@ export function setupInputPersistence({ storageKey = DEFAULT_STORAGE_KEY } = {})
   };
 
   const handler = (event) => {
     if (!targetSet.has(event.target)) return;
     schedule();
   };
 
   targets.forEach(el => {
     eventNamesFor(el).forEach(evt => {
       el.addEventListener(evt, handler);
     });
   });
 
   window.addEventListener('beforeunload', () => schedule(true));
   window.addEventListener('storage', evt => {
     if (evt.storageArea !== storage) return;
     if (evt.key && evt.key !== storageKey) return;
     const raw = evt.key === storageKey ? evt.newValue : storage.getItem(storageKey);
     state = parseState(raw);
     targets.forEach(el => {
       applyValue(el, state[el.id]);
     });
   });
 
   schedule();
-}
\ No newline at end of file
+}
+
+function resetElementToDefault(el) {
+  if (!el) return;
+  if (el instanceof HTMLInputElement) {
+    delete el.dataset.componentSelect;
+    delete el.dataset.componentPn;
+    if (el.type === 'checkbox' || el.type === 'radio') {
+      el.checked = el.defaultChecked;
+    } else {
+      el.value = el.defaultValue ?? '';
+    }
+    return;
+  }
+  if (el instanceof HTMLSelectElement) {
+    const options = Array.from(el.options);
+    if (el.multiple) {
+      options.forEach(opt => {
+        opt.selected = opt.defaultSelected;
+      });
+    } else {
+      const defaultOpt = options.find(opt => opt.defaultSelected);
+      if (defaultOpt) {
+        el.value = defaultOpt.value;
+      } else if (options.length) {
+        el.selectedIndex = 0;
+      } else {
+        el.value = '';
+      }
+    }
+    return;
+  }
+  if (el instanceof HTMLTextAreaElement) {
+    el.value = el.defaultValue ?? '';
+    return;
+  }
+  if ('textContent' in el) {
+    el.textContent = '';
+  }
+}
+
+function dispatchResetEvents(el) {
+  if (!el) return;
+  const events = eventNamesFor(el);
+  events.forEach(evt => {
+    el.dispatchEvent(new Event(evt, { bubbles: true }));
+  });
+}
+
+export function clearPersistedInputs({ storageKey = DEFAULT_STORAGE_KEY, triggerEvents = true } = {}) {
+  const storage = getStorage();
+  if (storage) {
+    try {
+      storage.removeItem(storageKey);
+    } catch (err) {
+      console.warn('Unable to clear persisted inputs:', err);
+    }
+  }
+
+  const targets = Array.from(document.querySelectorAll('input[id], select[id], textarea[id]'))
+    .filter(isPersistable);
+  if (!targets.length) return;
+
+  targets.forEach(el => {
+    resetElementToDefault(el);
+    if (triggerEvents) {
+      dispatchResetEvents(el);
+    }
+  });
+}
