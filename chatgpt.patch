diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index d81031e7e12fdc7a6e8e05a90c89e6d27162c528..ff6dac38f6a6f78cd3737fe18b4713c8b044387f 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -29,53 +29,56 @@ function getAccentColor() {
  */
 export function drawDepthProfiles(svgSpeed, svgTension, {
   scenario = 'electric',
   elWraps = [],
   hyWraps = [],
   payload_kg = 0,
   cable_w_kgpm = 0,
   dead_end_m = 0
 } = {}) {
   const wraps = (scenario === 'electric') ? (elWraps || []) : (hyWraps || []);
   const speedField = (scenario === 'electric') ? 'line_speed_mpm' : 'hyd_speed_available_mpm';
   const tensionField = (scenario === 'electric') ? 'avail_tension_kgf' : 'hyd_avail_tension_kgf';
 
   // Build wrap intervals [depth_start, depth_end] with values
   const deadEnd = Number.isFinite(dead_end_m) ? Math.max(0, dead_end_m) : 0;
   const segments = wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd, scenario);
 
   // Sort deep to shallow by start depth
   segments.sort((a, b) => (b.depth_start || 0) - (a.depth_start || 0));
 
   // Extents
   const maxDepth = segments.length
     ? Math.max(...segments.map(S => Math.max(S.depth_start || 0, S.depth_end || 0)))
     : 0;
   const maxSpeedFromCandidates = segments.length
-    ? Math.max(0, ...segments.map(S => Array.isArray(S.candidate_speeds_ms)
-      ? Math.max(0, ...S.candidate_speeds_ms, S.speed_ms || 0)
-      : (S.speed_ms || 0)))
+    ? Math.max(0, ...segments.map(S => {
+        if (!Array.isArray(S.candidate_speeds_ms) || !S.candidate_speeds_ms.length) {
+          return S.speed_ms || 0;
+        }
+        return Math.max(0, ...S.candidate_speeds_ms.map(C => C.value_ms), S.speed_ms || 0);
+      }))
     : 0;
   const maxSpeed = Math.max(1, maxSpeedFromCandidates);
   const maxAvailT = Math.max(0, ...segments.map(S => S.avail_tension_kgf || 0));
   const maxTheoT = payload_kg + cable_w_kgpm * maxDepth;
   const maxReqT = maxTheoT * TENSION_SAFETY_FACTOR;
   const maxTension = Math.max(maxReqT, maxAvailT) * 1.05 || 1;
 
   const accentColor = getAccentColor();
 
   // Render both
   drawSpeedProfile(svgSpeed, segments, maxDepth, maxSpeed, accentColor);
   drawTensionProfile(svgTension, segments, maxDepth, maxTension, payload_kg, cable_w_kgpm, accentColor);
 }
 
 // ---------- Speed vs Depth ----------
 function drawSpeedProfile(svg, segments, maxDepth, maxSpeed, accentColor) {
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const ML = 64, MR = 18, MT = 18, MB = 46;
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
   const H = svg.viewBox.baseVal.height || svg.clientHeight || 540;
   const innerW = W - ML - MR, innerH = H - MT - MB;
 
   const sx = d => ML + (d / Math.max(1e-9, maxDepth)) * innerW;       // X depth
   const sy = v => MT + (1 - v / Math.max(1e-9, maxSpeed)) * innerH;   // Y speed
@@ -101,61 +104,61 @@ function drawSpeedProfile(svg, segments, maxDepth, maxSpeed, accentColor) {
   svg.appendChild(svgEl('text', { x: ML + innerW / 2, y: H - 4, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' }))
      .textContent = 'Depth (m)';
   svg.appendChild(svgEl('text', {
     x: 18, y: MT + innerH / 2, transform: `rotate(-90,18,${MT + innerH / 2})`,
     'text-anchor': 'middle', 'font-size': '12', fill: '#444'
   })).textContent = 'Speed (m/s)';
 
   // available speed (accent)
   segments.forEach(S => {
     if (!Number.isFinite(S.speed_ms)) return;
     const y = sy(S.speed_ms);
     const depthEnd = Math.min(S.depth_start, S.depth_end);
     const depthStart = Math.max(S.depth_start, S.depth_end);
     const x0 = sx(depthEnd);
     const x1 = sx(depthStart);
     svg.appendChild(svgEl('line', {
       x1: x0,
       y1: y,
       x2: x1,
       y2: y,
       stroke: accentColor,
       'stroke-width': 4.8
     }));
   });
 
-  // candidate speeds (Vp light green, Vq light purple, dashed)
-    segments.forEach(S => {
+  // candidate speeds (Vp power-limited purple, Vq flow-limited green, dashed)
+  segments.forEach(S => {
     if (!Array.isArray(S.candidate_speeds_ms)) return;
     const depthEnd = Math.min(S.depth_start, S.depth_end);
     const depthStart = Math.max(S.depth_start, S.depth_end);
-    S.candidate_speeds_ms.forEach((val, idx) => {
-      if (!Number.isFinite(val)) return;
-      const y = sy(val);
+    S.candidate_speeds_ms.forEach(candidate => {
+      if (!candidate || !Number.isFinite(candidate.value_ms)) return;
+      const y = sy(candidate.value_ms);
       const x0 = sx(depthEnd);
       const x1 = sx(depthStart);
-      const stroke = (idx === 0) ? CANDIDATE_POWER_COLOR : CANDIDATE_FLOW_COLOR;
+      const stroke = (candidate.kind === 'flow') ? CANDIDATE_FLOW_COLOR : CANDIDATE_POWER_COLOR;
 
       svg.appendChild(svgEl('line', {
         x1: x0,
         y1: y,
         x2: x1,
         y2: y,
         stroke,
         'stroke-width': 2,
         'stroke-dasharray': '5 4'
       }));
     });
   });
 
   // zero line
   svg.appendChild(svgEl('line', { x1: ML, y1: sy(0), x2: W - MR, y2: sy(0), stroke: '#bbb', 'stroke-dasharray': '4 4' }));
 }
 
 // ---------- Tension vs Depth ----------
 function drawTensionProfile(svg, segments, maxDepth, maxTension, payload_kg, cable_w_kgpm, accentColor) {
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const ML = 64, MR = 18, MT = 18, MB = 46;
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
   const H = svg.viewBox.baseVal.height || svg.clientHeight || 540;
   const innerW = W - ML - MR, innerH = H - MT - MB;
@@ -350,58 +353,70 @@ function wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd = 0, scen
       depthStart = totalLen - preOn;
     } else if (Number.isFinite(fallbackStart)) {
       depthStart = fallbackStart;
     }
 
     if (!Number.isFinite(depthStart)) {
       depthStart = depthEnd;
     }
 
     if (depthStart < depthEnd) {
       const tmp = depthStart;
       depthStart = depthEnd;
       depthEnd = tmp;
     }
 
     const toDepth = (v) => {
       if (!Number.isFinite(v)) return 0;
       const adj = v - deadEnd;
       return +Math.max(0, adj).toFixed(3);
     };
     depthStart = toDepth(depthStart);
     depthEnd = toDepth(depthEnd);
 
     const speedValMpm = Number.isFinite(wrap[speedField]) ? wrap[speedField] : null;
     const candidateFields = (scenario === 'hydraulic')
-      ? ['hyd_speed_power_mpm', 'hyd_speed_flow_mpm']
+      ? [
+          { field: 'hyd_speed_power_mpm', kind: 'power' },
+          { field: 'hyd_speed_flow_mpm', kind: 'flow' }
+        ]
       : [];
-    /** @type {number[]} */
+    /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
     const candidateSpeedsMs = [];
-    for (const field of candidateFields) {
+    for (const { field, kind } of candidateFields) {
       const val = Number.isFinite(wrap[field]) ? wrap[field] : null;
       if (!Number.isFinite(val)) continue;
       const ms = val / 60;
-      if (Number.isFinite(ms)) candidateSpeedsMs.push(ms);
+      if (Number.isFinite(ms)) candidateSpeedsMs.push({ kind, value_ms: ms });
     }
 
     const speedMs = Number.isFinite(speedValMpm) ? speedValMpm / 60 : null;
-    const filteredCandidates = Array.from(new Set(
-      candidateSpeedsMs.filter(v => (speedMs === null) || Math.abs(v - speedMs) > 1e-6)
-    ));
+    /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
+    const filteredCandidates = [];
+    const seenKeys = new Set();
+    for (const candidate of candidateSpeedsMs) {
+      if (speedMs !== null && Math.abs(candidate.value_ms - speedMs) <= 1e-6) {
+        continue;
+      }
+      const key = `${candidate.kind}:${candidate.value_ms.toFixed(6)}`;
+      if (seenKeys.has(key)) continue;
+      seenKeys.add(key);
+      filteredCandidates.push(candidate);
+    }
     const tensionVal = Number.isFinite(wrap[tensionField]) ? wrap[tensionField] : null;
 
     segments.push({
       depth_start: depthStart,
       depth_end: depthEnd,
       speed_ms: speedMs,
       candidate_speeds_ms: filteredCandidates,
       avail_tension_kgf: Number.isFinite(tensionVal) ? tensionVal : null,
       label: Number.isFinite(wrap.wrap_no)
         ? `W${wrap.wrap_no}`
         : (Number.isFinite(wrap.layer_no) ? `L${wrap.layer_no}` : '')
     });
 
     fallbackStart = depthEnd + deadEnd;
   }
 
   return segments;
 }
