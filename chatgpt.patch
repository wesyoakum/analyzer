diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index b0e01d8351365040ec20dfd8de54c47a31d9217f..cdb09e972751a53fe1912db55e6e2a496fbca286 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -1,27 +1,27 @@
 // ===== plots/depth-profiles.mjs  Speed vs Depth & Tension vs Depth (DOM-agnostic) =====
-import { niceTicks, svgEl, TENSION_SAFETY_FACTOR } from '../utils.mjs';
+import { niceTicks, svgEl, TENSION_SAFETY_FACTOR, tension_kgf } from '../utils.mjs';
 
 const CANDIDATE_POWER_COLOR = '#9249c6'; // purple
 const CANDIDATE_FLOW_COLOR = '#eed500'; // yellow
 const EXCEED_COLOR = '#c65353'; // red
 const TENSION_THEORETICAL_COLOR = '#7c8fc5'; // matches legend swatch
 const RATED_SPEED_COLOR = '#888888'; // gray
 const PITA_PINK = 'e056e8'; // pink
 const CLARS_BLUE = '#2163a5'; // blue
 
 const RATED_AVAILABLE_TOLERANCE = 1e-9;
 
 function isRatedBelowAvailable(ratedSpeedMs, availableSpeedMs) {
   if (!Number.isFinite(ratedSpeedMs) || !Number.isFinite(availableSpeedMs)) return false;
   const diff = availableSpeedMs - ratedSpeedMs;
   if (!Number.isFinite(diff)) return false;
   const relTol = Number.EPSILON * Math.max(1, Math.abs(availableSpeedMs), Math.abs(ratedSpeedMs));
   const tolerance = Math.max(RATED_AVAILABLE_TOLERANCE, relTol);
   return diff > tolerance;
 }
 
 function isAvailableBelowRated(ratedSpeedMs, availableSpeedMs) {
   if (!Number.isFinite(ratedSpeedMs) || !Number.isFinite(availableSpeedMs)) return false;
   const diff = ratedSpeedMs - availableSpeedMs;
   if (!Number.isFinite(diff)) return false;
   const relTol = Number.EPSILON * Math.max(1, Math.abs(availableSpeedMs), Math.abs(ratedSpeedMs));
@@ -365,208 +365,289 @@ function drawTensionProfile(svg, segments, depthMin, depthMax, tensionMin, tensi
   niceTicks(tensionMin, tensionMax, 6).ticks.forEach(T => {
     if (T < tensionMin - 1e-9 || T > tensionMax + 1e-9) return;
     const Y = sy(T);
     svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#eee' }));
     const t = svgEl('text', { x: ML - 6, y: Y + 4, 'text-anchor': 'end', 'font-size': '12', fill: '#444' });
     t.textContent = String(Math.round(T));
     svg.appendChild(t);
   });
 
   svg.appendChild(svgEl('text', { x: ML + innerW / 2, y: H - 4, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' }))
     .textContent = 'Depth (m)';
   svg.appendChild(svgEl('text', {
     x: 18, y: MT + innerH / 2, transform: `rotate(-90,18,${MT + innerH / 2})`,
     'text-anchor': 'middle', 'font-size': '12', fill: '#444'
   })).textContent = 'Tension (kgf)';
 
   const normalizedSegments = segments.map(S => {
     const depthStartRaw = Math.max(S.depth_start, S.depth_end);
     const depthEndRaw = Math.min(S.depth_start, S.depth_end);
     if (!Number.isFinite(depthStartRaw) || !Number.isFinite(depthEndRaw)) return null;
     if (Math.max(depthStartRaw, depthEndRaw) < depthMin - 1e-9) return null;
     if (Math.min(depthStartRaw, depthEndRaw) > depthMax + 1e-9) return null;
     return {
       depth_start: clampDepth(depthStartRaw),
       depth_end: clampDepth(depthEndRaw),
-      avail_tension_kgf: Number.isFinite(S.avail_tension_kgf) ? S.avail_tension_kgf : null
+      avail_tension_kgf: Number.isFinite(S.avail_tension_kgf) ? S.avail_tension_kgf : null,
+      tension_required_end_kgf: Number.isFinite(S.tension_required_kgf) ? S.tension_required_kgf : null,
+      tension_theoretical_end_kgf: Number.isFinite(S.tension_theoretical_kgf) ? S.tension_theoretical_kgf : null
     };
   }).filter(Boolean);
 
-  segments.forEach(S => {
+  /** @type {Map<number, number>} */
+  const theoreticalByDepth = new Map();
+  /** @type {Map<number, number>} */
+  const requiredByDepth = new Map();
+
+  normalizedSegments.forEach(seg => {
+    if (Number.isFinite(seg.tension_theoretical_end_kgf)) {
+      theoreticalByDepth.set(seg.depth_end, seg.tension_theoretical_end_kgf);
+    }
+    if (Number.isFinite(seg.tension_required_end_kgf)) {
+      requiredByDepth.set(seg.depth_end, seg.tension_required_end_kgf);
+    }
+  });
+
+  const getTheoretical = (depth) => {
+    if (!Number.isFinite(depth)) return null;
+    if (theoreticalByDepth.has(depth)) return theoreticalByDepth.get(depth);
+    if (!Number.isFinite(payload_kg) || !Number.isFinite(cable_w_kgpm)) return null;
+    const val = tension_kgf(depth, payload_kg, cable_w_kgpm);
+    theoreticalByDepth.set(depth, val);
+    return val;
+  };
+
+  const getRequired = (depth) => {
+    if (!Number.isFinite(depth)) return null;
+    if (requiredByDepth.has(depth)) return requiredByDepth.get(depth);
+    const theo = getTheoretical(depth);
+    if (!Number.isFinite(theo)) return null;
+    const val = +(theo * TENSION_SAFETY_FACTOR).toFixed(1);
+    requiredByDepth.set(depth, val);
+    return val;
+  };
+
+  const segmentsWithValues = normalizedSegments.map(seg => {
+    const { depth_start, depth_end } = seg;
+    const theoreticalStart = getTheoretical(depth_start);
+    const theoreticalEnd = getTheoretical(depth_end);
+    const requiredStart = getRequired(depth_start);
+    const requiredEnd = getRequired(depth_end);
+    return {
+      ...seg,
+      tension_theoretical_start_kgf: theoreticalStart,
+      tension_theoretical_end_kgf: theoreticalEnd,
+      tension_required_start_kgf: requiredStart,
+      tension_required_end_kgf: requiredEnd
+    };
+  });
+
+  segmentsWithValues.forEach(S => {
     if (!Number.isFinite(S.avail_tension_kgf)) return;
     if (S.avail_tension_kgf < tensionMin - 1e-9 || S.avail_tension_kgf > tensionMax + 1e-9) return;
     const depthEnd = Math.min(S.depth_start, S.depth_end);
     const depthStart = Math.max(S.depth_start, S.depth_end);
     if (Math.max(depthStart, depthEnd) < depthMin - 1e-9) return;
     if (Math.min(depthStart, depthEnd) > depthMax + 1e-9) return;
     const x0 = sx(depthEnd);
     const x1 = sx(depthStart);
     if (Math.abs(x1 - x0) < 1e-6) return;
     const y = sy(S.avail_tension_kgf);
     svg.appendChild(svgEl('line', {
       x1: x0,
       y1: y,
       x2: x1,
       y2: y,
       stroke: accentColor,
       'stroke-width': 2,
       'stroke-dasharray': '6 4'
     }));
   });
 
   const drawPieces = (pieces, { strokeWidth = 2, dash = null } = {}) => {
     pieces.forEach(seg => {
       const d0 = clampDepth(seg.d0);
       const d1 = clampDepth(seg.d1);
       if (Math.abs(d1 - d0) < 1e-6) return;
       const pts = [
         [sx(d0), sy(seg.T0)],
         [sx(d1), sy(seg.T1)]
       ];
       const attrs = {
         d: pathFrom(pts),
         fill: 'none',
         stroke: seg.color,
         'stroke-width': strokeWidth
       };
       if (dash) attrs['stroke-dasharray'] = dash;
       svg.appendChild(svgEl('path', attrs));
     });
   };
 
-  const theoreticalPieces = buildTheoreticalCurve(depthMin, depthMax, payload_kg, cable_w_kgpm);
+  // Ensure theoretical map includes the visible bounds to keep the curve continuous
+  getTheoretical(depthMin);
+  getTheoretical(depthMax);
+
+  const theoreticalPieces = buildTheoreticalCurve(segmentsWithValues, depthMin, depthMax, getTheoretical);
   drawPieces(theoreticalPieces, { strokeWidth: 2, dash: '6 4' });
 
-  const requiredPieces = buildTensionSegments(normalizedSegments, payload_kg, cable_w_kgpm, depthMin, depthMax, {
-    factor: TENSION_SAFETY_FACTOR,
+  const requiredPieces = buildTensionSegments(segmentsWithValues, depthMin, depthMax, {
     colorBelow: accentColor,
     colorAbove: EXCEED_COLOR
   });
   drawPieces(requiredPieces, { strokeWidth: 2.4 });
 
   if (tensionMin <= 0 && tensionMax >= 0) {
     svg.appendChild(svgEl('line', { x1: ML, y1: sy(0), x2: W - MR, y2: sy(0), stroke: '#bbb', 'stroke-dasharray': '4 4' }));
   }
 
   function pathFrom(pts) {
     if (!pts.length) return '';
     let d = `M ${pts[0][0]} ${pts[0][1]}`;
     for (let i = 1; i < pts.length; i++) d += ` L ${pts[i][0]} ${pts[i][1]}`;
     return d;
   }
 }
 
-function buildTheoreticalCurve(depthMin, depthMax, payload_kg, cable_w_kgpm) {
+function buildTheoreticalCurve(segments, depthMin, depthMax, getTheoretical) {
   if (!Number.isFinite(depthMin) || !Number.isFinite(depthMax)) return [];
-  if (!Number.isFinite(payload_kg) || !Number.isFinite(cable_w_kgpm)) return [];
-
-  const clampedMin = Math.min(depthMin, depthMax);
-  const clampedMax = Math.max(depthMin, depthMax);
-  if (Math.abs(clampedMax - clampedMin) < 1e-9) return [];
-
-  return [{
-    d0: clampedMin,
-    d1: clampedMax,
-    color: TENSION_THEORETICAL_COLOR,
-    T0: payload_kg + cable_w_kgpm * clampedMin,
-    T1: payload_kg + cable_w_kgpm * clampedMax
-  }];
+
+  const depths = new Set([depthMin, depthMax]);
+  segments.forEach(seg => {
+    if (Number.isFinite(seg.depth_end)) depths.add(Math.min(Math.max(seg.depth_end, depthMin), depthMax));
+    if (Number.isFinite(seg.depth_start)) depths.add(Math.min(Math.max(seg.depth_start, depthMin), depthMax));
+  });
+
+  const sorted = [...depths].filter(d => Number.isFinite(d)).sort((a, b) => a - b);
+  const pieces = [];
+  for (let i = 0; i < sorted.length - 1; i++) {
+    const d0 = sorted[i];
+    const d1 = sorted[i + 1];
+    if (d1 - d0 < 1e-9) continue;
+    const T0 = getTheoretical(d0);
+    const T1 = getTheoretical(d1);
+    if (!Number.isFinite(T0) || !Number.isFinite(T1)) continue;
+    pieces.push({
+      d0,
+      d1,
+      color: TENSION_THEORETICAL_COLOR,
+      T0,
+      T1
+    });
+  }
+  return pieces;
 }
 
-function buildTensionSegments(segments, payload_kg, cable_w_kgpm, depthMin, depthMax, {
-  factor = 1,
+function buildTensionSegments(segments, depthMin, depthMax, {
   colorBelow,
   colorAbove
 } = {}) {
   const clampDepth = d => Math.min(Math.max(d, depthMin), depthMax);
   const boundaries = new Set([depthMin, depthMax]);
   segments.forEach(S => {
     boundaries.add(clampDepth(S.depth_end));
     boundaries.add(clampDepth(S.depth_start));
   });
   const sorted = [...boundaries].sort((a, b) => a - b);
 
   const pieces = [];
   for (let i = 0; i < sorted.length - 1; i++) {
     const d0 = sorted[i];
     const d1 = sorted[i + 1];
     if (d1 - d0 < 1e-9) continue;
     const mid = (d0 + d1) / 2;
     const seg = segments.find(S => mid >= Math.min(S.depth_end, S.depth_start) - 1e-9 && mid <= Math.max(S.depth_end, S.depth_start) + 1e-9);
-    const avail = seg ? seg.avail_tension_kgf : null;
-    const baseT0 = payload_kg + cable_w_kgpm * d0;
-    const baseT1 = payload_kg + cable_w_kgpm * d1;
-    const T0 = baseT0 * factor;
-    const T1 = baseT1 * factor;
+    if (!seg) continue;
+    const avail = seg.avail_tension_kgf;
+    const T0 = interpolateSegmentValue(seg, d0, 'tension_required');
+    const T1 = interpolateSegmentValue(seg, d1, 'tension_required');
+    if (!Number.isFinite(T0) || !Number.isFinite(T1)) continue;
 
-    if (!Number.isFinite(avail) || !Number.isFinite(factor) || factor <= 0) {
+    if (!Number.isFinite(avail)) {
       pieces.push({ d0, d1, color: colorBelow, T0, T1 });
       continue;
     }
 
     const above0 = T0 > avail + 1e-6;
     const above1 = T1 > avail + 1e-6;
 
     if (above0 === above1) {
       pieces.push({ d0, d1, color: above0 ? colorAbove : colorBelow, T0, T1 });
       continue;
     }
 
     const deltaT = T1 - T0;
     if (Math.abs(deltaT) < 1e-9) {
       pieces.push({ d0, d1, color: above0 ? colorAbove : colorBelow, T0, T1 });
       continue;
     }
 
     const frac = Math.min(Math.max((avail - T0) / deltaT, 0), 1);
     const dCross = d0 + frac * (d1 - d0);
     const Tcross = T0 + frac * deltaT;
     const firstColor = above0 ? colorAbove : colorBelow;
     const secondColor = above0 ? colorBelow : colorAbove;
 
     pieces.push({ d0, d1: dCross, color: firstColor, T0, T1: Tcross });
     pieces.push({ d0: dCross, d1, color: secondColor, T0: Tcross, T1 });
   }
 
   // Merge adjacent pieces of same color
   const merged = [];
   for (const piece of pieces) {
     if (!merged.length) {
       merged.push({ ...piece });
       continue;
     }
     const last = merged[merged.length - 1];
     if (piece.color === last.color && Math.abs(piece.d0 - last.d1) < 1e-6) {
       last.d1 = piece.d1;
       last.T1 = piece.T1;
     } else {
       merged.push({ ...piece });
     }
   }
   return merged;
 }
 
+function interpolateSegmentValue(segment, depth, fieldPrefix) {
+  if (!segment) return null;
+  const startDepth = Math.max(segment.depth_start, segment.depth_end);
+  const endDepth = Math.min(segment.depth_start, segment.depth_end);
+  const startVal = segment[`${fieldPrefix}_start_kgf`];
+  const endVal = segment[`${fieldPrefix}_end_kgf`];
+  if (Number.isFinite(startVal) && Number.isFinite(endVal)) {
+    if (Math.abs(startDepth - endDepth) < 1e-9) return startVal;
+    const frac = (depth - endDepth) / Math.max(startDepth - endDepth, 1e-9);
+    const clamped = Math.min(Math.max(frac, 0), 1);
+    return endVal + (startVal - endVal) * clamped;
+  }
+  if (Number.isFinite(endVal)) return endVal;
+  if (Number.isFinite(startVal)) return startVal;
+  return null;
+}
+
 function coerceNumeric(wrap, field) {
   if (!wrap) return null;
   const fields = Array.isArray(field) ? field : [field];
   for (const name of fields) {
     if (!name) continue;
     const raw = wrap[name];
     if (Number.isFinite(raw)) return raw;
     if (typeof raw === 'string') {
       const cleaned = raw.replace(/,/g, '').trim();
       if (!cleaned) continue;
       const parsed = Number.parseFloat(cleaned);
       if (Number.isFinite(parsed)) return parsed;
     }
   }
   return null;
 }
 
 function wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd = 0, scenario = 'electric') {
   /** @type {Array<Object>} */
   const segments = [];
   let fallbackStart = null;
 
   for (const wrap of wraps) {
     if (!wrap) continue;
     const totalLen = coerceNumeric(wrap, 'total_cable_len_m');
@@ -611,42 +692,52 @@ function wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd = 0, scen
         ]
       : [];
     /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
     const candidateSpeedsMs = [];
     for (const { field, kind } of candidateFields) {
       const val = coerceNumeric(wrap, field);
       if (!Number.isFinite(val)) continue;
       const ms = val / 60;
       if (Number.isFinite(ms)) candidateSpeedsMs.push({ kind, value_ms: ms });
     }
 
     const speedMs = Number.isFinite(speedValMpm) ? speedValMpm / 60 : null;
     /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
     const filteredCandidates = [];
     const seenKeys = new Set();
     for (const candidate of candidateSpeedsMs) {
       if (speedMs !== null && Math.abs(candidate.value_ms - speedMs) <= 1e-6) {
         continue;
       }
       const key = `${candidate.kind}:${candidate.value_ms.toFixed(6)}`;
       if (seenKeys.has(key)) continue;
       seenKeys.add(key);
       filteredCandidates.push(candidate);
     }
     const tensionVal = coerceNumeric(wrap, tensionField);
+    const requiredVal = coerceNumeric(wrap, [
+      'tension_required_kgf',
+      'tension_req_kgf'
+    ]);
+    const theoreticalVal = coerceNumeric(wrap, [
+      'tension_theoretical_kgf',
+      'tension_theo_kgf'
+    ]);
 
     segments.push({
       depth_start: depthStart,
       depth_end: depthEnd,
       speed_ms: speedMs,
       candidate_speeds_ms: filteredCandidates,
       avail_tension_kgf: Number.isFinite(tensionVal) ? tensionVal : null,
+      tension_required_kgf: Number.isFinite(requiredVal) ? requiredVal : null,
+      tension_theoretical_kgf: Number.isFinite(theoreticalVal) ? theoreticalVal : null,
       label: Number.isFinite(wrap.wrap_no)
         ? `W${wrap.wrap_no}`
         : (Number.isFinite(wrap.layer_no) ? `L${wrap.layer_no}` : '')
     });
 
     fallbackStart = depthEnd + deadEnd;
   }
 
   return segments;
 }
