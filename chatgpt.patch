diff --git a/src/js/main.mjs b/src/js/main.mjs
index 910341f6689bd3a5dc5d1ef36988d0b799e8363d..5ca4a2b665787064c590cc7b842c688674436f82 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -8,50 +8,52 @@ import {
   psi_from_torque_and_disp_Nm_cc, torque_per_motor_from_pressure_Pa,
   line_speed_mpm_from_motor_rpm, hp_from_psi_and_gpm,
   TENSION_SAFETY_FACTOR
 } from './utils.mjs';
 
 import { setupInputPersistence } from './persist-inputs.mjs';
 
 import { calcLayers } from './layer-engine.mjs';
 
 import {
   rowsToElectricLayer, projectElectricWraps, renderElectricTables
 } from './electric.mjs';
 
 import {
   rowsToHydraulicLayer, projectHydraulicWraps, renderHydraulicTables
 } from './hydraulic.mjs';
 
 import { drawWaveContours, drawWaveHeightContours } from './plots/wave-contours.mjs';
 import { drawDepthProfiles } from './plots/depth-profiles.mjs';
 import { setupComponentSelectors } from './component-selectors.mjs';
 import { renderDrumVisualization, clearDrumVisualization } from './drum-visual.mjs';
 
 // ---- App state for plots/tables ----
 let lastElLayer = [], lastElWraps = [];
 let lastHyLayer = [], lastHyWraps = [];
+/** @type {{ rows: any, summary: any, cfg: any, meta: any } | null} */
+let lastDrumState = null;
 
 const CSV_BUTTON_SPECS = {
   csv_el_layer: {
     filename: () => 'electric-layer.csv',
     columns: [
       'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
       'post_on_drum_m', 'post_deployed_m', 'max_tension_theoretical_kgf',
       'max_tension_required_kgf', 'max_torque_Nm', 'max_motor_torque_Nm',
       'motor_rpm_at_start', 'line_speed_at_start_mpm', 'avail_tension_kgf_at_start'
     ],
     header: [
       'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
       'post_on_drum_m', 'post_deployed_m', 'max_tension_theoretical_kgf',
       'max_tension_required_kgf', 'max_torque_Nm', 'max_motor_torque_Nm',
       'motor_rpm_at_start', 'line_speed_at_start_mpm', 'avail_tension_kgf_at_start'
     ],
     getRows: () => lastElLayer
   },
   csv_el_wraps: {
     filename: () => 'electric-wraps.csv',
     columns: [
       'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
       'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
       'tension_required_kgf', 'torque_Nm', 'motor_torque_Nm', 'motor_rpm',
       'line_speed_mpm', 'avail_tension_kgf'
@@ -97,50 +99,52 @@ const CSV_BUTTON_SPECS = {
       'tension_required_kgf', 'hyd_P_required_psi', 'hyd_speed_power_mpm',
       'hyd_speed_flow_mpm', 'hyd_speed_available_mpm', 'hyd_hp_used_at_available',
       'hyd_elec_input_hp_used', 'hyd_drum_torque_maxP_Nm', 'hyd_avail_tension_kgf'
     ],
     getRows: () => lastHyWraps
   }
 };
 
 const SYSTEM_TYPE_SELECT_ID = 'system_type_select';
 const DEFAULT_SYSTEM_TYPE = 'electric';
 
 // ---- Wire up events once DOM is ready ----
 document.addEventListener('DOMContentLoaded', () => {
   setupInputPersistence();
 
   setupComponentSelectors();
 
   setupCollapsibleToggles();
 
   setupDriveModeControls();
 
   setupCsvDownloads();
 
   setupPlotResizeToggles();
 
+  setupManualRefreshControls();
+
   setupAutoRecompute();
 
   updateBuildIndicator();
 
   setupTabs();
 
   document.querySelectorAll('.param-label').forEach(label => {
     const code = label.dataset.code;
     if (code) {
       label.setAttribute('title', code);
     }
   });
 
   // Wave plot controls
   q('wave_scenario').addEventListener('change', () => redrawPlots());
   ['wave_tmin', 'wave_tmax', 'wave_vmin', 'wave_vmax', 'wave_hmin', 'wave_hmax']
     .forEach(id => q(id).addEventListener('change', () => redrawPlots()));
 
   // Depth plot controls
   ['depth_xmin', 'depth_xmax', 'depth_speed_ymin', 'depth_speed_ymax', 'depth_tension_ymin', 'depth_tension_ymax']
     .forEach(id => q(id).addEventListener('change', () => redrawPlots()));
 
   // Initial compute
   computeAll();
 });
@@ -391,50 +395,79 @@ function setupCollapsibleToggles() {
   }
 }
 
 function setupPlotResizeToggles() {
   const toggles = document.querySelectorAll('[data-plot-pair-toggle]');
   toggles.forEach(btn => {
     const pair = btn.closest('[data-plot-pair]');
     if (!pair) return;
 
     const setState = (expanded) => {
       pair.classList.toggle('is-expanded', expanded);
       btn.textContent = expanded ? '[-]' : '[+]';
       btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
       btn.setAttribute('aria-label', expanded ? 'Collapse plots to two columns' : 'Expand plots to full width');
     };
 
     setState(pair.classList.contains('is-expanded'));
 
     btn.addEventListener('click', () => {
       const next = !pair.classList.contains('is-expanded');
       setState(next);
     });
   });
 }
 
+function setupManualRefreshControls() {
+  const statusEl = /** @type {HTMLElement|null} */ (document.getElementById('status'));
+
+  const updateStatus = (message) => {
+    if (statusEl) statusEl.textContent = message;
+  };
+
+  const plotButtons = document.querySelectorAll('[data-plot-refresh]');
+  plotButtons.forEach(btn => {
+    btn.addEventListener('click', () => {
+      redrawPlots();
+      updateStatus('plots refreshed');
+    });
+  });
+
+  const drumButton = /** @type {HTMLButtonElement|null} */ (document.querySelector('[data-drum-refresh]'));
+  if (drumButton) {
+    drumButton.addEventListener('click', () => {
+      if (lastDrumState) {
+        const { rows, summary, cfg, meta } = lastDrumState;
+        renderDrumVisualization(rows, summary, cfg, meta);
+        updateStatus('drum diagram refreshed');
+      } else {
+        computeAll();
+      }
+    });
+  }
+}
+
 function setupAutoRecompute() {
   const inputs = Array.from(document.querySelectorAll('input, select, textarea'));
   if (!inputs.length) return;
 
   const handler = () => computeAll();
 
   inputs.forEach(el => {
     if (el.tagName === 'SELECT') {
       el.addEventListener('change', handler);
       return;
     }
 
     if (el.tagName === 'INPUT') {
       const type = el.type;
       if (type === 'checkbox' || type === 'radio' || type === 'range' || type === 'color') {
         el.addEventListener('change', handler);
         return;
       }
     }
 
     el.addEventListener('input', handler);
     el.addEventListener('change', handler);
   });
 }
 
@@ -713,75 +746,77 @@ function computeAll() {
           const gpm_total_needed = Math.max(motors, 1) * gpm_per_motor_needed;
           const gpm_used = Math.min(gpm_total_needed, q_tot_gpm);
           hp_used_at_available = hp_from_psi_and_gpm(P_power_psi, gpm_used);
           if (hp_used_at_available > hp_tot_usable) hp_used_at_available = hp_tot_usable;
         }
 
         r.hyd_P_required_psi = Math.round(P_req_psi);
         r.hyd_speed_power_mpm = +speed_power_mpm.toFixed(2);
         r.hyd_speed_flow_mpm = +speed_flow_mpm.toFixed(2);
         r.hyd_speed_available_mpm = +speed_avail_mpm.toFixed(2);
         r.hyd_hp_used_at_available = +hp_used_at_available.toFixed(2);
         r.hyd_elec_input_hp_used = +((h_emotor_eff > 0 ? r.hyd_hp_used_at_available / h_emotor_eff : 0)).toFixed(2);
       } else {
         r.hyd_drum_torque_maxP_Nm = 0;
         r.hyd_avail_tension_kgf = 0;
         r.hyd_P_required_psi = 0;
         r.hyd_speed_power_mpm = 0;
         r.hyd_speed_flow_mpm = 0;
         r.hyd_speed_available_mpm = 0;
         r.hyd_hp_used_at_available = 0;
         r.hyd_elec_input_hp_used = 0;
       }
     }
 
     // ---- Drum visualization ----
+    lastDrumState = { rows, summary, cfg, meta };
     renderDrumVisualization(rows, summary, cfg, meta);
 
     // ---- Aggregate into per-layer tables ----
     lastElLayer = electricEnabled ? rowsToElectricLayer(rows, payload_kg, cable_w_kgpm, gr1, gr2, motors) : [];
     lastHyLayer = hydraulicEnabled ? rowsToHydraulicLayer(rows) : [];
     lastElWraps = electricEnabled ? projectElectricWraps(rows) : [];
     lastHyWraps = hydraulicEnabled ? projectHydraulicWraps(rows) : [];
 
     // ---- Render tables ----
     renderElectricTables(lastElLayer, lastElWraps, q('tbody_el_layer'), q('tbody_el_wraps'));
     renderHydraulicTables(lastHyLayer, lastHyWraps, q('tbody_hy_layer'), q('tbody_hy_wraps'));
 
     updateCsvButtonStates();
 
     // ---- Update status ----
     if (status) status.textContent = 'results updated';
 
     // ---- Draw plots ----
     redrawPlots();
   } catch (e) {
     console.error(e);
     if (errBox) errBox.textContent = 'ERROR: ' + (e && e.message ? e.message : e);
     if (status) status.textContent = 'error';
     clearMinimumSystemHp();
     lastElLayer = lastElWraps = lastHyLayer = lastHyWraps = [];
+    lastDrumState = null;
     clearDrumVisualization();
     clearPlots();
     updateCsvButtonStates();
   }
 }
 
 // ---- Plot redraw helper (uses decoupled plotting modules) ----
 function redrawPlots() {
   // Wave contours (optional - skip if controls/SVGs absent)
   const waveScenarioEl = /** @type {HTMLSelectElement|null} */ (document.getElementById('wave_scenario'));
   const waveTminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmin'));
   const waveTmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmax'));
   const waveVminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_vmin'));
   const waveVmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_vmax'));
   const waveHminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_hmin'));
   const waveHmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_hmax'));
   const waveSvg = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg'));
   const waveSvgHeight = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg_height'));
 
   const parseInput = (el) => {
     if (!el) return NaN;
     return parseFloat((el.value || '').replace(',', '.'));
   };
 
   if (waveScenarioEl && waveTminEl && waveTmaxEl && waveHmaxEl && waveSvg && waveSvgHeight) {
