diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index 9214070413dd23207ebe88846baacec94a44dd3f..fb8e433c1dcc17048989be0e5d778416c1f7573f 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -162,127 +162,113 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
   const widthPx = widthIn * scale;
   const heightPx = heightIn * scale;
   const viewWidth = widthPx + SVG_MARGIN * 2;
   const viewHeight = heightPx + SVG_MARGIN * 2;
 
   svg.setAttribute('viewBox', `0 0 ${viewWidth.toFixed(2)} ${viewHeight.toFixed(2)}`);
 
   const spoolLeft = SVG_MARGIN;
   const spoolRight = spoolLeft + widthPx;
   const centerY = SVG_MARGIN + heightPx / 2;
 
   const coreHeightPx = Math.max(0, (core_dia_in || 0) * scale);
   const coreWidthPx = Math.max(0, (flange_to_flange_in || 0) * scale);
 
   const layerStyles = uniqueLayers.map((layer, idx) => {
     const t = uniqueLayers.length > 1 ? idx / (uniqueLayers.length - 1) : 0;
     const baseColor = mixRgb(accentRgb, accentLightRgb, 0.25 + 0.55 * t);
     const fillColor = mixRgb(baseColor, paperRgb, 0.55);
     return {
       layer_no: layer.layer_no,
       fillColor: rgbToCss(fillColor, 0.82),
       strokeColor: rgbToCss(baseColor, 0.94)
     };
   });
 
-  const outerRectHeightPx = Math.max(0, Math.max(full_drum_dia_in || 0, derivedOuterRadiusIn * 2) * scale);
-  if (outerRectHeightPx > 0 && widthPx > 0) {
-    const outerFill = mixRgb(accentLightRgb, paperRgb, 0.3);
-    svg.appendChild(svgEl('rect', {
-      x: spoolLeft.toFixed(2),
-      y: (centerY - outerRectHeightPx / 2).toFixed(2),
-      width: widthPx.toFixed(2),
-      height: outerRectHeightPx.toFixed(2),
-      fill: rgbToCss(outerFill, 0.5),
-      stroke: rgbToCss(accentRgb, 0.45),
-      'stroke-width': 1.6
-    }));
-  }
-
   if (coreHeightPx > 0 && coreWidthPx > 0) {
     svg.appendChild(svgEl('rect', {
       x: spoolLeft.toFixed(2),
       y: (centerY - coreHeightPx / 2).toFixed(2),
       width: coreWidthPx.toFixed(2),
       height: coreHeightPx.toFixed(2),
-      fill: rgbToCss(ink900Rgb, 0.48),
+      fill: 'none',
       stroke: rgbToCss(ink900Rgb, 0.72),
-      'stroke-width': 1.2
+      'stroke-width': 1
     }));
   }
 
   const axisColor = rgbToCss(ink700Rgb, 0.18);
   svg.appendChild(svgEl('line', {
     x1: spoolLeft.toFixed(2),
     y1: centerY.toFixed(2),
     x2: spoolRight.toFixed(2),
     y2: centerY.toFixed(2),
     stroke: axisColor,
     'stroke-width': 1,
     'stroke-dasharray': '6 6'
   }));
 
   const cableRadiusPx = cable_dia_in > 0 ? (cable_dia_in / 2) * scale : 0;
   const cablePitchPx = cable_dia_in > 0 ? cable_dia_in * scale : 0;
 
   const wrapsByLayer = new Map();
   for (const row of rows) {
     wrapsByLayer.set(row.layer_no, (wrapsByLayer.get(row.layer_no) || 0) + 1);
   }
 
   if (cableRadiusPx > 0 && cablePitchPx > 0 && coreWidthPx > 0) {
     uniqueLayers.forEach((layer, idx) => {
       const wraps = wrapsByLayer.get(layer.layer_no) || 0;
       if (wraps <= 0) return;
       const style = layerStyles[idx];
       const centerOffsetIn = Number.isFinite(layer.center_dia_in) ? layer.center_dia_in / 2 : 0;
       const centerOffsetPx = centerOffsetIn * scale;
       const layerPhasePx = (layer.layer_no % 2 === 0) ? cablePitchPx / 2 : 0;
       const topY = centerY - centerOffsetPx;
       const bottomY = centerY + centerOffsetPx;
 
       for (let w = 0; w < wraps; w++) {
         const cx = spoolLeft + cableRadiusPx + layerPhasePx + w * cablePitchPx;
         if (cx - cableRadiusPx < spoolLeft - 1e-3) continue;
         if (cx + cableRadiusPx > spoolRight + 1e-3) continue;
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: topY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: style.fillColor,
           stroke: style.strokeColor,
-          'stroke-width': 1.4
+          'stroke-width': 1
         }));
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: bottomY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: style.fillColor,
           stroke: style.strokeColor,
-          'stroke-width': 1.4
+          'stroke-width': 1
         }));
       }
     });
   }
 
   // Summary & accessibility copy
   const cableLenDigits = cable_len_m >= 1000 ? 0 : cable_len_m >= 10 ? 1 : 2;
   const cableDiaDigits = cable_dia_mm >= 50 ? 0 : cable_dia_mm >= 10 ? 1 : 2;
   const layerWord = total_layers === 1 ? 'layer' : 'layers';
   const wrapWord = total_wraps === 1 ? 'wrap' : 'wraps';
   const summaryLine = `${fmt(cable_len_m, cableLenDigits)} m of ${fmt(cable_dia_mm, cableDiaDigits)} mm cable on ${fmt(total_layers, 0)} ${layerWord} with ${fmt(total_wraps, 0)} total ${wrapWord}`;
   const wrapsPerLayer = meta && Number.isFinite(meta.wraps_per_layer_used)
     ? ` (≈${fmt(meta.wraps_per_layer_used, 1)} wraps per layer)`
     : '';
   const geometryParts = [
     `core Ø ${fmt(core_dia_in, 2)} in`,
     `flange-to-flange ${fmt(flange_to_flange_in, 2)} in`,
     `Lebus liner ${fmt(lebus_thk_in, 3)} in`,
     `full drum Ø ${fmt(full_drum_dia_in, 2)} in`
   ];
   const geometryLine = `Drum geometry: ${geometryParts.join(', ')}.`;
   const summaryPlain = `${summaryLine}${wrapsPerLayer}. ${geometryLine}`;
 
   summaryEl.innerHTML = `<strong>${summaryLine}${wrapsPerLayer}.</strong> ${geometryLine}`;
   titleEl.textContent = `Winch drum cross-section with ${fmt(total_layers, 0)} ${layerWord}`;
