diff --git a/src/js/main.mjs b/src/js/main.mjs
index 87ef58ba8c1b7117d52e502bd7000a5cfefc993e..af5d57f21f5589bc368533de889836e5d81e83e9 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -396,74 +396,76 @@ function computeAll() {
     // Geometry & load inputs
         const wraps_override_input = read('wraps_override');
     const wraps_per_layer_override = (
       Number.isFinite(wraps_override_input) && wraps_override_input > 0
     ) ? wraps_override_input : undefined;
 
     const cfg = {
       cable_dia_mm: read('c_mm'),
       operating_depth_m: read('depth_m'),
       dead_end_m: read('dead_m'),
       core_dia_in: read('core_in'),
       flange_to_flange_in: read('ftf_in'),
       lebus_thk_in: read('lebus_in'),
       packing_factor: read('pack'),
       wraps_per_layer_override
     };
     const payload_kg = read('payload_kg');
     const cable_w_kgpm = read('c_w_kgpm');
 
     const rated_speed_mpm = read('rated_speed_mpm');
     const rated_swl_kgf = read('rated_swl_kgf');
     const system_efficiency = read('system_efficiency');
 
     updateMinimumSystemHp(rated_speed_mpm, rated_swl_kgf, system_efficiency);
 
+    const positiveOr = (value, fallback) => (Number.isFinite(value) && value > 0 ? value : fallback);
+
     // Shared drivetrain
-    const gr1 = read('gr1');
-    const gr2 = read('gr2');
-    const motors = read('motors');
-    const denom_mech = (gr1 || 1) * (gr2 || 1) * (motors || 1);
+    const gr1 = positiveOr(read('gr1'), 1);
+    const gr2 = positiveOr(read('gr2'), 1);
+    const motors = positiveOr(read('motors'), 1);
+    const denom_mech = gr1 * gr2 * motors;
 
     const electricEnabled = driveModeEnabled('electric');
     const hydraulicEnabled = driveModeEnabled('hydraulic');
 
     // Electric inputs
     const motor_max_rpm = read('motor_max_rpm');
-    const motor_hp = read('motor_hp');
+    const motor_hp = positiveOr(read('motor_hp'), 0);
     const motor_tmax = read('motor_tmax');
-    const P_per_motor_W = (Number.isFinite(motor_hp) ? motor_hp : 0) * W_PER_HP;
+    const P_per_motor_W = motor_hp * W_PER_HP;
 
     // Hydraulic inputs
-    const h_strings = read('h_pump_strings');
-    const h_emotor_hp = read('h_emotor_hp');
-    const h_emotor_eff = read('h_emotor_eff'); // electro-hydraulic efficiency
-    const h_emotor_rpm = read('h_emotor_rpm');
-    const h_pump_cc = read('h_pump_cc');
-    const h_max_psi = read('h_max_psi');
-    const h_hmot_cc = read('h_hmot_cc');
-    const h_hmot_rpm_cap = read('h_hmot_rpm_max');
+    const h_strings = positiveOr(read('h_pump_strings'), 0);
+    const h_emotor_hp = positiveOr(read('h_emotor_hp'), 0);
+    const h_emotor_eff = positiveOr(read('h_emotor_eff'), 0); // electro-hydraulic efficiency
+    const h_emotor_rpm = positiveOr(read('h_emotor_rpm'), 0);
+    const h_pump_cc = positiveOr(read('h_pump_cc'), 0);
+    const h_max_psi = positiveOr(read('h_max_psi'), 0);
+    const h_hmot_cc = positiveOr(read('h_hmot_cc'), 0);
+    const h_hmot_rpm_cap = positiveOr(read('h_hmot_rpm_max'), Infinity);
 
     // Usable hydraulic hp & flow from pump strings
     const hp_str_usable = h_emotor_hp * h_emotor_eff;
     const hp_tot_usable = hp_str_usable * h_strings;
     const q_str_gpm = gpm_from_cc_rev_and_rpm(h_pump_cc, h_emotor_rpm);
     const q_tot_gpm = q_str_gpm * h_strings;
 
     // Max-pressure torque per hydraulic motor and at drum (pressure-limited)
     const dP_Pa = h_max_psi * PSI_TO_PA;
     const torque_per_hmotor_maxP = torque_per_motor_from_pressure_Pa(dP_Pa, h_hmot_cc); // N·m per motor at max P
     const torque_at_drum_maxP_factor = Math.max(gr1, 1) * Math.max(gr2, 1) * Math.max(motors, 1);
 
     // Generate wraps from geometry
     const { rows, summary, meta } = calcLayers(cfg);
 
     const wrapsNoteEl = /** @type {HTMLTableCellElement|null} */ (document.getElementById('wraps_note'));
     if (wrapsNoteEl) {
       const calcWraps = meta && Number.isFinite(meta.wraps_per_layer_calc) ? meta.wraps_per_layer_calc : undefined;
       const display = (typeof calcWraps === 'number') ? calcWraps.toFixed(1) : '–';
       wrapsNoteEl.textContent = `Leave blank or set to 0 to use calculated wraps (always truncated to .0/.5). Auto-calculated wraps per layer: ${display}.`;
     }
 
     // Per-wrap calculations (electric + hydraulic)
     for (const r of rows) {
       // Base tension and torque at drum
@@ -498,60 +500,59 @@ function computeAll() {
         // Available line tension from motor torque cap
         r.avail_tension_kgf = elec_available_tension_kgf(motor_tmax, gr1, gr2, motors, radius_m);
       } else {
         r.motor_torque_Nm = 0;
         r.motor_rpm = 0;
         r.line_speed_mpm = 0;
         r.avail_tension_kgf = 0;
       }
 
       // ----- HYDRAULIC per wrap -----
       if (hydraulicEnabled) {
         // Pressure-limited drum torque and available tension
         const drum_T_pressure_max = torque_per_hmotor_maxP * torque_at_drum_maxP_factor; // N·m at drum
         r.hyd_drum_torque_maxP_Nm = +drum_T_pressure_max.toFixed(2);
         const hyd_avail_tension_N = drum_T_pressure_max / Math.max(radius_m, 1e-12);
         r.hyd_avail_tension_kgf = +(hyd_avail_tension_N / G).toFixed(1);
 
         // Pressure required for current torque (per motor)
         const drum_T = tension_N * radius_m;
         const torque_per_hmotor = drum_T / (Math.max(gr1, 1e-9) * Math.max(gr2, 1e-9) * Math.max(motors, 1));
         let P_req_psi = psi_from_torque_and_disp_Nm_cc(torque_per_hmotor, h_hmot_cc);
         if (!Number.isFinite(P_req_psi) || P_req_psi < 0) P_req_psi = 0;
 
         // Flow-limited speed
         const rpm_flow_per_motor = Math.min(
-          h_hmot_rpm_cap || Infinity,
+          h_hmot_rpm_cap,
           rpm_from_gpm_and_disp(q_tot_gpm / Math.max(motors, 1), h_hmot_cc)
         );
         const speed_flow_mpm = line_speed_mpm_from_motor_rpm(rpm_flow_per_motor, gr1, gr2, r.layer_dia_in);
 
         // Power-limited speed (cap pressure at max if P_req exceeds max)
         const P_power_psi = (P_req_psi > 0) ? Math.min(P_req_psi, h_max_psi) : 0;
-        const hp_elec_in_total = (Number.isFinite(h_emotor_hp) ? h_emotor_hp : 0) *
-          (Number.isFinite(h_strings) ? h_strings : 0);
-        const eff_total = Number.isFinite(h_emotor_eff) ? h_emotor_eff : 0;
+        const hp_elec_in_total = h_emotor_hp * h_strings;
+        const eff_total = h_emotor_eff;
 
         let speed_power_mpm = 0;
         if (hp_elec_in_total > 0 && eff_total > 0 && theoretical_tension > 0) {
           const tension_theoretical_N = theoretical_tension * G;
           if (tension_theoretical_N > 0) {
             const power_available_W = hp_elec_in_total * eff_total * W_PER_HP;
             const speed_power_mps = power_available_W / tension_theoretical_N;
             speed_power_mpm = speed_power_mps * 60;
           }
         }
         if (!Number.isFinite(speed_power_mpm) || speed_power_mpm < 0) speed_power_mpm = 0;
 
         let speed_avail_mpm = Math.min(speed_power_mpm, speed_flow_mpm);
         if (!Number.isFinite(speed_avail_mpm) || speed_avail_mpm < 0) speed_avail_mpm = 0;
 
         let hp_used_at_available = 0;
         if (speed_avail_mpm > 0 && P_power_psi > 0) {
           // Power used at the actual available speed
           const D_m = r.layer_dia_in * M_PER_IN;
           const drum_rpm_needed = speed_avail_mpm / (Math.PI * D_m);
           const motor_rpm_needed = drum_rpm_needed * (Math.max(gr1, 1) * Math.max(gr2, 1));
           const gpm_per_motor_needed = (motor_rpm_needed * h_hmot_cc) / CC_PER_GAL;
           const gpm_total_needed = Math.max(motors, 1) * gpm_per_motor_needed;
           const gpm_used = Math.min(gpm_total_needed, q_tot_gpm);
           hp_used_at_available = hp_from_psi_and_gpm(P_power_psi, gpm_used);
