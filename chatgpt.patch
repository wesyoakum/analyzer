diff --git a/main.js b/main.js
index 896e980c785e43cf3289570d7e9dcf02bab94df8..729f7e3d3933b8ee631b35925900fc28c86f14a7 100644
--- a/main.js
+++ b/main.js
@@ -1,27 +1,38 @@
 // Configuration management
 const CONFIG_KEY = 'winch_configs';
+const BIKITY_BASE_URL = (window.BIKITY_API_BASE || '').replace(/\/$/, '');
+const BIKITY_CONFIG_ENDPOINT_OVERRIDE = (window.BIKITY_CONFIG_ENDPOINT || '').replace(/\/$/, '');
+const BIKITY_DISABLE_SYNC = Boolean(window.BIKITY_DISABLE_SYNC);
+const CONFIG_SERVER_ENDPOINT = (BIKITY_CONFIG_ENDPOINT_OVERRIDE
+  ? BIKITY_CONFIG_ENDPOINT_OVERRIDE
+  : `${BIKITY_BASE_URL}/api/configs`).replace(/^\/\//, '/');
+
+const configServerState = {
+  disabled: typeof fetch !== 'function' || BIKITY_DISABLE_SYNC,
+  endpoint: CONFIG_SERVER_ENDPOINT
+};
 
 // Default configurations bundled with the app
 const DEFAULT_CONFIGS = {
   "CTW513": {
     winch_type: "hydraulic",
     winch_model: "CTW513",
     use_ahc: true,
     req_swl: 13000,
     req_speed: 90,
     wave_height: 3,
     wave_period: 10,
     avg_offset_speed: 0,
     sel_umb_dia: 41,
     sel_cable_length: 3500,
     sel_umb_weight: 1.2,
     sel_drum_core_dia: 70,
     sel_drum_lebus_thickness: 0.625,
     sel_drum_flange_dia: 110,
     sel_drum_flange_to_flange: 91.5,
     sel_drum_wraps_per_layer: 0,
     sel_payload_weight: 1537,
     sel_elec_motor_power: 150,
     sel_hyd_system_psi_max: 4000,
     sel_hyd_mech_efficiency: 0.85,
     sel_pinion_ratio: 5.24,
@@ -91,50 +102,129 @@ if (typeof Chart !== 'undefined') {
     beforeDraw: (chart, args, opts) => {
       const {left, top, width, height} = chart.chartArea;
       const ctx = chart.ctx;
       ctx.save();
       ctx.fillStyle = opts.color || '#212121';
       ctx.fillRect(left, top, width, height);
       ctx.restore();
     }
   });
 }
 
 function getConfigs() {
   try {
     const stored = JSON.parse(localStorage.getItem(CONFIG_KEY)) || {};
     const merged = { ...DEFAULT_CONFIGS, ...stored };
     const missing = Object.keys(DEFAULT_CONFIGS).filter(k => !(k in stored));
     if (missing.length > 0) {
       localStorage.setItem(CONFIG_KEY, JSON.stringify(merged));
     }
     return merged;
   } catch (e) {
     return { ...DEFAULT_CONFIGS };
   }
 }
 
+function configServerAvailable() {
+  return !configServerState.disabled && typeof fetch === 'function';
+}
+
+function disableConfigServer(err) {
+  if (!configServerState.disabled) {
+    console.warn('Disabling configuration server sync', err);
+  }
+  configServerState.disabled = true;
+}
+
+async function requestConfigServer(path = '', options = {}) {
+  if (!configServerAvailable()) return null;
+  try {
+    const { ignoreNotFound, headers: customHeaders, ...fetchOptions } = options;
+    const response = await fetch(`${configServerState.endpoint}${path}`, {
+      cache: 'no-store',
+      headers: {
+        'Content-Type': 'application/json',
+        ...(customHeaders || {})
+      },
+      ...fetchOptions
+    });
+    if (!response.ok) {
+      if (response.status === 404 && ignoreNotFound) {
+        return null;
+      }
+      const error = new Error(`Server responded with ${response.status}`);
+      if (response.status === 404 || response.status >= 500) {
+        disableConfigServer(error);
+      } else {
+        console.warn('Configuration server request failed', error);
+      }
+      return null;
+    }
+    if (response.status === 204) {
+      return null;
+    }
+    const contentType = response.headers.get('content-type');
+    if (contentType && contentType.includes('application/json')) {
+      return await response.json();
+    }
+    return null;
+  } catch (err) {
+    disableConfigServer(err);
+    return null;
+  }
+}
+
+async function refreshConfigsFromServer() {
+  if (!configServerAvailable()) {
+    return getConfigs();
+  }
+  const data = await requestConfigServer('', { method: 'GET' });
+  if (!data || typeof data !== 'object' || typeof data.configs !== 'object') {
+    return getConfigs();
+  }
+  const local = getConfigs();
+  const merged = { ...local, ...data.configs };
+  saveConfigs(merged);
+  return merged;
+}
+
+async function syncConfigToServer(name, config) {
+  if (!configServerAvailable()) return;
+  await requestConfigServer(`/${encodeURIComponent(name)}`, {
+    method: 'PUT',
+    body: JSON.stringify(config || {})
+  });
+}
+
+async function deleteConfigFromServer(name) {
+  if (!configServerAvailable()) return;
+  await requestConfigServer(`/${encodeURIComponent(name)}`, {
+    method: 'DELETE',
+    ignoreNotFound: true
+  });
+}
+
 function calculateWinchPerformance(inputs, wraps) {
   try {
     if (typeof math === 'undefined' || !math.unit) {
       throw new Error('math.js library is required for calculateWinchPerformance');
     }
     const u = math.unit;
 
     const toMeters = x => u(x, 'inch').toNumber('m');
     const totalGearRatio = (inputs.sel_pinion_ratio || 1) * (inputs.sel_gearbox_ratio || 1);
 
     const cableWeight = inputs.sel_umb_weight; // kgf per m
     const payload = inputs.sel_payload_weight; // kgf
     const cableLength = inputs.sel_cable_length || 0; // total length of cable
 
     const g = 9.80665; // N per kgf
 
     const perf = [];
 
     if (inputs.winch_type === 'electric') {
       const torque = inputs.sel_motor_torque * inputs.sel_motor_count * totalGearRatio; // N*m
       const power = inputs.sel_motor_power * inputs.sel_motor_count * (inputs.sel_motor_eff || 1); // W
       const rpm = inputs.sel_motor_rpm; // 1/min
 
       wraps.forEach(l => {
         const radius = toMeters(l.diameter_in) / 2;
@@ -930,140 +1020,150 @@ function tryCalculateAndDisplay() {
     const drum = calculateDrumLayers(inputs);
     const perf = calculateWinchPerformance(inputs, drum.wraps);
     const combined = combineResults(inputs, drum.wraps, perf);
     displayResults({ ...drum, combined }, inputs);
   } else {
     clearResults();
   }
 }
 
 function loadConfig(name) {
   clearInputs();
   const configs = getConfigs();
   if (configs[name]) {
     fillInputs(configs[name]);
         updateFieldVisibility();
     console.log('loadConfig', name, configs[name]);
     tryCalculateAndDisplay();
   }
 }
 
 function saveCurrentConfig() {
   const name = document.getElementById('configSelect').value;
   const configs = getConfigs();
   configs[name] = readInputs();
   saveConfigs(configs);
+  syncConfigToServer(name, configs[name]);
 }
 
 function addNewConfig() {
   const name = prompt('New configuration name:');
   if (!name) return;
   const configs = getConfigs();
   if (configs[name]) {
     alert('Configuration already exists');
     return;
   }
   configs[name] = readInputs();
   saveConfigs(configs);
+  syncConfigToServer(name, configs[name]);
   populateConfigSelect();
   document.getElementById('configSelect').value = name;
 }
 
 function deleteConfig() {
   const select = document.getElementById('configSelect');
   const name = select.value;
   if (!confirm(`Delete configuration "${name}"?`)) return;
   const configs = getConfigs();
   delete configs[name];
   saveConfigs(configs);
+  deleteConfigFromServer(name);
   populateConfigSelect();
   if (select.options.length) {
     select.value = select.options[0].value;
     loadConfig(select.value);
   } else {
     clearResults();
   }
 }
 
 function renameConfig() {
   const select = document.getElementById('configSelect');
   const oldName = select.value;
   const newName = prompt('New name:', oldName);
   if (!newName || newName === oldName) return;
   const configs = getConfigs();
   if (configs[newName]) {
     alert('A configuration with that name already exists');
     return;
   }
   configs[newName] = configs[oldName];
   delete configs[oldName];
   saveConfigs(configs);
+  syncConfigToServer(newName, configs[newName]);
+  deleteConfigFromServer(oldName);
   populateConfigSelect();
   select.value = newName;
 }
 
 function exportConfigs() {
   const data = JSON.stringify(getConfigs());
   const blob = new Blob([data], {type: 'application/json'});
   const url = URL.createObjectURL(blob);
   const a = document.createElement('a');
   a.href = url;
   a.download = 'configs.json';
   a.click();
   URL.revokeObjectURL(url);
 }
 
 function importConfigs(file) {
   const reader = new FileReader();
   reader.onload = e => {
     try {
       const obj = JSON.parse(e.target.result);
       const configs = getConfigs();
       Object.assign(configs, obj);
       saveConfigs(configs);
+      Object.entries(obj).forEach(([name, cfg]) => {
+        syncConfigToServer(name, cfg);
+      });
       populateConfigSelect();
     } catch (err) {
       alert('Invalid configuration file');
     }
   };
   reader.readAsText(file);
 }
 
 // Form submission
 document.getElementById('inputForm').addEventListener('submit', function (event) {
   event.preventDefault();
   updateFieldVisibility();
   tryCalculateAndDisplay();
 });
 
 // Configuration button handlers
-window.addEventListener('DOMContentLoaded', () => {
+window.addEventListener('DOMContentLoaded', async () => {
+  await refreshConfigsFromServer();
   populateConfigSelect();
   const select = document.getElementById('configSelect');
   if (getConfigs()['CTW513']) {
     select.value = 'CTW513';
-  }  if (select.value) loadConfig(select.value);
+  }
+  if (select.value) loadConfig(select.value);
   updateFieldVisibility();
 
   document.getElementById('winch_type').addEventListener('change', updateFieldVisibility);
   document.getElementById('configAdd').addEventListener('click', addNewConfig);
   document.getElementById('configSave').addEventListener('click', () => {
     saveCurrentConfig();
   });
   document.getElementById('configDelete').addEventListener('click', deleteConfig);
   document.getElementById('configRename').addEventListener('click', renameConfig);
   document.getElementById('configExport').addEventListener('click', exportConfigs);
   document.getElementById('configImport').addEventListener('click', () => {
     document.getElementById('configImportInput').click();
   });
   document.getElementById('configImportInput').addEventListener('change', e => {
     if (e.target.files[0]) {
       importConfigs(e.target.files[0]);
     }
     e.target.value = '';
   });
   document.querySelectorAll('#inputForm input, #inputForm select').forEach(el => {
     el.addEventListener('input', () => {
       updateFieldVisibility();
       tryCalculateAndDisplay();
     });
   });
