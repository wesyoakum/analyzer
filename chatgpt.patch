diff --git a/src/js/plots/wave-contours.mjs b/src/js/plots/wave-contours.mjs
index 7cfc6e4d33adba9ea0e8f95040d7e9da45e72acc..946d7110fe9b09362160d61ae8e58166baee48c7 100644
--- a/src/js/plots/wave-contours.mjs
+++ b/src/js/plots/wave-contours.mjs
@@ -206,87 +206,142 @@ function renderWavePlot(svg, {
         x: W - MR - 2,
         y: Y - 3,
         'text-anchor': 'end',
         'font-size': '11',
         fill: accentColor
       });
       lbl.textContent = `L${L.layer_no} (${L.v_ms.toFixed(2)} m/s)`;
       svg.appendChild(lbl);
     });
 
     if (contourLabelLayer.childNodes.length) {
       svg.appendChild(contourLabelLayer);
     }
 
     hoverLayer = svgEl('g', { 'pointer-events': 'none' });
     const hoverLine = svgEl('line', {
       x1: ML,
       x2: ML,
       y1: MT,
       y2: H - MB,
       stroke: accentColor,
       'stroke-width': 1.5,
       'stroke-dasharray': '6 4',
       opacity: 0
     });
+    const hoverHLine = svgEl('line', {
+      x1: ML,
+      x2: W - MR,
+      y1: MT,
+      y2: MT,
+      stroke: accentColor,
+      'stroke-width': 1.5,
+      'stroke-dasharray': '6 4',
+      opacity: 0
+    });
     const hoverLabel = svgEl('text', {
       x: ML,
       y: H - MB + 20,
       'text-anchor': 'middle',
       'font-size': '12',
       fill: accentColor,
       opacity: 0
     });
+    const hoverYLabel = svgEl('text', {
+      x: ML - 8,
+      y: MT,
+      'text-anchor': 'end',
+      'font-size': '12',
+      fill: accentColor,
+      opacity: 0
+    });
     hoverLayer.appendChild(hoverLine);
+    hoverLayer.appendChild(hoverHLine);
     hoverLayer.appendChild(hoverLabel);
+    hoverLayer.appendChild(hoverYLabel);
     svg.appendChild(hoverLayer);
 
     const clamp = (val, min, max) => Math.min(Math.max(val, min), max);
-    const updateHover = evt => {
+    const toViewBoxPoint = evt => {
+      if (typeof DOMPoint === 'function' && svg.getScreenCTM) {
+        const ctm = svg.getScreenCTM();
+        if (ctm && typeof ctm.inverse === 'function') {
+          const point = new DOMPoint(evt.clientX, evt.clientY);
+          const svgPoint = point.matrixTransform(ctm.inverse());
+          return { x: svgPoint.x, y: svgPoint.y };
+        }
+      }
+
       const rect = svg.getBoundingClientRect();
-      const localX = evt.clientX - rect.left;
-      if (localX < ML || localX > W - MR) {
+      const vb = svg.viewBox.baseVal;
+      const vbWidth = vb && vb.width ? vb.width : rect.width;
+      const vbHeight = vb && vb.height ? vb.height : rect.height;
+      const offsetX = vb && vb.x ? vb.x : 0;
+      const offsetY = vb && vb.y ? vb.y : 0;
+      const scaleX = rect.width ? vbWidth / rect.width : 1;
+      const scaleY = rect.height ? vbHeight / rect.height : 1;
+      return {
+        x: offsetX + (evt.clientX - rect.left) * scaleX,
+        y: offsetY + (evt.clientY - rect.top) * scaleY
+      };
+    };
+    const updateHover = evt => {
+      const { x: localX, y: localY } = toViewBoxPoint(evt);
+      if (localX < ML || localX > W - MR || localY < MT || localY > H - MB) {
         hoverLine.setAttribute('opacity', '0');
         hoverLabel.setAttribute('opacity', '0');
+        hoverHLine.setAttribute('opacity', '0');
+        hoverYLabel.setAttribute('opacity', '0');
         return;
       }
 
       const clampedX = clamp(localX, ML, W - MR);
+      const clampedY = clamp(localY, MT, H - MB);
       const T = Tmin + ((clampedX - ML) / Math.max(innerW, 1e-9)) * (Tmax - Tmin);
+      const yValue = yMax - ((clampedY - MT) / Math.max(innerH, 1e-9)) * (yMax - yMin);
       hoverLine.setAttribute('x1', clampedX);
       hoverLine.setAttribute('x2', clampedX);
       hoverLine.setAttribute('opacity', '1');
+      hoverHLine.setAttribute('y1', clampedY);
+      hoverHLine.setAttribute('y2', clampedY);
+      hoverHLine.setAttribute('opacity', '1');
 
       const displayT = Math.round(T * 10) / 10;
+      const displayY = Math.round(yValue * 10) / 10;
       hoverLabel.setAttribute('x', clampedX);
       hoverLabel.textContent = `${displayT.toFixed(1)} sec`;
       hoverLabel.setAttribute('opacity', '1');
+      hoverYLabel.setAttribute('y', clampedY + 4);
+      hoverYLabel.textContent = `${displayY.toFixed(1)} ${mode === 'speed' ? 'm/s' : 'm'}`;
+      hoverYLabel.setAttribute('opacity', '1');
     };
 
     const hideHover = () => {
       hoverLine.setAttribute('opacity', '0');
       hoverLabel.setAttribute('opacity', '0');
+      hoverHLine.setAttribute('opacity', '0');
+      hoverYLabel.setAttribute('opacity', '0');
     };
 
     svg.addEventListener('pointermove', updateHover);
     svg.addEventListener('pointerenter', updateHover);
     svg.addEventListener('pointerleave', hideHover);
     svg._waveHoverHandlers = { move: updateHover, leave: hideHover };
   } else {
     // iso-speed contour lines (H = v·T / π) for integer and half-integer speeds
     const speedStep = 0.5;
     const maxIsoSpeed = Math.PI * Hmax / Math.max(Tmin, 1e-9);
     for (let v = speedStep; v <= maxIsoSpeed + 1e-9; v += speedStep) {
       const TmaxForLine = Math.min(Tmax, (Hmax * Math.PI) / Math.max(v, 1e-12));
       if (TmaxForLine <= Tmin + 1e-6) continue;
 
       const minH = (v * Tmin) / Math.PI;
       const maxH = (v * TmaxForLine) / Math.PI;
       if (maxH < Hmin - 1e-6 || minH > Hmax + 1e-6) continue;
 
       const pts = [];
       const samples = 200;
       for (let i = 0; i <= samples; i++) {
         const T = Tmin + (TmaxForLine - Tmin) * i / samples;
         const Hline = (v * T) / Math.PI;
         pts.push([sx(T), sy(Hline)]);
       }
