diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index bf049811aabd57ed03d520284bf90c6b1fa36a60..9214070413dd23207ebe88846baacec94a44dd3f 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -118,54 +118,60 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
 
   const { total_layers, total_wraps, cable_len_m, full_drum_dia_in } = summary;
   const {
     cable_dia_mm,
     core_dia_in,
     flange_to_flange_in,
     lebus_thk_in
   } = cfg;
 
   const cable_dia_in = Math.max(0, (cable_dia_mm || 0) * IN_PER_MM);
 
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const styles = getComputedStyle(document.documentElement);
   const accentRgb = parseCssColor(cssVar(styles, '--accent', FALLBACK_HEX.accent), FALLBACK_COLORS.accent);
   const accentLightRgb = parseCssColor(cssVar(styles, '--accent-light', FALLBACK_HEX.accentLight), FALLBACK_COLORS.accentLight);
   const ink700Rgb = parseCssColor(cssVar(styles, '--ink-700', FALLBACK_HEX.ink700), FALLBACK_COLORS.ink700);
   const ink900Rgb = parseCssColor(cssVar(styles, '--ink-900', FALLBACK_HEX.ink900), FALLBACK_COLORS.ink900);
   const paperRgb = parseCssColor(cssVar(styles, '--paper', FALLBACK_HEX.paper), FALLBACK_COLORS.paper);
 
   const uniqueLayers = [];
   const seen = new Set();
   for (const row of rows) {
     if (seen.has(row.layer_no)) continue;
     seen.add(row.layer_no);
-    uniqueLayers.push({ layer_no: row.layer_no, outer_dia_in: row.layer_dia_in });
+    uniqueLayers.push({ layer_no: row.layer_no, center_dia_in: row.layer_dia_in });
   }
-  
-  const derivedOuterRadiusIn = Math.max(0, (core_dia_in || 0) / 2 + (lebus_thk_in || 0) + cable_dia_in * uniqueLayers.length);
+
+  const maxCenterlineRadiusIn = uniqueLayers.reduce((max, layer) => {
+    const radius = Number.isFinite(layer.center_dia_in) ? layer.center_dia_in / 2 : 0;
+    return Math.max(max, radius);
+  }, 0);
+  const derivedOuterRadiusIn = maxCenterlineRadiusIn > 0
+    ? maxCenterlineRadiusIn + (cable_dia_in > 0 ? cable_dia_in / 2 : 0)
+    : Math.max(0, (core_dia_in || 0) / 2 + (lebus_thk_in || 0) + (cable_dia_in > 0 ? cable_dia_in / 2 : 0));
   const outerDiaIn = Math.max(
     Math.max(full_drum_dia_in || 0, derivedOuterRadiusIn * 2),
     core_dia_in || 0,
     cable_dia_in || 0,
     1
   );
   const heightIn = outerDiaIn;
   const scale = heightIn > 0 ? (SVG_BASE_HEIGHT - 2 * SVG_MARGIN) / heightIn : 1;
   const widthIn = Math.max(flange_to_flange_in || 0, cable_dia_in || 0, 1);
   const widthPx = widthIn * scale;
   const heightPx = heightIn * scale;
   const viewWidth = widthPx + SVG_MARGIN * 2;
   const viewHeight = heightPx + SVG_MARGIN * 2;
 
   svg.setAttribute('viewBox', `0 0 ${viewWidth.toFixed(2)} ${viewHeight.toFixed(2)}`);
 
   const spoolLeft = SVG_MARGIN;
   const spoolRight = spoolLeft + widthPx;
   const centerY = SVG_MARGIN + heightPx / 2;
 
   const coreHeightPx = Math.max(0, (core_dia_in || 0) * scale);
   const coreWidthPx = Math.max(0, (flange_to_flange_in || 0) * scale);
 
   const layerStyles = uniqueLayers.map((layer, idx) => {
     const t = uniqueLayers.length > 1 ? idx / (uniqueLayers.length - 1) : 0;
@@ -193,72 +199,71 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
   }
 
   if (coreHeightPx > 0 && coreWidthPx > 0) {
     svg.appendChild(svgEl('rect', {
       x: spoolLeft.toFixed(2),
       y: (centerY - coreHeightPx / 2).toFixed(2),
       width: coreWidthPx.toFixed(2),
       height: coreHeightPx.toFixed(2),
       fill: rgbToCss(ink900Rgb, 0.48),
       stroke: rgbToCss(ink900Rgb, 0.72),
       'stroke-width': 1.2
     }));
   }
 
   const axisColor = rgbToCss(ink700Rgb, 0.18);
   svg.appendChild(svgEl('line', {
     x1: spoolLeft.toFixed(2),
     y1: centerY.toFixed(2),
     x2: spoolRight.toFixed(2),
     y2: centerY.toFixed(2),
     stroke: axisColor,
     'stroke-width': 1,
     'stroke-dasharray': '6 6'
   }));
 
-  const coreRadiusIn = Math.max(0, (core_dia_in || 0) / 2);
-  const lebusOffsetIn = Math.max(0, (lebus_thk_in || 0));
   const cableRadiusPx = cable_dia_in > 0 ? (cable_dia_in / 2) * scale : 0;
   const cablePitchPx = cable_dia_in > 0 ? cable_dia_in * scale : 0;
 
   const wrapsByLayer = new Map();
   for (const row of rows) {
     wrapsByLayer.set(row.layer_no, (wrapsByLayer.get(row.layer_no) || 0) + 1);
   }
 
   if (cableRadiusPx > 0 && cablePitchPx > 0 && coreWidthPx > 0) {
     uniqueLayers.forEach((layer, idx) => {
       const wraps = wrapsByLayer.get(layer.layer_no) || 0;
       if (wraps <= 0) return;
       const style = layerStyles[idx];
-      const centerOffsetIn = coreRadiusIn + lebusOffsetIn + (idx + 0.5) * cable_dia_in;
+      const centerOffsetIn = Number.isFinite(layer.center_dia_in) ? layer.center_dia_in / 2 : 0;
       const centerOffsetPx = centerOffsetIn * scale;
+      const layerPhasePx = (layer.layer_no % 2 === 0) ? cablePitchPx / 2 : 0;
       const topY = centerY - centerOffsetPx;
       const bottomY = centerY + centerOffsetPx;
 
       for (let w = 0; w < wraps; w++) {
-        const cx = spoolLeft + cableRadiusPx + w * cablePitchPx;
+        const cx = spoolLeft + cableRadiusPx + layerPhasePx + w * cablePitchPx;
         if (cx - cableRadiusPx < spoolLeft - 1e-3) continue;
         if (cx + cableRadiusPx > spoolRight + 1e-3) continue;
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: topY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: style.fillColor,
           stroke: style.strokeColor,
           'stroke-width': 1.4
         }));
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: bottomY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: style.fillColor,
           stroke: style.strokeColor,
           'stroke-width': 1.4
         }));
       }
     });
   }
 
   // Summary & accessibility copy
