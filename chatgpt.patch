diff --git a/src/js/plots/rpm-torque.mjs b/src/js/plots/rpm-torque.mjs
index 794087270b0237cfcc9472c541ec89aa1df6a175..d885012a037d7e7c4bd5fd4e658756fde34dfeb6 100644
--- a/src/js/plots/rpm-torque.mjs
+++ b/src/js/plots/rpm-torque.mjs
@@ -109,43 +109,56 @@ export function drawHydraulicRpmTorque(svg, { wraps = [] } = {}) {
       .map(d => [d.torque, d[field]])
       .filter(([torque, rpm]) => Number.isFinite(torque) && Number.isFinite(rpm));
 
     if (!points.length) return '';
 
     if (dropAtMaxTorque) {
       const lastPoint = points[points.length - 1];
       if (lastPoint && lastPoint[1] > rpmMin + 1e-9) {
         points.push([lastPoint[0], rpmMin]);
       }
     }
 
     return svgPathFromPoints(points.map(([torque, rpm]) => [sx(torque), sy(rpm)]));
   };
 
   const availPath = pathFor('rpmAvail', { dropAtMaxTorque: true });
   if (availPath) {
     svg.appendChild(svgEl('path', {
       d: availPath,
       fill: 'none',
       stroke: accent,
       'stroke-width': 3
     }));
   }
 
+  const minPoint = data.find(d => Number.isFinite(d.rpmAvail));
+  if (minPoint) {
+    const y = sy(minPoint.rpmAvail);
+    svg.appendChild(svgEl('line', {
+      x1: ML,
+      y1: y,
+      x2: sx(minPoint.torque),
+      y2: y,
+      stroke: accent,
+      'stroke-width': 2
+    }));
+  }
+
 }
 
 function toNumber(val) {
   if (val === null || val === undefined) return NaN;
   if (typeof val === 'string') {
     const trimmed = val.trim();
     if (!trimmed) return NaN;
     const parsed = Number(trimmed);
     return Number.isFinite(parsed) ? parsed : NaN;
   }
   const num = Number(val);
   return Number.isFinite(num) ? num : NaN;
 }
 
 function formatNumber(val, decimals = 0) {
   const factor = Math.pow(10, decimals);
   return String(Math.round(val * factor) / factor);
 }
