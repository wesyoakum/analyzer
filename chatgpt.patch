diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index a46e9dedbff29584853784009aafb9d7ffb48600..900962defd880f8b42d4272b10f0627274ecd09d 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -63,82 +63,83 @@ export function drawDepthProfiles(svgSpeed, svgTension, {
   const tensionField = (scenario === 'electric')
     ? ['avail_tension_kgf', 't_avail_kgf', 'tAvail']
     : ['Tavail,start', 'Tavail_start', 'tavail_start', 'tavail_start_kgf', 'hyd_avail_tension_kgf'];
 
   // Build wrap intervals [depth_start, depth_end] with values
   const deadEnd = Number.isFinite(dead_end_m) ? Math.max(0, dead_end_m) : 0;
   const segments = wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd, scenario);
 
   // Sort deep to shallow by start depth
   segments.sort((a, b) => (b.depth_start || 0) - (a.depth_start || 0));
 
   // Extents
   const maxDepth = segments.length
     ? Math.max(...segments.map(S => Math.max(S.depth_start || 0, S.depth_end || 0)))
     : 0;
   const maxSpeedFromCandidates = segments.length
     ? Math.max(0, ...segments.map(S => {
         if (!Array.isArray(S.candidate_speeds_ms) || !S.candidate_speeds_ms.length) {
           return S.speed_ms || 0;
         }
         return Math.max(0, ...S.candidate_speeds_ms.map(C => C.value_ms), S.speed_ms || 0);
       }))
     : 0;
   const ratedSpeedMs = Number.isFinite(rated_speed_ms) ? Math.max(0, rated_speed_ms) : null;
   const maxAvailT = Math.max(0, ...segments.map(S => S.avail_tension_kgf || 0));
-  const tensionDepth = Math.max(maxDepth, depthMax);
-  const maxTheoT = payload_kg + cable_w_kgpm * tensionDepth;
-  const maxReqT = maxTheoT * TENSION_SAFETY_FACTOR;
   const toNumber = val => {
     const num = Number(val);
     return Number.isFinite(num) ? num : NaN;
   };
 
   let depthMin = toNumber(depth_xmin);
   if (!Number.isFinite(depthMin) || depthMin < 0) depthMin = 0;
 
   let depthMax = toNumber(depth_xmax);
   const autoDepthMax = Math.max(depthMin + 0.1, maxDepth);
   if (Number.isFinite(depthMax)) {
     depthMax = Math.max(depthMin + 0.1, depthMax);
   } else {
     depthMax = autoDepthMax;
   }
   if (depthMax <= depthMin) depthMax = depthMin + 1;
 
   let speedMin = toNumber(speed_ymin);
   if (!Number.isFinite(speedMin) || speedMin < 0) speedMin = 0;
 
   let speedMax = toNumber(speed_ymax);
   const autoSpeedMax = Math.max(speedMin + 0.1, 1, maxSpeedFromCandidates, ratedSpeedMs || 0);
   if (Number.isFinite(speedMax)) {
     speedMax = Math.max(speedMin + 0.1, speedMax);
   } else {
     speedMax = autoSpeedMax;
   }
   if (speedMax <= speedMin) speedMax = speedMin + 1;
 
+  const tensionDepth = Math.max(maxDepth, depthMax);
+  const maxTheoT = payload_kg + cable_w_kgpm * tensionDepth;
+  const maxReqT = maxTheoT * TENSION_SAFETY_FACTOR;
+
   let tensionMin = toNumber(tension_ymin);
   if (!Number.isFinite(tensionMin) || tensionMin < 0) tensionMin = 0;
 
   let tensionMax = toNumber(tension_ymax);
   const autoTensionMax = Math.max(tensionMin + 1, maxReqT, maxAvailT) * 1.05;
   if (Number.isFinite(tensionMax)) {
     tensionMax = Math.max(tensionMin + 1, tensionMax);
   } else {
     tensionMax = autoTensionMax;
   }
   if (tensionMax <= tensionMin) tensionMax = tensionMin + 1;
 
   const accentColor = getAccentColor();
 
   // Render both
   drawSpeedProfile(svgSpeed, segments, depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs);
   drawTensionProfile(svgTension, segments, depthMin, depthMax, tensionMin, tensionMax, payload_kg, cable_w_kgpm, accentColor);
 }
 
 // ---------- Speed vs Depth ----------
 function drawSpeedProfile(svg, segments, depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs = null) {
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const ML = 64, MR = 18, MT = 18, MB = 46;
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
