diff --git a/src/js/main.mjs b/src/js/main.mjs
index 22d2e5366c5e1fef902bdd25047b449d59000024..bc3864b28807c841a4395e5b213c984eae862767 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -10,50 +10,57 @@ import {
 } from './utils.mjs';
 
 import { setupInputPersistence } from './persist-inputs.mjs';
 
 import { calcLayers } from './layer-engine.mjs';
 
 import {
   rowsToElectricLayer, projectElectricWraps, renderElectricTables
 } from './electric.mjs';
 
 import {
   rowsToHydraulicLayer, projectHydraulicWraps, renderHydraulicTables
 } from './hydraulic.mjs';
 
 import { drawWaveContours, drawWaveHeightContours } from './plots/wave-contours.mjs';
 import { drawDepthProfiles } from './plots/depth-profiles.mjs';
 
 // ---- App state for plots/tables ----
 let lastElLayer = [], lastElWraps = [];
 let lastHyLayer = [], lastHyWraps = [];
 
 // ---- Wire up events once DOM is ready ----
 document.addEventListener('DOMContentLoaded', () => {
   setupInputPersistence();
 
+  document.querySelectorAll('.param-label').forEach(label => {
+    const code = label.dataset.code;
+    if (code) {
+      label.setAttribute('title', code);
+    }
+  });
+
   // Compute button
   q('go').addEventListener('click', computeAll);
 
   // Tabs
   document.querySelectorAll('.tab-btn').forEach(b => {
     b.addEventListener('click', () => {
       document.querySelectorAll('.tab-btn').forEach(x => x.classList.remove('active'));
       document.querySelectorAll('.panel').forEach(x => x.classList.remove('active'));
       b.classList.add('active');
       document.getElementById(b.dataset.target).classList.add('active');
     });
   });
 
   // Wave plot controls
   q('wave_redraw').addEventListener('click', () => redrawPlots());
   q('wave_scenario').addEventListener('change', () => redrawPlots());
   ['wave_tmin', 'wave_tmax', 'wave_vmax', 'wave_hmax'].forEach(id => q(id).addEventListener('change', () => redrawPlots()));
 
   // Depth plot controls
   q('depth_redraw').addEventListener('click', () => redrawPlots());
   q('depth_scenario').addEventListener('change', () => redrawPlots());
 
   // Initial compute
   q('go').click();
 });
@@ -97,51 +104,58 @@ function computeAll() {
     const motor_tmax = read('motor_tmax');
     const P_per_motor_W = (Number.isFinite(motor_hp) ? motor_hp : 0) * W_PER_HP;
 
     // Hydraulic inputs
     const h_strings = read('h_pump_strings');
     const h_emotor_hp = read('h_emotor_hp');
     const h_emotor_eff = read('h_emotor_eff'); // electro-hydraulic efficiency
     const h_emotor_rpm = read('h_emotor_rpm');
     const h_pump_cc = read('h_pump_cc');
     const h_max_psi = read('h_max_psi');
     const h_hmot_cc = read('h_hmot_cc');
     const h_hmot_rpm_cap = read('h_hmot_rpm_max');
 
     // Usable hydraulic hp & flow from pump strings
     const hp_str_usable = h_emotor_hp * h_emotor_eff;
     const hp_tot_usable = hp_str_usable * h_strings;
     const q_str_gpm = gpm_from_cc_rev_and_rpm(h_pump_cc, h_emotor_rpm);
     const q_tot_gpm = q_str_gpm * h_strings;
 
     // Max-pressure torque per hydraulic motor and at drum (pressure-limited)
     const dP_Pa = h_max_psi * PSI_TO_PA;
     const torque_per_hmotor_maxP = torque_per_motor_from_pressure_Pa(dP_Pa, h_hmot_cc); // N·m per motor at max P
     const torque_at_drum_maxP_factor = Math.max(gr1, 1) * Math.max(gr2, 1) * Math.max(motors, 1);
 
     // Generate wraps from geometry
-    const { rows } = calcLayers(cfg);
+    const { rows, meta } = calcLayers(cfg);
+
+    const wrapsNoteEl = /** @type {HTMLTableCellElement|null} */ (document.getElementById('wraps_note'));
+    if (wrapsNoteEl) {
+      const calcWraps = meta && Number.isFinite(meta.wraps_per_layer_calc) ? meta.wraps_per_layer_calc : undefined;
+      const display = (typeof calcWraps === 'number') ? calcWraps.toFixed(1) : '–';
+      wrapsNoteEl.textContent = `Leave blank or set to 0 to use calculated wraps (always truncated to .0/.5). Auto-calculated wraps per layer: ${display}.`;
+    }
 
     // Per-wrap calculations (electric + hydraulic)
     for (const r of rows) {
       // Base tension and torque at drum
       r.tension_kgf = tension_kgf(r.deployed_len_m, payload_kg, cable_w_kgpm);
       const tension_N = r.tension_kgf * G;
       const radius_m = (r.layer_dia_in * M_PER_IN) / 2;
       r.torque_Nm = +(tension_N * radius_m).toFixed(1);
 
       // ----- ELECTRIC per wrap -----
       const motorTorque_e = r.torque_Nm / (denom_mech || 1);
       r.motor_torque_Nm = +motorTorque_e.toFixed(2);
 
       // RPM limited by available power per motor and capped by motor max rpm
       let rpm_power_e = 0;
       if (P_per_motor_W > 0 && motorTorque_e > 0) {
         rpm_power_e = (P_per_motor_W / motorTorque_e) * 60 / (2 * Math.PI);
       } else if (P_per_motor_W > 0 && motorTorque_e === 0) {
         rpm_power_e = Number.POSITIVE_INFINITY;
       } else {
         rpm_power_e = 0;
       }
       const rpm_capped_e = Math.min(Number.isFinite(motor_max_rpm) ? motor_max_rpm : Infinity, rpm_power_e);
       r.motor_rpm = +((Number.isFinite(rpm_capped_e) ? rpm_capped_e : 0)).toFixed(1);
 
@@ -196,52 +210,51 @@ function computeAll() {
       } else {
         speed_power_mpm = speed_flow_mpm;
         speed_avail_mpm = speed_flow_mpm;
         hp_used_at_available = 0;
       }
 
       r.hyd_P_required_psi = Math.round(P_req_psi);
       r.hyd_speed_power_mpm = +speed_power_mpm.toFixed(2);
       r.hyd_speed_flow_mpm = +speed_flow_mpm.toFixed(2);
       r.hyd_speed_available_mpm = +speed_avail_mpm.toFixed(2);
       r.hyd_hp_used_at_available = +hp_used_at_available.toFixed(2);
       r.hyd_elec_input_hp_used = +((h_emotor_eff > 0 ? r.hyd_hp_used_at_available / h_emotor_eff : 0)).toFixed(2);
     }
 
     // ---- Aggregate into per-layer tables ----
     lastElLayer = rowsToElectricLayer(rows, payload_kg, cable_w_kgpm, gr1, gr2, motors);
     lastHyLayer = rowsToHydraulicLayer(rows);
     lastElWraps = projectElectricWraps(rows);
     lastHyWraps = projectHydraulicWraps(rows);
 
     // ---- Render tables ----
     renderElectricTables(lastElLayer, lastElWraps, q('tbody_el_layer'), q('tbody_el_wraps'));
     renderHydraulicTables(lastHyLayer, lastHyWraps, q('tbody_hy_layer'), q('tbody_hy_wraps'));
 
     // ---- Update status ----
-    const wrapsCount = Math.max(lastElWraps.length, lastHyWraps.length);
-    q('status').textContent = `ok — layers(E/H): ${lastElLayer.length}/${lastHyLayer.length}, wraps: ${wrapsCount}`;
+    q('status').textContent = 'results updated';
 
     // ---- Draw plots ----
     redrawPlots();
   } catch (e) {
     console.error(e);
     q('err').textContent = 'ERROR: ' + (e && e.message ? e.message : e);
     q('status').textContent = 'error';
     lastElLayer = lastElWraps = lastHyLayer = lastHyWraps = [];
     clearPlots();
   }
 }
 
 // ---- Plot redraw helper (uses decoupled plotting modules) ----
 function redrawPlots() {
     // Wave contours (optional - skip if controls/SVGs absent)
   const waveScenarioEl = /** @type {HTMLSelectElement|null} */ (document.getElementById('wave_scenario'));
   const waveTminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmin'));
   const waveTmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmax'));
   const waveVmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_vmax'));
   const waveHmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_hmax'));
   const waveSvg = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg'));
   const waveSvgHeight = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg_height'));
 
   if (waveScenarioEl && waveTminEl && waveTmaxEl && waveHmaxEl && waveSvg && waveSvgHeight) {
     const parseInput = (el) => parseFloat((el.value || '').replace(',', '.'));
