diff --git a/src/js/main.mjs b/src/js/main.mjs
index 33063bde4394991e3441cb478fd8e1e14f8eb8f6..076fa7a8b54171d457b17d7913e69ea3878c4dc4 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -9,63 +9,136 @@ import {
   line_speed_mpm_from_motor_rpm, hp_from_psi_and_gpm,
   TENSION_SAFETY_FACTOR
 } from './utils.mjs';
 
 import { setupInputPersistence } from './persist-inputs.mjs';
 
 import { calcLayers } from './layer-engine.mjs';
 
 import {
   rowsToElectricLayer, projectElectricWraps, renderElectricTables
 } from './electric.mjs';
 
 import {
   rowsToHydraulicLayer, projectHydraulicWraps, renderHydraulicTables
 } from './hydraulic.mjs';
 
 import { drawWaveContours, drawWaveHeightContours } from './plots/wave-contours.mjs';
 import { drawDepthProfiles } from './plots/depth-profiles.mjs';
 import { setupComponentSelectors } from './component-selectors.mjs';
 import { renderDrumVisualization, clearDrumVisualization } from './drum-visual.mjs';
 
 // ---- App state for plots/tables ----
 let lastElLayer = [], lastElWraps = [];
 let lastHyLayer = [], lastHyWraps = [];
 
+const CSV_BUTTON_SPECS = {
+  csv_el_layer: {
+    filename: () => 'electric-layer.csv',
+    columns: [
+      'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
+      'post_on_drum_m', 'post_deployed_m', 'max_tension_theoretical_kgf',
+      'max_tension_required_kgf', 'max_torque_Nm', 'max_motor_torque_Nm',
+      'motor_rpm_at_start', 'line_speed_at_start_mpm', 'avail_tension_kgf_at_start'
+    ],
+    header: [
+      'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
+      'post_on_drum_m', 'post_deployed_m', 'max_tension_theoretical_kgf',
+      'max_tension_required_kgf', 'max_torque_Nm', 'max_motor_torque_Nm',
+      'motor_rpm_at_start', 'line_speed_at_start_mpm', 'avail_tension_kgf_at_start'
+    ],
+    getRows: () => lastElLayer
+  },
+  csv_el_wraps: {
+    filename: () => 'electric-wraps.csv',
+    columns: [
+      'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
+      'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
+      'tension_required_kgf', 'torque_Nm', 'motor_torque_Nm', 'motor_rpm',
+      'line_speed_mpm', 'avail_tension_kgf'
+    ],
+    header: [
+      'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
+      'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
+      'tension_required_kgf', 'torque_Nm', 'motor_torque_Nm', 'motor_rpm',
+      'line_speed_mpm', 'avail_tension_kgf'
+    ],
+    getRows: () => lastElWraps
+  },
+  csv_hy_layer: {
+    filename: () => 'hydraulic-layer.csv',
+    columns: [
+      'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
+      'post_on_drum_m', 'post_deployed_m', 'hyd_P_required_psi',
+      'hyd_speed_power_mpm', 'hyd_speed_flow_mpm', 'hyd_speed_available_mpm',
+      'hyd_hp_used_at_available', 'hyd_elec_input_hp_used',
+      'hyd_drum_torque_at_maxP_Nm', 'hyd_avail_tension_kgf_at_start'
+    ],
+    header: [
+      'layer_no', 'layer_dia_in', 'pre_on_drum_m', 'pre_deployed_m',
+      'post_on_drum_m', 'post_deployed_m', 'hyd_P_required_psi',
+      'hyd_speed_power_mpm', 'hyd_speed_flow_mpm', 'hyd_speed_available_mpm',
+      'hyd_hp_used_at_available', 'hyd_elec_input_hp_used',
+      'hyd_drum_torque_at_maxP_Nm', 'hyd_avail_tension_kgf_at_start'
+    ],
+    getRows: () => lastHyLayer
+  },
+  csv_hy_wraps: {
+    filename: () => 'hydraulic-wraps.csv',
+    columns: [
+      'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
+      'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
+      'tension_required_kgf', 'hyd_P_required_psi', 'hyd_speed_power_mpm',
+      'hyd_speed_flow_mpm', 'hyd_speed_available_mpm', 'hyd_hp_used_at_available',
+      'hyd_elec_input_hp_used', 'hyd_drum_torque_maxP_Nm', 'hyd_avail_tension_kgf'
+    ],
+    header: [
+      'wrap_no', 'layer_no', 'layer_dia_in', 'wrap_len_in', 'pre_spooled_len_m',
+      'spooled_len_m', 'deployed_len_m', 'tension_theoretical_kgf',
+      'tension_required_kgf', 'hyd_P_required_psi', 'hyd_speed_power_mpm',
+      'hyd_speed_flow_mpm', 'hyd_speed_available_mpm', 'hyd_hp_used_at_available',
+      'hyd_elec_input_hp_used', 'hyd_drum_torque_maxP_Nm', 'hyd_avail_tension_kgf'
+    ],
+    getRows: () => lastHyWraps
+  }
+};
+
 const DRIVE_MODE_CHECKBOX = {
   electric: 'drive_electric_enabled',
   hydraulic: 'drive_hydraulic_enabled'
 };
 
 // ---- Wire up events once DOM is ready ----
 document.addEventListener('DOMContentLoaded', () => {
   setupInputPersistence();
 
   setupComponentSelectors();
 
   setupDriveModeControls();
 
+  setupCsvDownloads();
+
   setupPlotResizeToggles();
 
   setupAutoRecompute();
 
   updateBuildIndicator();
 
   document.querySelectorAll('.param-label').forEach(label => {
     const code = label.dataset.code;
     if (code) {
       label.setAttribute('title', code);
     }
   });
 
   // Tabs
   document.querySelectorAll('.tab-btn').forEach(b => {
     b.addEventListener('click', () => {
       document.querySelectorAll('.tab-btn').forEach(x => x.classList.remove('active'));
       document.querySelectorAll('.panel').forEach(x => x.classList.remove('active'));
       b.classList.add('active');
       document.getElementById(b.dataset.target).classList.add('active');
     });
   });
 
   // Wave plot controls
   q('wave_redraw').addEventListener('click', () => redrawPlots());
@@ -82,50 +155,101 @@ document.addEventListener('DOMContentLoaded', () => {
 
 function updateBuildIndicator() {
   const indicator = /** @type {HTMLElement|null} */ (document.getElementById('build-info'));
   if (!indicator) return;
 
   const lastModified = new Date(document.lastModified);
   if (Number.isNaN(lastModified.getTime())) {
     indicator.textContent = `Updated ${document.lastModified}`;
     return;
   }
 
   const formatter = new Intl.DateTimeFormat('en-US', {
     year: 'numeric',
     month: 'short',
     day: '2-digit',
     hour: '2-digit',
     minute: '2-digit',
     second: '2-digit',
     hour12: false,
     timeZone: 'UTC'
   });
 
   indicator.textContent = `Updated ${formatter.format(lastModified)} UTC`;
 }
 
+function setupCsvDownloads() {
+  Object.entries(CSV_BUTTON_SPECS).forEach(([id, spec]) => {
+    const btn = q(id);
+    if (!btn) return;
+    btn.addEventListener('click', () => {
+      const rows = spec.getRows ? spec.getRows() : [];
+      if (!rows || rows.length === 0) return;
+      const csv = rowsToCsv(rows, spec.columns, spec.header);
+      triggerCsvDownload(csv, spec.filename ? spec.filename() : `${id}.csv`);
+    });
+  });
+
+  updateCsvButtonStates();
+}
+
+function updateCsvButtonStates() {
+  Object.entries(CSV_BUTTON_SPECS).forEach(([id, spec]) => {
+    const btn = q(id);
+    if (!btn) return;
+    const rows = spec.getRows ? spec.getRows() : [];
+    btn.disabled = !(Array.isArray(rows) && rows.length > 0);
+  });
+}
+
+function rowsToCsv(rows, columns, headerRow) {
+  const header = (headerRow && headerRow.length ? headerRow : columns).map(csvEscapeCell).join(',');
+  const dataLines = rows.map(row => columns.map(col => csvEscapeCell(row[col])).join(','));
+  return [header, ...dataLines].join('\r\n');
+}
+
+function csvEscapeCell(value) {
+  if (value === null || value === undefined) return '';
+  const str = String(value);
+  if (/[",\n\r]/.test(str)) {
+    return '"' + str.replace(/"/g, '""') + '"';
+  }
+  return str;
+}
+
+function triggerCsvDownload(csvText, filename) {
+  const blob = new Blob([csvText], { type: 'text/csv;charset=utf-8;' });
+  const url = URL.createObjectURL(blob);
+  const link = document.createElement('a');
+  link.href = url;
+  link.download = filename;
+  document.body.appendChild(link);
+  link.click();
+  document.body.removeChild(link);
+  URL.revokeObjectURL(url);
+}
+
 function setupPlotResizeToggles() {
   const toggles = document.querySelectorAll('[data-plot-toggle]');
   toggles.forEach(btn => {
     const col = btn.closest('.plot-column');
     if (!col) return;
     const initialExpanded = col.classList.contains('is-expanded');
     btn.textContent = initialExpanded ? '[-]' : '[+]';
     btn.setAttribute('aria-expanded', initialExpanded ? 'true' : 'false');
     btn.addEventListener('click', () => {
       const expanded = col.classList.toggle('is-expanded');
       btn.textContent = expanded ? '[-]' : '[+]';
       btn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
     });
   });
 }
 
 function setupAutoRecompute() {
   const inputs = Array.from(document.querySelectorAll('input, select, textarea'));
   if (!inputs.length) return;
 
   const handler = () => computeAll();
 
   inputs.forEach(el => {
     if (el.tagName === 'SELECT') {
       el.addEventListener('change', handler);
@@ -438,63 +562,66 @@ function computeAll() {
       } else {
         r.hyd_drum_torque_maxP_Nm = 0;
         r.hyd_avail_tension_kgf = 0;
         r.hyd_P_required_psi = 0;
         r.hyd_speed_power_mpm = 0;
         r.hyd_speed_flow_mpm = 0;
         r.hyd_speed_available_mpm = 0;
         r.hyd_hp_used_at_available = 0;
         r.hyd_elec_input_hp_used = 0;
       }
     }
 
     // ---- Drum visualization ----
     renderDrumVisualization(rows, summary, cfg, meta);
 
     // ---- Aggregate into per-layer tables ----
     lastElLayer = electricEnabled ? rowsToElectricLayer(rows, payload_kg, cable_w_kgpm, gr1, gr2, motors) : [];
     lastHyLayer = hydraulicEnabled ? rowsToHydraulicLayer(rows) : [];
     lastElWraps = electricEnabled ? projectElectricWraps(rows) : [];
     lastHyWraps = hydraulicEnabled ? projectHydraulicWraps(rows) : [];
 
     // ---- Render tables ----
     renderElectricTables(lastElLayer, lastElWraps, q('tbody_el_layer'), q('tbody_el_wraps'));
     renderHydraulicTables(lastHyLayer, lastHyWraps, q('tbody_hy_layer'), q('tbody_hy_wraps'));
 
+    updateCsvButtonStates();
+
     // ---- Update status ----
     if (status) status.textContent = 'results updated';
 
     // ---- Draw plots ----
     redrawPlots();
   } catch (e) {
     console.error(e);
     q('err').textContent = 'ERROR: ' + (e && e.message ? e.message : e);
     if (status) status.textContent = 'error';
     clearMinimumSystemHp();
     lastElLayer = lastElWraps = lastHyLayer = lastHyWraps = [];
     clearDrumVisualization();
     clearPlots();
+    updateCsvButtonStates();
   }
 }
 
 // ---- Plot redraw helper (uses decoupled plotting modules) ----
 function redrawPlots() {
     // Wave contours (optional - skip if controls/SVGs absent)
   const waveScenarioEl = /** @type {HTMLSelectElement|null} */ (document.getElementById('wave_scenario'));
   const waveTminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmin'));
   const waveTmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmax'));
   const waveVmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_vmax'));
   const waveHmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_hmax'));
   const waveSvg = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg'));
   const waveSvgHeight = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg_height'));
 
   if (waveScenarioEl && waveTminEl && waveTmaxEl && waveHmaxEl && waveSvg && waveSvgHeight) {
     const parseInput = (el) => parseFloat((el.value || '').replace(',', '.'));
     const waveOpts = {
       scenario: waveScenarioEl.value || 'electric',
       Tmin: parseInput(waveTminEl) || 4,
       Tmax: parseInput(waveTmaxEl) || 20,
       speedMax: waveVmaxEl ? parseInput(waveVmaxEl) : undefined,
       Hmax: parseInput(waveHmaxEl) || 6,
       elLayers: lastElLayer,
       hyLayers: lastHyLayer
     };
