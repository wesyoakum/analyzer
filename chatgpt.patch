diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index ff6dac38f6a6f78cd3737fe18b4713c8b044387f..06a91e90b7b42c1164729cc871bb030e88f9be3e 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -14,52 +14,56 @@ function getAccentColor() {
   return '#2c56a3';
 }
 
 /**
  * Draw both depth profile plots (speed & tension).
  *
  * @param {SVGSVGElement} svgSpeed
  * @param {SVGSVGElement} svgTension
  * @param {Object} opts
  * @param {'electric'|'hydraulic'} opts.scenario
  * @param {Array<Object>} opts.elWraps
  * @param {Array<Object>} opts.hyWraps
  * @param {number} opts.payload_kg
  * @param {number} opts.cable_w_kgpm
  * @param {number} [opts.dead_end_m=0]
  */
 export function drawDepthProfiles(svgSpeed, svgTension, {
   scenario = 'electric',
   elWraps = [],
   hyWraps = [],
   payload_kg = 0,
   cable_w_kgpm = 0,
   dead_end_m = 0
 } = {}) {
   const wraps = (scenario === 'electric') ? (elWraps || []) : (hyWraps || []);
-  const speedField = (scenario === 'electric') ? 'line_speed_mpm' : 'hyd_speed_available_mpm';
-  const tensionField = (scenario === 'electric') ? 'avail_tension_kgf' : 'hyd_avail_tension_kgf';
+  const speedField = (scenario === 'electric')
+    ? 'line_speed_mpm'
+    : ['vavail', 'vAvail', 'v_available', 'v_available_mpm', 'hyd_speed_available_mpm'];
+  const tensionField = (scenario === 'electric')
+    ? ['avail_tension_kgf', 't_avail_kgf', 'tAvail']
+    : ['Tavail,start', 'Tavail_start', 'tavail_start', 'tavail_start_kgf', 'hyd_avail_tension_kgf'];
 
   // Build wrap intervals [depth_start, depth_end] with values
   const deadEnd = Number.isFinite(dead_end_m) ? Math.max(0, dead_end_m) : 0;
   const segments = wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd, scenario);
 
   // Sort deep to shallow by start depth
   segments.sort((a, b) => (b.depth_start || 0) - (a.depth_start || 0));
 
   // Extents
   const maxDepth = segments.length
     ? Math.max(...segments.map(S => Math.max(S.depth_start || 0, S.depth_end || 0)))
     : 0;
   const maxSpeedFromCandidates = segments.length
     ? Math.max(0, ...segments.map(S => {
         if (!Array.isArray(S.candidate_speeds_ms) || !S.candidate_speeds_ms.length) {
           return S.speed_ms || 0;
         }
         return Math.max(0, ...S.candidate_speeds_ms.map(C => C.value_ms), S.speed_ms || 0);
       }))
     : 0;
   const maxSpeed = Math.max(1, maxSpeedFromCandidates);
   const maxAvailT = Math.max(0, ...segments.map(S => S.avail_tension_kgf || 0));
   const maxTheoT = payload_kg + cable_w_kgpm * maxDepth;
   const maxReqT = maxTheoT * TENSION_SAFETY_FACTOR;
   const maxTension = Math.max(maxReqT, maxAvailT) * 1.05 || 1;
@@ -310,113 +314,130 @@ function buildTensionSegments(segments, payload_kg, cable_w_kgpm, maxDepth, {
     const firstColor = above0 ? colorAbove : colorBelow;
     const secondColor = above0 ? colorBelow : colorAbove;
 
     pieces.push({ d0, d1: clamped, color: firstColor, T0, T1: Tcross });
     pieces.push({ d0: clamped, d1, color: secondColor, T0: Tcross, T1 });
   }
 
   // Merge adjacent pieces of same color
   const merged = [];
   for (const piece of pieces) {
     if (!merged.length) {
       merged.push({ ...piece });
       continue;
     }
     const last = merged[merged.length - 1];
     if (piece.color === last.color && Math.abs(piece.d0 - last.d1) < 1e-6) {
       last.d1 = piece.d1;
       last.T1 = piece.T1;
     } else {
       merged.push({ ...piece });
     }
   }
   return merged;
 }
 
+function coerceNumeric(wrap, field) {
+  if (!wrap) return null;
+  const fields = Array.isArray(field) ? field : [field];
+  for (const name of fields) {
+    if (!name) continue;
+    const raw = wrap[name];
+    if (Number.isFinite(raw)) return raw;
+    if (typeof raw === 'string') {
+      const cleaned = raw.replace(/,/g, '').trim();
+      if (!cleaned) continue;
+      const parsed = Number.parseFloat(cleaned);
+      if (Number.isFinite(parsed)) return parsed;
+    }
+  }
+  return null;
+}
+
 function wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd = 0, scenario = 'electric') {
   /** @type {Array<Object>} */
   const segments = [];
   let fallbackStart = null;
 
   for (const wrap of wraps) {
     if (!wrap) continue;
-    const totalLen = Number.isFinite(wrap.total_cable_len_m) ? wrap.total_cable_len_m : null;
-    const preOn = Number.isFinite(wrap.pre_spooled_len_m) ? wrap.pre_spooled_len_m : null;
-    let depthEnd = Number.isFinite(wrap.deployed_len_m) ? wrap.deployed_len_m : null;
+    const totalLen = coerceNumeric(wrap, 'total_cable_len_m');
+    const preOn = coerceNumeric(wrap, 'pre_spooled_len_m');
+    let depthEnd = coerceNumeric(wrap, 'deployed_len_m');
 
     if (!Number.isFinite(depthEnd)) {
       fallbackStart = null;
       continue;
     }
 
     let depthStart = null;
     if (Number.isFinite(totalLen) && Number.isFinite(preOn)) {
       depthStart = totalLen - preOn;
     } else if (Number.isFinite(fallbackStart)) {
       depthStart = fallbackStart;
     }
 
     if (!Number.isFinite(depthStart)) {
       depthStart = depthEnd;
     }
 
     if (depthStart < depthEnd) {
       const tmp = depthStart;
       depthStart = depthEnd;
       depthEnd = tmp;
     }
 
     const toDepth = (v) => {
       if (!Number.isFinite(v)) return 0;
       const adj = v - deadEnd;
       return +Math.max(0, adj).toFixed(3);
     };
     depthStart = toDepth(depthStart);
     depthEnd = toDepth(depthEnd);
 
-    const speedValMpm = Number.isFinite(wrap[speedField]) ? wrap[speedField] : null;
+    const speedValMpm = coerceNumeric(wrap, speedField);
     const candidateFields = (scenario === 'hydraulic')
       ? [
-          { field: 'hyd_speed_power_mpm', kind: 'power' },
-          { field: 'hyd_speed_flow_mpm', kind: 'flow' }
+          { field: ['vP', 'vp', 'vp_mpm', 'hyd_speed_power_mpm'], kind: 'power' },
+          { field: ['vQ', 'vq', 'vq_mpm', 'hyd_speed_flow_mpm'], kind: 'flow' }
         ]
       : [];
     /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
     const candidateSpeedsMs = [];
     for (const { field, kind } of candidateFields) {
-      const val = Number.isFinite(wrap[field]) ? wrap[field] : null;
+      const val = coerceNumeric(wrap, field);
       if (!Number.isFinite(val)) continue;
       const ms = val / 60;
       if (Number.isFinite(ms)) candidateSpeedsMs.push({ kind, value_ms: ms });
     }
 
     const speedMs = Number.isFinite(speedValMpm) ? speedValMpm / 60 : null;
     /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
     const filteredCandidates = [];
     const seenKeys = new Set();
     for (const candidate of candidateSpeedsMs) {
       if (speedMs !== null && Math.abs(candidate.value_ms - speedMs) <= 1e-6) {
         continue;
       }
       const key = `${candidate.kind}:${candidate.value_ms.toFixed(6)}`;
       if (seenKeys.has(key)) continue;
       seenKeys.add(key);
       filteredCandidates.push(candidate);
     }
-    const tensionVal = Number.isFinite(wrap[tensionField]) ? wrap[tensionField] : null;
+    const tensionVal = coerceNumeric(wrap, tensionField);
 
     segments.push({
       depth_start: depthStart,
       depth_end: depthEnd,
       speed_ms: speedMs,
       candidate_speeds_ms: filteredCandidates,
       avail_tension_kgf: Number.isFinite(tensionVal) ? tensionVal : null,
       label: Number.isFinite(wrap.wrap_no)
         ? `W${wrap.wrap_no}`
         : (Number.isFinite(wrap.layer_no) ? `L${wrap.layer_no}` : '')
     });
 
     fallbackStart = depthEnd + deadEnd;
   }
 
   return segments;
 }
