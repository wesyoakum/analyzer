diff --git a/src/js/main.mjs b/src/js/main.mjs
index b7bf146b39e26360ec4392ef1117545658304a80..50cd648e340dfe0f90c5ebae79fafc7dc2abf9d7 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -2,50 +2,51 @@
 
 import {
   q, read,
   G, W_PER_HP, PSI_TO_PA, CC_PER_GAL, M_PER_IN,
   tension_kgf, elec_available_tension_kgf,
   gpm_from_cc_rev_and_rpm, rpm_from_gpm_and_disp,
   psi_from_torque_and_disp_Nm_cc, torque_per_motor_from_pressure_Pa,
   line_speed_mpm_from_motor_rpm, hp_from_psi_and_gpm
 } from './utils.mjs';
 
 import { setupInputPersistence } from './persist-inputs.mjs';
 
 import { calcLayers } from './layer-engine.mjs';
 
 import {
   rowsToElectricLayer, projectElectricWraps, renderElectricTables
 } from './electric.mjs';
 
 import {
   rowsToHydraulicLayer, projectHydraulicWraps, renderHydraulicTables
 } from './hydraulic.mjs';
 
 import { drawWaveContours, drawWaveHeightContours } from './plots/wave-contours.mjs';
 import { drawDepthProfiles } from './plots/depth-profiles.mjs';
 import { setupComponentSelectors } from './component-selectors.mjs';
+import { renderDrumVisualization, clearDrumVisualization } from './drum-visual.mjs';
 
 // ---- App state for plots/tables ----
 let lastElLayer = [], lastElWraps = [];
 let lastHyLayer = [], lastHyWraps = [];
 
 // ---- Wire up events once DOM is ready ----
 document.addEventListener('DOMContentLoaded', () => {
   setupInputPersistence();
 
   setupComponentSelectors();
 
   setupPlotResizeToggles();
 
   setupAutoRecompute();
 
   document.querySelectorAll('.param-label').forEach(label => {
     const code = label.dataset.code;
     if (code) {
       label.setAttribute('title', code);
     }
   });
 
   // Tabs
   document.querySelectorAll('.tab-btn').forEach(b => {
     b.addEventListener('click', () => {
@@ -149,51 +150,51 @@ function computeAll() {
     const motor_tmax = read('motor_tmax');
     const P_per_motor_W = (Number.isFinite(motor_hp) ? motor_hp : 0) * W_PER_HP;
 
     // Hydraulic inputs
     const h_strings = read('h_pump_strings');
     const h_emotor_hp = read('h_emotor_hp');
     const h_emotor_eff = read('h_emotor_eff'); // electro-hydraulic efficiency
     const h_emotor_rpm = read('h_emotor_rpm');
     const h_pump_cc = read('h_pump_cc');
     const h_max_psi = read('h_max_psi');
     const h_hmot_cc = read('h_hmot_cc');
     const h_hmot_rpm_cap = read('h_hmot_rpm_max');
 
     // Usable hydraulic hp & flow from pump strings
     const hp_str_usable = h_emotor_hp * h_emotor_eff;
     const hp_tot_usable = hp_str_usable * h_strings;
     const q_str_gpm = gpm_from_cc_rev_and_rpm(h_pump_cc, h_emotor_rpm);
     const q_tot_gpm = q_str_gpm * h_strings;
 
     // Max-pressure torque per hydraulic motor and at drum (pressure-limited)
     const dP_Pa = h_max_psi * PSI_TO_PA;
     const torque_per_hmotor_maxP = torque_per_motor_from_pressure_Pa(dP_Pa, h_hmot_cc); // N·m per motor at max P
     const torque_at_drum_maxP_factor = Math.max(gr1, 1) * Math.max(gr2, 1) * Math.max(motors, 1);
 
     // Generate wraps from geometry
-    const { rows, meta } = calcLayers(cfg);
+    const { rows, summary, meta } = calcLayers(cfg);
 
     const wrapsNoteEl = /** @type {HTMLTableCellElement|null} */ (document.getElementById('wraps_note'));
     if (wrapsNoteEl) {
       const calcWraps = meta && Number.isFinite(meta.wraps_per_layer_calc) ? meta.wraps_per_layer_calc : undefined;
       const display = (typeof calcWraps === 'number') ? calcWraps.toFixed(1) : '–';
       wrapsNoteEl.textContent = `Leave blank or set to 0 to use calculated wraps (always truncated to .0/.5). Auto-calculated wraps per layer: ${display}.`;
     }
 
     // Per-wrap calculations (electric + hydraulic)
     for (const r of rows) {
       // Base tension and torque at drum
       r.tension_kgf = tension_kgf(r.deployed_len_m, payload_kg, cable_w_kgpm);
       const tension_N = r.tension_kgf * G;
       const radius_m = (r.layer_dia_in * M_PER_IN) / 2;
       r.torque_Nm = +(tension_N * radius_m).toFixed(1);
 
       // ----- ELECTRIC per wrap -----
       const motorTorque_e = r.torque_Nm / (denom_mech || 1);
       r.motor_torque_Nm = +motorTorque_e.toFixed(2);
 
       // RPM limited by available power per motor and capped by motor max rpm
       let rpm_power_e = 0;
       if (P_per_motor_W > 0 && motorTorque_e > 0) {
         rpm_power_e = (P_per_motor_W / motorTorque_e) * 60 / (2 * Math.PI);
       } else if (P_per_motor_W > 0 && motorTorque_e === 0) {
@@ -244,70 +245,73 @@ function computeAll() {
         speed_avail_mpm = Math.min(speed_power_mpm, speed_flow_mpm);
 
         // Power used at the actual available speed
         const D_m = r.layer_dia_in * M_PER_IN;
         const drum_rpm_needed = speed_avail_mpm / (Math.PI * D_m);
         const motor_rpm_needed = drum_rpm_needed * (Math.max(gr1, 1) * Math.max(gr2, 1));
         const gpm_per_motor_needed = (motor_rpm_needed * h_hmot_cc) / CC_PER_GAL;
         const gpm_total_needed = Math.max(motors, 1) * gpm_per_motor_needed;
         const gpm_used = Math.min(gpm_total_needed, q_tot_gpm);
         hp_used_at_available = hp_from_psi_and_gpm(P_power_psi, gpm_used);
         if (hp_used_at_available > hp_tot_usable) hp_used_at_available = hp_tot_usable;
       } else {
         speed_power_mpm = speed_flow_mpm;
         speed_avail_mpm = speed_flow_mpm;
         hp_used_at_available = 0;
       }
 
       r.hyd_P_required_psi = Math.round(P_req_psi);
       r.hyd_speed_power_mpm = +speed_power_mpm.toFixed(2);
       r.hyd_speed_flow_mpm = +speed_flow_mpm.toFixed(2);
       r.hyd_speed_available_mpm = +speed_avail_mpm.toFixed(2);
       r.hyd_hp_used_at_available = +hp_used_at_available.toFixed(2);
       r.hyd_elec_input_hp_used = +((h_emotor_eff > 0 ? r.hyd_hp_used_at_available / h_emotor_eff : 0)).toFixed(2);
     }
 
+    renderDrumVisualization(rows, summary, cfg, meta);
+
     // ---- Aggregate into per-layer tables ----
     lastElLayer = rowsToElectricLayer(rows, payload_kg, cable_w_kgpm, gr1, gr2, motors);
     lastHyLayer = rowsToHydraulicLayer(rows);
     lastElWraps = projectElectricWraps(rows);
     lastHyWraps = projectHydraulicWraps(rows);
 
     // ---- Render tables ----
     renderElectricTables(lastElLayer, lastElWraps, q('tbody_el_layer'), q('tbody_el_wraps'));
     renderHydraulicTables(lastHyLayer, lastHyWraps, q('tbody_hy_layer'), q('tbody_hy_wraps'));
 
     // ---- Update status ----
     if (status) status.textContent = 'results updated';
 
     // ---- Draw plots ----
     redrawPlots();
   } catch (e) {
     console.error(e);
     q('err').textContent = 'ERROR: ' + (e && e.message ? e.message : e);
     if (status) status.textContent = 'error';
     lastElLayer = lastElWraps = lastHyLayer = lastHyWraps = [];
+    clearDrumVisualization();
     clearPlots();
   }
 }
 
 // ---- Plot redraw helper (uses decoupled plotting modules) ----
 function redrawPlots() {
     // Wave contours (optional - skip if controls/SVGs absent)
   const waveScenarioEl = /** @type {HTMLSelectElement|null} */ (document.getElementById('wave_scenario'));
   const waveTminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmin'));
   const waveTmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmax'));
   const waveVmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_vmax'));
   const waveHmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_hmax'));
   const waveSvg = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg'));
   const waveSvgHeight = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg_height'));
 
   if (waveScenarioEl && waveTminEl && waveTmaxEl && waveHmaxEl && waveSvg && waveSvgHeight) {
     const parseInput = (el) => parseFloat((el.value || '').replace(',', '.'));
     const waveOpts = {
       scenario: waveScenarioEl.value || 'electric',
       Tmin: parseInput(waveTminEl) || 4,
       Tmax: parseInput(waveTmaxEl) || 20,
       speedMax: waveVmaxEl ? parseInput(waveVmaxEl) : undefined,
       Hmax: parseInput(waveHmaxEl) || 6,
       elLayers: lastElLayer,
       hyLayers: lastHyLayer
