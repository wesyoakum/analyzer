diff --git a/src/js/plots/rpm-torque.mjs b/src/js/plots/rpm-torque.mjs
index f2fbd9922c455df774801551d4d8003bf8495521..86fa72cce528914886cc9755cef480d8da580a25 100644
--- a/src/js/plots/rpm-torque.mjs
+++ b/src/js/plots/rpm-torque.mjs
@@ -1,58 +1,58 @@
 // ===== plots/rpm-torque.mjs — Hydraulic available RPM vs torque =====
 import { niceTicks, svgEl, svgPathFromPoints } from '../utils.mjs';
 
 const FLOW_COLOR = '#eed500';
 const POWER_COLOR = '#9249c6';
 
 function getAccentColor() {
   if (typeof window !== 'undefined' && typeof document !== 'undefined' && window.getComputedStyle) {
     const val = window.getComputedStyle(document.documentElement).getPropertyValue('--accent');
     if (val) return val.trim();
   }
   return '#2c56a3';
 }
 
 /**
- * Draw available hydraulic RPM (per motor) as a function of torque demand.
+ * Draw available hydraulic drum RPM as a function of torque demand.
  * The available RPM is the lower of the flow-limited and power-limited RPM.
  * @param {SVGSVGElement} svg
  * @param {Object} opts
  * @param {Array<Object>} [opts.wraps]
  */
 export function drawHydraulicRpmTorque(svg, { wraps = [] } = {}) {
   if (!svg) return;
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const data = (Array.isArray(wraps) ? wraps : [])
     .map(w => ({
       wrap: w.wrap_no,
       layer: w.layer_no,
       torque: toNumber(w.torque_Nm),
-      rpmAvail: toNumber(w.hyd_rpm_available_per_motor),
-      rpmFlow: toNumber(w.hyd_rpm_flow_per_motor),
-      rpmPower: toNumber(w.hyd_rpm_power_per_motor)
+      rpmAvail: toNumber(w.hyd_drum_rpm_available),
+      rpmFlow: toNumber(w.hyd_drum_rpm_flow),
+      rpmPower: toNumber(w.hyd_drum_rpm_power)
     }))
     .filter(d => Number.isFinite(d.torque) && d.torque > 0 && Number.isFinite(d.rpmAvail) && d.rpmAvail >= 0);
 
   if (!data.length) {
     const msg = svgEl('text', {
       x: (svg.viewBox.baseVal.width || svg.clientWidth || 1000) / 2,
       y: (svg.viewBox.baseVal.height || svg.clientHeight || 540) / 2,
       'text-anchor': 'middle',
       'font-size': '16',
       fill: '#666'
     });
     msg.textContent = 'No hydraulic data available';
     svg.appendChild(msg);
     return;
   }
 
   data.sort((a, b) => a.torque - b.torque);
 
   const accent = getAccentColor();
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
   const H = svg.viewBox.baseVal.height || svg.clientHeight || 540;
   const ML = 70, MR = 20, MT = 20, MB = 60;
   const innerW = W - ML - MR;
   const innerH = H - MT - MB;
 
@@ -88,51 +88,51 @@ export function drawHydraulicRpmTorque(svg, { wraps = [] } = {}) {
   rpmTicks.forEach(r => {
     if (r < rpmMin - 1e-9 || r > rpmMax + 1e-9) return;
     const Y = sy(r);
     svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#eee' }));
     const label = svgEl('text', { x: ML - 8, y: Y + 4, 'text-anchor': 'end', 'font-size': '12', fill: '#444' });
     label.textContent = formatNumber(r, 0);
     svg.appendChild(label);
   });
 
   svg.appendChild(svgEl('text', {
     x: ML + innerW / 2,
     y: H - 6,
     'text-anchor': 'middle',
     'font-size': '13',
     fill: '#333'
   })).textContent = 'Torque at drum (N·m)';
 
   const ylabel = svgEl('text', {
     x: 16,
     y: MT + innerH / 2,
     'text-anchor': 'middle',
     'font-size': '13',
     fill: '#333',
     transform: `rotate(-90 16 ${MT + innerH / 2})`
   });
-  ylabel.textContent = 'Motor RPM (per motor)';
+  ylabel.textContent = 'Drum RPM';
   svg.appendChild(ylabel);
 
   const pathFor = (field, { dropAtMaxTorque = false } = {}) => {
     const points = data
       .map(d => [d.torque, d[field]])
       .filter(([torque, rpm]) => Number.isFinite(torque) && Number.isFinite(rpm));
 
     if (!points.length) return '';
 
     if (dropAtMaxTorque) {
       const lastPoint = points[points.length - 1];
       if (lastPoint && lastPoint[1] > rpmMin + 1e-9) {
         points.push([lastPoint[0], rpmMin]);
       }
     }
 
     return svgPathFromPoints(points.map(([torque, rpm]) => [sx(torque), sy(rpm)]));
   };
 
   const flowPath = pathFor('rpmFlow');
   if (flowPath) {
     svg.appendChild(svgEl('path', {
       d: flowPath,
       fill: 'none',
       stroke: FLOW_COLOR,
