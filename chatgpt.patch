diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index cb8dd9b577f5804545dab65007a0ca58dc868795..2dbaaf0bb3ca4ca804157438e2733cc342a529b9 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -231,136 +231,98 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
     svg.appendChild(svgEl('rect', {
       ...flangeRectAttrs,
       x: (spoolLeft - flangeWidthPx).toFixed(2)
     }));
 
     svg.appendChild(svgEl('rect', {
       ...flangeRectAttrs,
       x: spoolRight.toFixed(2)
     }));
   }
 
   const axisColor = rgbToCss(ink700Rgb, 0.18);
   svg.appendChild(svgEl('line', {
     x1: spoolLeft.toFixed(2),
     y1: centerY.toFixed(2),
     x2: spoolRight.toFixed(2),
     y2: centerY.toFixed(2),
     stroke: axisColor,
     'stroke-width': strokeWidthAttr,
     'vector-effect': 'non-scaling-stroke',
     'stroke-dasharray': '6 6'
   }));
 
   const cableRadiusPx = cable_dia_in > 0 ? (cable_dia_in / 2) * scale : 0;
 
-  const wrapsPerLayerUsed = meta && Number.isFinite(meta.wraps_per_layer_used)
-    ? meta.wraps_per_layer_used
-    : null;
-  const wrapsPerLayerFraction = wrapsPerLayerUsed !== null
-    ? Math.abs(wrapsPerLayerUsed - Math.round(wrapsPerLayerUsed))
-    : 0;
-  const isHalfWrapPattern = wrapsPerLayerUsed !== null && Math.abs(wrapsPerLayerFraction - 0.5) < 1e-6;
-  const isWholeWrapPattern = wrapsPerLayerUsed !== null && Math.abs(wrapsPerLayerFraction) < 1e-6;
-
   const wrapsByLayer = new Map();
   for (const row of rows) {
     wrapsByLayer.set(row.layer_no, (wrapsByLayer.get(row.layer_no) || 0) + 1);
   }
 
   if (cableRadiusPx > 0 && coreWidthPx > 0) {
-    const leftTangent = spoolLeft + cableRadiusPx;
-    const rightTangent = spoolRight - cableRadiusPx;
-    const availableWidth = Math.max(0, coreWidthPx - 2 * cableRadiusPx);
-
     layersForViz.forEach(layer => {
       const wraps = wrapsByLayer.get(layer.layer_no) || 0;
       if (wraps <= 0) return;
       const centerOffsetPx = layer.center_radius_in * scale;
       const topY = centerY - centerOffsetPx;
       const bottomY = centerY + centerOffsetPx;
 
-      /** @type {number[]} */
-      const centers = [];
-      if (isHalfWrapPattern) {
-        const denom = Math.max(wraps - 0.5, 1e-6);
-        const gap = availableWidth / denom;
-        const start = (layer.layer_no % 2 === 0)
-          ? leftTangent + gap / 2
-          : leftTangent;
-        for (let w = 0; w < wraps; w++) {
-          centers.push(start + w * gap);
-        }
-      } else if (
-        isWholeWrapPattern &&
-        wrapsPerLayerUsed > 1 &&
-        availableWidth > 0
-      ) {
-        const baseWraps = Math.max(0, Math.round(wrapsPerLayerUsed));
-        const gap = availableWidth / Math.max(baseWraps - 1, 1e-6);
-        const start = (layer.layer_no % 2 === 0)
-          ? leftTangent + gap / 2
-          : leftTangent;
-        for (let w = 0; w < wraps; w++) {
-          centers.push(start + w * gap);
-        }
-      } else {
-        const gap = wraps > 1 ? availableWidth / (wraps - 1) : 0;
-        const start = leftTangent;
-        if (wraps === 1) {
-          centers.push(start);
-        } else {
-          for (let w = 0; w < wraps; w++) {
-            centers.push(start + w * gap);
-          }
-        }
-      }
-
-      centers.forEach(cx => {
-        if (cx - cableRadiusPx < spoolLeft - 1e-3) return;
-        if (cx + cableRadiusPx > spoolRight + 1e-3) return;
+      const spacingIn = wraps > 1
+        ? (Math.max(flange_to_flange_in || 0, 0) - Math.max(cable_dia_in, 0)) / (wraps - 1)
+        : 0;
+      const spacingPx = Math.max(spacingIn, 0) * scale;
+      const startFromLeft = (layer.layer_no % 2) === 1;
+      const startCx = startFromLeft
+        ? spoolLeft + cableRadiusPx
+        : spoolRight - cableRadiusPx;
+      const delta = startFromLeft ? spacingPx : -spacingPx;
+
+      for (let w = 0; w < wraps; w++) {
+        const cx = startCx + w * delta;
+        if (cx - cableRadiusPx < spoolLeft - 1e-3) continue;
+        if (cx + cableRadiusPx > spoolRight + 1e-3) continue;
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: topY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
         }));
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: bottomY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
         }));
-      });
+      }
     });
   }
 
   // Summary & accessibility copy
   const cableLenDigits = cable_len_m >= 1000 ? 0 : cable_len_m >= 10 ? 1 : 2;
   const cableDiaDigits = cable_dia_mm >= 50 ? 0 : cable_dia_mm >= 10 ? 1 : 2;
   const layerWord = total_layers === 1 ? 'layer' : 'layers';
   const wrapWord = total_wraps === 1 ? 'wrap' : 'wraps';
   const summaryLine = `${fmt(cable_len_m, cableLenDigits)} m of ${fmt(cable_dia_mm, cableDiaDigits)} mm cable on ${fmt(total_layers, 0)} ${layerWord} with ${fmt(total_wraps, 0)} total ${wrapWord}`;
   const wrapsPerLayer = meta && Number.isFinite(meta.wraps_per_layer_used)
     ? ` (≈${fmt(meta.wraps_per_layer_used, 1)} wraps per layer)`
     : '';
   const geometryParts = [
     `core Ø ${fmt(core_dia_in, 2)} in`,
     `flange-to-flange ${fmt(flange_to_flange_in, 2)} in`,
     `flange Ø ${fmt(flange_dia_in, 2)} in`,
     `Lebus liner ${fmt(lebus_thk_in, 3)} in`,
     `full drum Ø ${fmt(full_drum_dia_in, 2)} in`
   ];
   const geometryLine = `Drum geometry: ${geometryParts.join(', ')}.`;
   const summaryPlain = `${summaryLine}${wrapsPerLayer}. ${geometryLine}`;
 
   summaryEl.innerHTML = `<strong>${summaryLine}${wrapsPerLayer}.</strong> ${geometryLine}`;
   titleEl.textContent = `Winch drum cross-section with ${fmt(total_layers, 0)} ${layerWord}`;
   svg.setAttribute('aria-label', summaryPlain);
