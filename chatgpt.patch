diff --git a/src/js/component-selectors.mjs b/src/js/component-selectors.mjs
index b7e84dc6d0fcbe9d9427b80315497117ee631504..0a2084d65660a59d3894b2ac1ffe9b8200006e32 100644
--- a/src/js/component-selectors.mjs
+++ b/src/js/component-selectors.mjs
@@ -868,50 +868,52 @@ const SELECT_CONFIGS = [
     type: 'hydraulic-pump',
     label: 'Hydraulic Pump',
     fieldMap: FIELD_MAPS.hydraulicPump
   },
   {
     selectId: 'hydraulic_motor_select',
     options: HYDRAULIC_MOTOR_OPTIONS,
     type: 'hydraulic-motor',
     label: 'Hydraulic Motor',
     fieldMap: FIELD_MAPS.hydraulicMotor
   },
   {
     selectId: 'system_select',
     options: SYSTEM_OPTIONS,
     type: 'system',
     label: 'System',
     fieldMap: FIELD_MAPS.system,
     initialSkipEvents: false
   }
 ];
 
 const watchedInputs = new Set();
 const CREATE_NEW_VALUE = '__component_create_new__';
 const SAVE_CURRENT_VALUE = '__component_save_current__';
 const SAVE_CURRENT_LABEL = 'Save Current Preset';
+const DELETE_PRESET_VALUE = '__component_delete_preset__';
+const DELETE_PRESET_LABEL = 'Delete Preset';
 const COMPONENT_STORAGE_PREFIX = 'analyzer.components.';
 /** @type {Map<string, ComponentOption[]>} */
 const memoryCustomOptions = new Map();
 let cachedComponentStorage;
 
 function isPlainObject(value) {
   return typeof value === 'object' && value !== null && !Array.isArray(value);
 }
 
 function mergePresetMetadata(...sources) {
   /** @type {Record<string, unknown>} */
   const result = {};
   sources.forEach(source => {
     if (!isPlainObject(source)) {
       return;
     }
     Object.entries(source).forEach(([key, value]) => {
       if (key === 'fieldMap' && isPlainObject(value)) {
         const existingFieldMap =
           isPlainObject(result.fieldMap) ? { .../** @type {Record<string, unknown>} */ (result.fieldMap) } : {};
         result.fieldMap = { ...existingFieldMap, .../** @type {Record<string, unknown>} */ (value) };
         return;
       }
       result[key] = value;
     });
@@ -1019,50 +1021,61 @@ function mergeCustomOptionLists(existing, incoming) {
   const result = Array.isArray(existing) ? existing.map(cloneOption) : [];
   if (!Array.isArray(incoming)) {
     return result;
   }
   incoming.forEach(option => {
     const key = optionIdentity(option);
     if (!key) return;
     const clone = cloneOption(option);
     const index = result.findIndex(item => optionIdentity(item) === key);
     if (index >= 0) {
       result[index] = clone;
     } else {
       result.push(clone);
     }
   });
   return result;
 }
 
 function upsertCustomOption(type, option, { persist = true } = {}) {
   if (!type) return;
   const existing = memoryCustomOptions.get(type) ?? [];
   const merged = mergeCustomOptionLists(existing, [option]);
   replaceCustomOptions(type, merged, { persist });
 }
 
+function removeCustomOptionById(type, id, { persist = true } = {}) {
+  if (!type || typeof id !== 'string' || !id) return false;
+  const existing = memoryCustomOptions.get(type) ?? [];
+  const filtered = existing.filter(item => item.id !== id);
+  if (filtered.length === existing.length) {
+    return false;
+  }
+  replaceCustomOptions(type, filtered, { persist });
+  return true;
+}
+
 function normalizePresetDataForOption(data, fieldMap) {
   if (!data || typeof data !== 'object' || Array.isArray(data)) {
     return {};
   }
 
   const normalized = {};
   const entries = Object.entries(data);
   const fieldMapEntries =
     fieldMap && typeof fieldMap === 'object' && !Array.isArray(fieldMap)
       ? Object.entries(fieldMap)
       : [];
   const inputIds = new Set(fieldMapEntries.map(([inputId]) => inputId));
 
   entries.forEach(([key, value]) => {
     if (!inputIds.has(key)) {
       normalized[key] = value;
     }
   });
 
   fieldMapEntries.forEach(([inputId, optionKey]) => {
     if (typeof optionKey !== 'string' || optionKey.length === 0) return;
     if (Object.prototype.hasOwnProperty.call(data, optionKey)) {
       normalized[optionKey] = data[optionKey];
       return;
     }
@@ -1227,73 +1240,94 @@ function populateSelectOptions(selectEl, config, { selectedValue } = {}) {
   selectEl.innerHTML = '';
   const manualOpt = document.createElement('option');
   manualOpt.value = '';
   manualOpt.textContent = 'Custom (manual input)';
   selectEl.appendChild(manualOpt);
 
   allOptions(config).forEach(option => {
     const opt = document.createElement('option');
     opt.value = option.pn;
     opt.textContent = describeOption(config, option);
     selectEl.appendChild(opt);
   });
 
   const createOpt = document.createElement('option');
   createOpt.value = CREATE_NEW_VALUE;
   createOpt.textContent = 'Create New';
   selectEl.appendChild(createOpt);
 
   const saveOpt = document.createElement('option');
   saveOpt.value = SAVE_CURRENT_VALUE;
   saveOpt.textContent = SAVE_CURRENT_LABEL;
   saveOpt.dataset.componentPresetSave = '1';
   saveOpt.disabled = true;
   selectEl.appendChild(saveOpt);
 
+  const deleteOpt = document.createElement('option');
+  deleteOpt.value = DELETE_PRESET_VALUE;
+  deleteOpt.textContent = DELETE_PRESET_LABEL;
+  deleteOpt.dataset.componentPresetDelete = '1';
+  deleteOpt.disabled = true;
+  selectEl.appendChild(deleteOpt);
+
   if (prior && prior !== CREATE_NEW_VALUE && prior !== SAVE_CURRENT_VALUE && findOption(config, prior)) {
     selectEl.value = prior;
   } else if (prior === '') {
     selectEl.value = '';
   } else {
     selectEl.value = '';
   }
 }
 
 function ensureSavePresetOption(selectEl) {
   /** @type {HTMLOptionElement|null} */
   let option = selectEl.querySelector(`option[value="${SAVE_CURRENT_VALUE}"]`);
   if (!option) {
     option = document.createElement('option');
     option.value = SAVE_CURRENT_VALUE;
     option.textContent = SAVE_CURRENT_LABEL;
     option.dataset.componentPresetSave = '1';
     option.disabled = true;
     selectEl.appendChild(option);
   }
   return option;
 }
 
+function ensureDeletePresetOption(selectEl) {
+  /** @type {HTMLOptionElement|null} */
+  let option = selectEl.querySelector(`option[value="${DELETE_PRESET_VALUE}"]`);
+  if (!option) {
+    option = document.createElement('option');
+    option.value = DELETE_PRESET_VALUE;
+    option.textContent = DELETE_PRESET_LABEL;
+    option.dataset.componentPresetDelete = '1';
+    option.disabled = true;
+    selectEl.appendChild(option);
+  }
+  return option;
+}
+
 async function handleCreateNew(config, selectEl) {
   const label = config.label || 'component';
   const pnInput = window.prompt(`Enter a part number for the new ${label} preset:`);
   if (pnInput == null) {
     return null;
   }
   const pn = pnInput.trim();
   if (!pn) {
     window.alert('A part number is required to create a preset.');
     return null;
   }
 
   const existing = allOptions(config).find(opt => opt.pn.toLowerCase() === pn.toLowerCase());
   if (existing) {
     window.alert(`A preset with part number "${pn}" already exists.`);
     return null;
   }
 
   const descriptionInput = window.prompt(`Enter a description for ${pn}:`);
   const description = descriptionInput == null ? '' : descriptionInput.trim();
 
   const values = collectValuesForConfig(config);
   const metadata = { pn };
   if (config.type) {
     metadata.type = config.type;
@@ -1498,111 +1532,130 @@ function applySelection(config, pn, { skipEvents = false } = {}) {
 }
 
 export function setupComponentSelectors() {
   const initializedTypes = new Set();
   SELECT_CONFIGS.forEach(config => {
     const type = config.type;
     if (!type || initializedTypes.has(type)) return;
     const loaded = loadCustomOptions(type);
     rememberCustomOptions(type, loaded);
     initializedTypes.add(type);
   });
 
   SELECT_CONFIGS.forEach(config => {
     const selectEl = /** @type {HTMLSelectElement|null} */ (document.getElementById(config.selectId));
     if (!selectEl) return;
 
     const customOptions = getRememberedCustomOptions(config.type);
     config.customOptions = customOptions;
 
     const initialValue = selectEl.value;
     const { initialSkipEvents = true } = config;
 
     populateSelectOptions(selectEl, config, { selectedValue: initialValue });
 
     let isSavingPreset = false;
+    let isDeletingPreset = false;
     let saveOption = ensureSavePresetOption(selectEl);
-    const updateSaveOptionState = () => {
+    let deleteOption = ensureDeletePresetOption(selectEl);
+    const updatePresetActionState = () => {
       saveOption = ensureSavePresetOption(selectEl);
-      if (!saveOption) {
-        return;
-      }
-      if (isSavingPreset) {
-        saveOption.disabled = true;
-        saveOption.textContent = 'Saving…';
-        return;
-      }
-      saveOption.textContent = SAVE_CURRENT_LABEL;
+      deleteOption = ensureDeletePresetOption(selectEl);
       const option = findOption(config, selectEl.value);
       const isServerPreset = Boolean(option && typeof option.id === 'string' && option.id);
-      const shouldEnable = isServerPreset && !selectEl.disabled;
-      saveOption.disabled = !shouldEnable;
-      if (isServerPreset && option && typeof option.id === 'string') {
-        saveOption.dataset.presetId = option.id;
-      } else {
-        delete saveOption.dataset.presetId;
+      const canMutate = isServerPreset && !selectEl.disabled;
+
+      if (saveOption) {
+        if (isSavingPreset) {
+          saveOption.disabled = true;
+          saveOption.textContent = 'Saving…';
+        } else {
+          saveOption.textContent = SAVE_CURRENT_LABEL;
+          saveOption.disabled = !(canMutate && !isDeletingPreset);
+        }
+        if (isServerPreset && option && typeof option.id === 'string') {
+          saveOption.dataset.presetId = option.id;
+        } else {
+          delete saveOption.dataset.presetId;
+        }
+      }
+
+      if (deleteOption) {
+        if (isDeletingPreset) {
+          deleteOption.disabled = true;
+          deleteOption.textContent = 'Deleting…';
+        } else {
+          deleteOption.textContent = DELETE_PRESET_LABEL;
+          deleteOption.disabled = !(canMutate && !isSavingPreset);
+        }
+        if (isServerPreset && option && typeof option.id === 'string') {
+          deleteOption.dataset.presetId = option.id;
+        } else {
+          delete deleteOption.dataset.presetId;
+        }
       }
     };
 
     selectEl.addEventListener('component:options-refreshed', () => {
       saveOption = ensureSavePresetOption(selectEl);
-      updateSaveOptionState();
+      deleteOption = ensureDeletePresetOption(selectEl);
+      updatePresetActionState();
     });
 
     Object.keys(config.fieldMap).forEach(inputId => attachWatcher(inputId));
 
     let previousValue = selectEl.value && selectEl.value !== CREATE_NEW_VALUE ? selectEl.value : '';
     let suppressNext = false;
 
     const ensureOptionApplied = (value, { skipEvents = false } = {}) => {
       applySelection(config, value, { skipEvents });
     };
 
     const performSaveCurrentPreset = async () => {
       if (isSavingPreset) {
         return;
       }
       const option = findOption(config, selectEl.value);
       if (!option || typeof option.id !== 'string' || !option.id) {
         return;
       }
 
       const descriptor = option.name && option.name !== option.pn ? `${option.name} (${option.pn})` : option.pn;
       const label = config.label || 'component';
       const confirmMessage = [
         `Save the current ${label} settings to preset "${descriptor}"?`,
         'This will overwrite the version stored on the server.'
       ].join('\n\n');
       const confirmed = window.confirm(confirmMessage);
       if (!confirmed) {
         return;
       }
 
       isSavingPreset = true;
       const wasSelectDisabled = selectEl.disabled;
       selectEl.disabled = true;
-      updateSaveOptionState();
+      updatePresetActionState();
 
       try {
         const values = collectValuesForConfig(config);
         const payloadMetadata = buildMetadataForConfig(option, config);
         const payload = {
           id: option.id,
           name: option.name ?? option.pn,
           ...(option.description ? { description: option.description } : {}),
           data: values,
           metadata: payloadMetadata
         };
 
         let response;
         try {
           response = await fetch('/api/presets', {
             method: 'POST',
             headers: {
               'Content-Type': 'application/json'
             },
             body: JSON.stringify(payload)
           });
         } catch (err) {
           const message = err instanceof Error ? err.message : String(err);
           window.alert(`Unable to save preset: ${message}`);
           return;
@@ -1665,99 +1718,164 @@ export function setupComponentSelectors() {
           name: preset.name ?? option.name ?? option.pn,
           ...(preset.description ? { description: preset.description } : option.description ? { description: option.description } : {}),
           ...normalizedOptionData,
           id: option.id,
           metadata: isPlainObject(mergedMetadata) ? { ...mergedMetadata } : undefined,
           data: isPlainObject(presetData) ? { ...presetData } : undefined
         };
         if (typeof preset.updatedAt === 'string') {
           updatedOption.updatedAt = preset.updatedAt;
         } else if (option.updatedAt) {
           updatedOption.updatedAt = option.updatedAt;
         }
 
         if (config.type) {
           upsertCustomOption(config.type, updatedOption);
         }
 
         const updatedPn = updatedOption.pn ?? option.pn;
         if (updatedPn) {
           previousValue = updatedPn;
           selectEl.value = updatedPn;
         }
       } finally {
         isSavingPreset = false;
         selectEl.disabled = wasSelectDisabled;
-        updateSaveOptionState();
+        updatePresetActionState();
       }
     };
 
     selectEl.addEventListener('change', async () => {
       if (suppressNext) {
         suppressNext = false;
         previousValue = selectEl.value;
         ensureOptionApplied(selectEl.value);
-        updateSaveOptionState();
+        updatePresetActionState();
         return;
       }
 
       const value = selectEl.value;
       if (value === SAVE_CURRENT_VALUE) {
         const revertValue = previousValue || '';
         selectEl.value = revertValue;
         await performSaveCurrentPreset();
-        updateSaveOptionState();
+        updatePresetActionState();
+        return;
+      }
+
+      if (value === DELETE_PRESET_VALUE) {
+        const revertValue = previousValue || '';
+        selectEl.value = revertValue;
+        const option = findOption(config, revertValue);
+        if (!option || typeof option.id !== 'string' || !option.id) {
+          ensureOptionApplied(revertValue);
+          updatePresetActionState();
+          return;
+        }
+
+        const descriptor = option.name && option.name !== option.pn ? `${option.name} (${option.pn})` : option.pn;
+        const confirmMessage = `Delete preset "${descriptor}"? This action cannot be undone.`;
+        const confirmed = window.confirm(confirmMessage);
+        if (!confirmed) {
+          ensureOptionApplied(revertValue);
+          updatePresetActionState();
+          return;
+        }
+
+        const wasSelectDisabled = selectEl.disabled;
+        selectEl.disabled = true;
+        isDeletingPreset = true;
+        updatePresetActionState();
+
+        try {
+          let response;
+          try {
+            response = await fetch(`/api/presets/${encodeURIComponent(option.id)}`, {
+              method: 'DELETE'
+            });
+          } catch (err) {
+            const message = err instanceof Error ? err.message : String(err);
+            window.alert(`Unable to delete preset: ${message}`);
+            return;
+          }
+
+          if (!response.ok) {
+            let message = 'Failed to delete preset.';
+            try {
+              const errorBody = await response.json();
+              if (errorBody?.error?.message) {
+                message = errorBody.error.message;
+              }
+            } catch (err) {
+              // Ignore JSON parsing errors; fall back to generic message.
+            }
+            window.alert(message);
+            return;
+          }
+
+          if (config.type) {
+            removeCustomOptionById(config.type, option.id);
+          }
+          previousValue = '';
+          selectEl.value = '';
+          ensureOptionApplied('');
+        } finally {
+          isDeletingPreset = false;
+          selectEl.disabled = wasSelectDisabled;
+          updatePresetActionState();
+        }
+
         return;
       }
 
       if (value === CREATE_NEW_VALUE) {
         selectEl.value = previousValue;
         const createdPn = await handleCreateNew(config, selectEl);
         if (createdPn) {
           previousValue = createdPn;
           suppressNext = true;
           selectEl.value = createdPn;
           ensureOptionApplied(createdPn);
           selectEl.dispatchEvent(new Event('change', { bubbles: true }));
         } else {
           ensureOptionApplied(previousValue);
         }
-        updateSaveOptionState();
+        updatePresetActionState();
         return;
       }
 
       previousValue = value;
       ensureOptionApplied(value);
-      updateSaveOptionState();
+      updatePresetActionState();
     });
 
     // Apply persisted selection if present
     if (selectEl.value) {
       ensureOptionApplied(selectEl.value, { skipEvents: initialSkipEvents });
     }
 
-    updateSaveOptionState();
+    updatePresetActionState();
   });
 
   void fetchAndApplyServerPresets();
 }
 
 async function fetchAndApplyServerPresets() {
   if (typeof window === 'undefined' || typeof window.fetch !== 'function') {
     return;
   }
 
   let response;
   try {
     response = await fetch('/api/presets');
   } catch (err) {
     console.warn('Unable to fetch presets from server:', err);
     return;
   }
 
   if (!response.ok) {
     console.warn('Failed to load presets from server.');
     return;
   }
 
   let body;
   try {
