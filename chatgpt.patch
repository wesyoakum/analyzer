diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index afef8bd9835b89323b5855e228f2e1ef51db2c12..97cd9c36790090f4e00efa7c94912e8137b260d5 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -77,85 +77,112 @@ function cssVar(styles, name, fallbackHex) {
   return value && value.trim() ? value.trim() : fallbackHex;
 }
 
 function mixRgb(a, b, t) {
   const k = Math.max(0, Math.min(1, t));
   return {
     r: clamp255(a.r + (b.r - a.r) * k),
     g: clamp255(a.g + (b.g - a.g) * k),
     b: clamp255(a.b + (b.b - a.b) * k)
   };
 }
 
 function rgbToCss(rgb, alpha = 1) {
   const a = typeof alpha === 'number' ? Math.max(0, Math.min(1, alpha)) : 1;
   if (a < 1) {
     return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a.toFixed(3)})`;
   }
   return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
 }
 
 function fmt(value, digits = 0) {
   if (!Number.isFinite(value)) return 'â€“';
   return value.toLocaleString('en-US', { maximumFractionDigits: digits });
 }
 
+function resetDrumSvg(svg, currentTitleEl = null) {
+  if (!svg) return null;
+
+  let titleEl = currentTitleEl;
+  if (!titleEl || titleEl.ownerSVGElement !== svg) {
+    titleEl = svg.querySelector('#drum_visual_title');
+  }
+
+  if (!titleEl) {
+    titleEl = document.createElementNS('http://www.w3.org/2000/svg', 'title');
+    titleEl.id = 'drum_visual_title';
+    svg.insertBefore(titleEl, svg.firstChild);
+  } else if (titleEl.parentNode !== svg) {
+    svg.insertBefore(titleEl, svg.firstChild);
+  } else if (titleEl.previousSibling) {
+    svg.insertBefore(titleEl, svg.firstChild);
+  }
+
+  const nodes = Array.from(svg.childNodes);
+  for (const node of nodes) {
+    if (node !== titleEl) {
+      svg.removeChild(node);
+    }
+  }
+
+  return titleEl;
+}
+
 function emptyState(summaryEl, titleEl, svg) {
-  if (titleEl) titleEl.textContent = 'Winch drum cross-section (awaiting inputs)';
+  const activeTitleEl = svg ? resetDrumSvg(svg, titleEl) : titleEl;
+  if (activeTitleEl) activeTitleEl.textContent = 'Winch drum cross-section (awaiting inputs)';
   if (svg) svg.setAttribute('aria-label', 'Winch drum cross-section awaiting inputs');
   if (summaryEl) summaryEl.textContent = 'Enter drum and cable inputs to view the drum visualization.';
-  if (svg) {
-    while (svg.firstChild) svg.removeChild(svg.firstChild);
-  }
 }
 
 export function renderDrumVisualization(rows, summary, cfg, meta) {
   const svg = /** @type {SVGSVGElement|null} */ (document.getElementById('drum_visual_svg'));
   const summaryEl = /** @type {HTMLParagraphElement|null} */ (document.getElementById('drum_summary'));
-  const titleEl = /** @type {SVGTitleElement|null} */ (document.getElementById('drum_visual_title'));
+  let titleEl = /** @type {SVGTitleElement|null} */ (document.getElementById('drum_visual_title'));
 
-  if (!svg || !summaryEl || !titleEl) return;
+  if (!svg || !summaryEl) return;
 
   if (!rows || !rows.length || !summary || !cfg) {
     emptyState(summaryEl, titleEl, svg);
     return;
   }
 
   const { total_layers, total_wraps, cable_len_m, full_drum_dia_in } = summary;
   const {
     cable_dia_mm,
     core_dia_in,
     flange_dia_in,
     flange_to_flange_in,
     lebus_thk_in,
     packing_factor
   } = cfg;
 
   const cable_dia_in = Math.max(0, (cable_dia_mm || 0) * IN_PER_MM);
   const packingFactor = Number.isFinite(packing_factor) ? Math.max(packing_factor, 0) : 0.877;
 
-  while (svg.firstChild) svg.removeChild(svg.firstChild);
+  titleEl = resetDrumSvg(svg, titleEl);
+  if (!titleEl) return;
 
   const styles = getComputedStyle(document.documentElement);
   const accentRgb = parseCssColor(cssVar(styles, '--accent', FALLBACK_HEX.accent), FALLBACK_COLORS.accent);
   const ink700Rgb = parseCssColor(cssVar(styles, '--ink-700', FALLBACK_HEX.ink700), FALLBACK_COLORS.ink700);
   const ink900Rgb = parseCssColor(cssVar(styles, '--ink-900', FALLBACK_HEX.ink900), FALLBACK_COLORS.ink900);
   const paperRgb = parseCssColor(cssVar(styles, '--paper', FALLBACK_HEX.paper), FALLBACK_COLORS.paper);
   const tensionLowRgb = parseCssColor(cssVar(styles, '--tension-low', FALLBACK_HEX.tensionLow), FALLBACK_COLORS.tensionLow);
   const tensionHighRgb = parseCssColor(cssVar(styles, '--tension-high', FALLBACK_HEX.tensionHigh), FALLBACK_COLORS.tensionHigh);
   const cableFillCss = rgbToCss(mixRgb(accentRgb, paperRgb, 0.45), 0.82);
   const cableStrokeCss = rgbToCss(accentRgb, 0.94);
 
   const uniqueLayers = [];
   const seen = new Set();
   for (const row of rows) {
     if (seen.has(row.layer_no)) continue;
     seen.add(row.layer_no);
     uniqueLayers.push({ layer_no: row.layer_no });
   }
 
   const baseRadiusIn = Math.max(0,
     (core_dia_in || 0) / 2 +
     (lebus_thk_in || 0) +
     (cable_dia_in > 0 ? cable_dia_in / 2 : 0)
   );
 
