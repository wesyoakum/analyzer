diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index 15a890aa941df59d2c94f8f28cd5806cdcda7d56..b0e01d8351365040ec20dfd8de54c47a31d9217f 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -489,65 +489,64 @@ function buildTensionSegments(segments, payload_kg, cable_w_kgpm, depthMin, dept
   for (let i = 0; i < sorted.length - 1; i++) {
     const d0 = sorted[i];
     const d1 = sorted[i + 1];
     if (d1 - d0 < 1e-9) continue;
     const mid = (d0 + d1) / 2;
     const seg = segments.find(S => mid >= Math.min(S.depth_end, S.depth_start) - 1e-9 && mid <= Math.max(S.depth_end, S.depth_start) + 1e-9);
     const avail = seg ? seg.avail_tension_kgf : null;
     const baseT0 = payload_kg + cable_w_kgpm * d0;
     const baseT1 = payload_kg + cable_w_kgpm * d1;
     const T0 = baseT0 * factor;
     const T1 = baseT1 * factor;
 
     if (!Number.isFinite(avail) || !Number.isFinite(factor) || factor <= 0) {
       pieces.push({ d0, d1, color: colorBelow, T0, T1 });
       continue;
     }
 
     const above0 = T0 > avail + 1e-6;
     const above1 = T1 > avail + 1e-6;
 
     if (above0 === above1) {
       pieces.push({ d0, d1, color: above0 ? colorAbove : colorBelow, T0, T1 });
       continue;
     }
 
-    if (Math.abs(cable_w_kgpm) < 1e-9) {
+    const deltaT = T1 - T0;
+    if (Math.abs(deltaT) < 1e-9) {
       pieces.push({ d0, d1, color: above0 ? colorAbove : colorBelow, T0, T1 });
       continue;
     }
 
-    const baseAvail = avail / factor;
-    const dCross = (baseAvail - payload_kg) / cable_w_kgpm;
-    const clamped = Math.min(Math.max(dCross, d0), d1);
-    const baseCross = payload_kg + cable_w_kgpm * clamped;
-    const Tcross = baseCross * factor;
+    const frac = Math.min(Math.max((avail - T0) / deltaT, 0), 1);
+    const dCross = d0 + frac * (d1 - d0);
+    const Tcross = T0 + frac * deltaT;
     const firstColor = above0 ? colorAbove : colorBelow;
     const secondColor = above0 ? colorBelow : colorAbove;
 
-    pieces.push({ d0, d1: clamped, color: firstColor, T0, T1: Tcross });
-    pieces.push({ d0: clamped, d1, color: secondColor, T0: Tcross, T1 });
+    pieces.push({ d0, d1: dCross, color: firstColor, T0, T1: Tcross });
+    pieces.push({ d0: dCross, d1, color: secondColor, T0: Tcross, T1 });
   }
 
   // Merge adjacent pieces of same color
   const merged = [];
   for (const piece of pieces) {
     if (!merged.length) {
       merged.push({ ...piece });
       continue;
     }
     const last = merged[merged.length - 1];
     if (piece.color === last.color && Math.abs(piece.d0 - last.d1) < 1e-6) {
       last.d1 = piece.d1;
       last.T1 = piece.T1;
     } else {
       merged.push({ ...piece });
     }
   }
   return merged;
 }
 
 function coerceNumeric(wrap, field) {
   if (!wrap) return null;
   const fields = Array.isArray(field) ? field : [field];
   for (const name of fields) {
     if (!name) continue;
