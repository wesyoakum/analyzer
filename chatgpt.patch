diff --git a/src/js/plots/rpm-torque.mjs b/src/js/plots/rpm-torque.mjs
index ca4b315261c49d31c1d7e8af319fe33c785f4100..f2fbd9922c455df774801551d4d8003bf8495521 100644
--- a/src/js/plots/rpm-torque.mjs
+++ b/src/js/plots/rpm-torque.mjs
@@ -35,51 +35,54 @@ export function drawHydraulicRpmTorque(svg, { wraps = [] } = {}) {
     .filter(d => Number.isFinite(d.torque) && d.torque > 0 && Number.isFinite(d.rpmAvail) && d.rpmAvail >= 0);
 
   if (!data.length) {
     const msg = svgEl('text', {
       x: (svg.viewBox.baseVal.width || svg.clientWidth || 1000) / 2,
       y: (svg.viewBox.baseVal.height || svg.clientHeight || 540) / 2,
       'text-anchor': 'middle',
       'font-size': '16',
       fill: '#666'
     });
     msg.textContent = 'No hydraulic data available';
     svg.appendChild(msg);
     return;
   }
 
   data.sort((a, b) => a.torque - b.torque);
 
   const accent = getAccentColor();
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
   const H = svg.viewBox.baseVal.height || svg.clientHeight || 540;
   const ML = 70, MR = 20, MT = 20, MB = 60;
   const innerW = W - ML - MR;
   const innerH = H - MT - MB;
 
   const torqueMin = 0;
-  const torqueMax = Math.max(torqueMin + 1, Math.max(...data.map(d => d.torque)) * 1.05);
+  const torqueMaxData = Math.max(...data.map(d => d.torque));
+  const torqueExtent = Math.max(torqueMin + 1, torqueMaxData);
+  const { step: torqueStep } = niceTicks(torqueMin, torqueExtent, 6);
+  const torqueMax = torqueMin + Math.max(1, Math.ceil((torqueExtent - torqueMin) / Math.max(torqueStep, 1e-9))) * Math.max(torqueStep, 1e-9);
   const rpmMaxCandidate = Math.max(
     Math.max(...data.map(d => d.rpmAvail)),
     Math.max(...data.map(d => Number.isFinite(d.rpmFlow) ? d.rpmFlow : 0)),
     Math.max(...data.map(d => Number.isFinite(d.rpmPower) ? d.rpmPower : 0))
   );
   const rpmMin = 0;
   const rpmMax = Math.max(rpmMin + 1, rpmMaxCandidate * 1.1);
 
   const sx = torque => ML + (Math.min(Math.max(torque, torqueMin), torqueMax) - torqueMin) / (torqueMax - torqueMin) * innerW;
   const sy = rpm => MT + (1 - (Math.min(Math.max(rpm, rpmMin), rpmMax) - rpmMin) / (rpmMax - rpmMin)) * innerH;
 
   svg.appendChild(svgEl('rect', { x: ML, y: MT, width: innerW, height: innerH, fill: '#fff', stroke: '#ccc' }));
 
   const torqueTicks = niceTicks(torqueMin, torqueMax, 6).ticks;
   torqueTicks.forEach(t => {
     if (t < torqueMin - 1e-9 || t > torqueMax + 1e-9) return;
     const X = sx(t);
     svg.appendChild(svgEl('line', { x1: X, y1: MT, x2: X, y2: H - MB, stroke: '#eee' }));
     const label = svgEl('text', { x: X, y: H - 30, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' });
     label.textContent = formatNumber(t, 0);
     svg.appendChild(label);
   });
 
   const rpmTicks = niceTicks(rpmMin, rpmMax, 6).ticks;
   rpmTicks.forEach(r => {
