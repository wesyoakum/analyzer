diff --git a/src/js/main.mjs b/src/js/main.mjs
index 076fa7a8b54171d457b17d7913e69ea3878c4dc4..a34a43601c5acd3354a9dc391f32ee9e476db5f4 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -505,74 +505,74 @@ function computeAll() {
       }
 
       // ----- HYDRAULIC per wrap -----
       if (hydraulicEnabled) {
         // Pressure-limited drum torque and available tension
         const drum_T_pressure_max = torque_per_hmotor_maxP * torque_at_drum_maxP_factor; // NÂ·m at drum
         r.hyd_drum_torque_maxP_Nm = +drum_T_pressure_max.toFixed(2);
         const hyd_avail_tension_N = drum_T_pressure_max / Math.max(radius_m, 1e-12);
         r.hyd_avail_tension_kgf = +(hyd_avail_tension_N / G).toFixed(1);
 
         // Pressure required for current torque (per motor)
         const drum_T = tension_N * radius_m;
         const torque_per_hmotor = drum_T / (Math.max(gr1, 1e-9) * Math.max(gr2, 1e-9) * Math.max(motors, 1));
         let P_req_psi = psi_from_torque_and_disp_Nm_cc(torque_per_hmotor, h_hmot_cc);
         if (!Number.isFinite(P_req_psi) || P_req_psi < 0) P_req_psi = 0;
 
         // Flow-limited speed
         const rpm_flow_per_motor = Math.min(
           h_hmot_rpm_cap || Infinity,
           rpm_from_gpm_and_disp(q_tot_gpm / Math.max(motors, 1), h_hmot_cc)
         );
         const speed_flow_mpm = line_speed_mpm_from_motor_rpm(rpm_flow_per_motor, gr1, gr2, r.layer_dia_in);
 
         // Power-limited speed (cap pressure at max if P_req exceeds max)
         const P_power_psi = (P_req_psi > 0) ? Math.min(P_req_psi, h_max_psi) : 0;
-        let speed_power_mpm = 0, hp_used_at_available = 0, speed_avail_mpm = 0;
+        const hp_elec_in_total = (Number.isFinite(h_emotor_hp) ? h_emotor_hp : 0) *
+          (Number.isFinite(h_strings) ? h_strings : 0);
+        const eff_total = Number.isFinite(h_emotor_eff) ? h_emotor_eff : 0;
 
-        if (P_power_psi > 0) {
-          const gpm_power_max = (hp_tot_usable * 1714) / P_power_psi;
-          const rpm_power_per_motor = Math.min(
-            h_hmot_rpm_cap || Infinity,
-            rpm_from_gpm_and_disp(gpm_power_max / Math.max(motors, 1), h_hmot_cc)
-          );
-          speed_power_mpm = line_speed_mpm_from_motor_rpm(rpm_power_per_motor, gr1, gr2, r.layer_dia_in);
-          speed_avail_mpm = Math.min(speed_power_mpm, speed_flow_mpm);
+        let speed_power_mpm = 0;
+        if (hp_elec_in_total > 0 && eff_total > 0) {
+          speed_power_mpm = required_tension / (hp_elec_in_total * eff_total);
+        }
+        if (!Number.isFinite(speed_power_mpm) || speed_power_mpm < 0) speed_power_mpm = 0;
+
+        let speed_avail_mpm = Math.min(speed_power_mpm, speed_flow_mpm);
+        if (!Number.isFinite(speed_avail_mpm) || speed_avail_mpm < 0) speed_avail_mpm = 0;
 
+        let hp_used_at_available = 0;
+        if (speed_avail_mpm > 0 && P_power_psi > 0) {
           // Power used at the actual available speed
           const D_m = r.layer_dia_in * M_PER_IN;
           const drum_rpm_needed = speed_avail_mpm / (Math.PI * D_m);
           const motor_rpm_needed = drum_rpm_needed * (Math.max(gr1, 1) * Math.max(gr2, 1));
           const gpm_per_motor_needed = (motor_rpm_needed * h_hmot_cc) / CC_PER_GAL;
           const gpm_total_needed = Math.max(motors, 1) * gpm_per_motor_needed;
           const gpm_used = Math.min(gpm_total_needed, q_tot_gpm);
           hp_used_at_available = hp_from_psi_and_gpm(P_power_psi, gpm_used);
           if (hp_used_at_available > hp_tot_usable) hp_used_at_available = hp_tot_usable;
-        } else {
-          speed_power_mpm = speed_flow_mpm;
-          speed_avail_mpm = speed_flow_mpm;
-          hp_used_at_available = 0;
         }
 
         r.hyd_P_required_psi = Math.round(P_req_psi);
         r.hyd_speed_power_mpm = +speed_power_mpm.toFixed(2);
         r.hyd_speed_flow_mpm = +speed_flow_mpm.toFixed(2);
         r.hyd_speed_available_mpm = +speed_avail_mpm.toFixed(2);
         r.hyd_hp_used_at_available = +hp_used_at_available.toFixed(2);
         r.hyd_elec_input_hp_used = +((h_emotor_eff > 0 ? r.hyd_hp_used_at_available / h_emotor_eff : 0)).toFixed(2);
       } else {
         r.hyd_drum_torque_maxP_Nm = 0;
         r.hyd_avail_tension_kgf = 0;
         r.hyd_P_required_psi = 0;
         r.hyd_speed_power_mpm = 0;
         r.hyd_speed_flow_mpm = 0;
         r.hyd_speed_available_mpm = 0;
         r.hyd_hp_used_at_available = 0;
         r.hyd_elec_input_hp_used = 0;
       }
     }
 
     // ---- Drum visualization ----
     renderDrumVisualization(rows, summary, cfg, meta);
 
     // ---- Aggregate into per-layer tables ----
     lastElLayer = electricEnabled ? rowsToElectricLayer(rows, payload_kg, cable_w_kgpm, gr1, gr2, motors) : [];
