diff --git a/src/js/component-selectors.mjs b/src/js/component-selectors.mjs
index 8eccf31467284ad8f4cfcb2ab9766c3f9f72307f..b9ec472e3b97c020fc53a842d31b4ee369a939f9 100644
--- a/src/js/component-selectors.mjs
+++ b/src/js/component-selectors.mjs
@@ -25,50 +25,51 @@
   * @property {number|string|boolean} [motor_eff]
   * @property {number|string|boolean} [c_mm]
   * @property {number|string|boolean} [depth_m]
   * @property {number|string|boolean} [dead_m]
  * @property {number|string|boolean} [c_w_kgpm]
  * @property {number|string|boolean} [core_in]
  * @property {number|string|boolean} [flange_dia_in]
  * @property {number|string|boolean} [ftf_in]
  * @property {number|string|boolean} [lebus_in]
  * @property {number|string|boolean} [pack]
  * @property {number|string|boolean} [wraps_override]
  * @property {number|string|boolean} [motors]
  * @property {number|string|boolean} [gearbox_select]
  * @property {number|string|boolean} [electric_motor_select]
  * @property {number|string|boolean} [hydraulic_motor_select]
  * @property {number|string|boolean} [hydraulic_pump_select]
  * @property {number|string|boolean} [payload_select]
  * @property {number|string|boolean} [cable_select]
  * @property {number|string|boolean} [drum_select]
  * @property {number|string|boolean} [h_pump_strings]
  * @property {string} [hpu_select]
  * @property {string} [hpu_motor_select]
  * @property {number|string|boolean} [h_emotor_hp]
  * @property {number|string|boolean} [h_emotor_rpm]
  * @property {Record<string, unknown>} [metadata]
+ * @property {Record<string, unknown>} [data]
  */
 
 /**
  * @typedef {Object} SelectConfig
  * @property {string} selectId
  * @property {ComponentOption[]} options
  * @property {string} type
  * @property {string} label
  * @property {Record<string, keyof ComponentOption>} fieldMap
  * @property {boolean} [initialSkipEvents]
  * @property {ComponentOption[]} [customOptions]
  */
 
 /** @type {ComponentOption[]} */
 export const CABLE_OPTIONS = [
   {
     pn: '.681 Umbilical',
     description: '0.681 in diameter umbilical',
     c_mm: 17.3
   },
   {
     pn: '.322 Umbilical',
     description: '0.322 in diameter umbilical',
     c_mm: 8.18
   },
@@ -870,50 +871,148 @@ const SELECT_CONFIGS = [
   },
   {
     selectId: 'hydraulic_motor_select',
     options: HYDRAULIC_MOTOR_OPTIONS,
     type: 'hydraulic-motor',
     label: 'Hydraulic Motor',
     fieldMap: FIELD_MAPS.hydraulicMotor
   },
   {
     selectId: 'system_select',
     options: SYSTEM_OPTIONS,
     type: 'system',
     label: 'System',
     fieldMap: FIELD_MAPS.system,
     initialSkipEvents: false
   }
 ];
 
 const watchedInputs = new Set();
 const CREATE_NEW_VALUE = '__component_create_new__';
 const COMPONENT_STORAGE_PREFIX = 'analyzer.components.';
 /** @type {Map<string, ComponentOption[]>} */
 const memoryCustomOptions = new Map();
 let cachedComponentStorage;
 
+function isPlainObject(value) {
+  return typeof value === 'object' && value !== null && !Array.isArray(value);
+}
+
+function cloneOption(option) {
+  const clone = { ...option };
+  if (isPlainObject(option.metadata)) {
+    clone.metadata = { ...option.metadata };
+  }
+  if (isPlainObject(option.data)) {
+    clone.data = { ...option.data };
+  }
+  return clone;
+}
+
+function rememberCustomOptions(type, options) {
+  if (!type) return;
+  const list = Array.isArray(options) ? options.map(cloneOption) : [];
+  memoryCustomOptions.set(type, list);
+}
+
+function getRememberedCustomOptions(type) {
+  if (!type) return [];
+  const existing = memoryCustomOptions.get(type);
+  return existing ? existing.map(cloneOption) : [];
+}
+
+function persistCustomOptions(type) {
+  if (!type) return;
+  const storage = getComponentStorage();
+  if (!storage) return;
+  try {
+    const snapshot = memoryCustomOptions.get(type) ?? [];
+    storage.setItem(`${COMPONENT_STORAGE_PREFIX}${type}`, JSON.stringify(snapshot));
+  } catch (err) {
+    console.warn(`Unable to persist custom ${type} options:`, err);
+  }
+}
+
+function refreshSelectsForType(type) {
+  if (!type) return;
+  const snapshot = getRememberedCustomOptions(type);
+  SELECT_CONFIGS.forEach(config => {
+    if (config.type !== type) return;
+    config.customOptions = snapshot.map(cloneOption);
+    const selectEl = /** @type {HTMLSelectElement|null} */ (document.getElementById(config.selectId));
+    if (!selectEl) return;
+    const prior = selectEl.value;
+    populateSelectOptions(selectEl, config, { selectedValue: prior });
+  });
+}
+
+function replaceCustomOptions(type, options, { persist = true } = {}) {
+  if (!type) return;
+  rememberCustomOptions(type, options);
+  refreshSelectsForType(type);
+  if (persist) {
+    persistCustomOptions(type);
+  }
+}
+
+function optionIdentity(option) {
+  if (!option) return null;
+  if (typeof option.id === 'string' && option.id.length) {
+    return `id:${option.id}`;
+  }
+  if (typeof option.pn === 'string' && option.pn.length) {
+    return `pn:${option.pn.toLowerCase()}`;
+  }
+  return null;
+}
+
+function mergeCustomOptionLists(existing, incoming) {
+  const result = Array.isArray(existing) ? existing.map(cloneOption) : [];
+  if (!Array.isArray(incoming)) {
+    return result;
+  }
+  incoming.forEach(option => {
+    const key = optionIdentity(option);
+    if (!key) return;
+    const clone = cloneOption(option);
+    const index = result.findIndex(item => optionIdentity(item) === key);
+    if (index >= 0) {
+      result[index] = clone;
+    } else {
+      result.push(clone);
+    }
+  });
+  return result;
+}
+
+function upsertCustomOption(type, option, { persist = true } = {}) {
+  if (!type) return;
+  const existing = memoryCustomOptions.get(type) ?? [];
+  const merged = mergeCustomOptionLists(existing, [option]);
+  replaceCustomOptions(type, merged, { persist });
+}
+
 function normalizePresetDataForOption(data, fieldMap) {
   if (!data || typeof data !== 'object' || Array.isArray(data)) {
     return {};
   }
 
   const normalized = {};
   const entries = Object.entries(data);
   const fieldMapEntries =
     fieldMap && typeof fieldMap === 'object' && !Array.isArray(fieldMap)
       ? Object.entries(fieldMap)
       : [];
   const inputIds = new Set(fieldMapEntries.map(([inputId]) => inputId));
 
   entries.forEach(([key, value]) => {
     if (!inputIds.has(key)) {
       normalized[key] = value;
     }
   });
 
   fieldMapEntries.forEach(([inputId, optionKey]) => {
     if (typeof optionKey !== 'string' || optionKey.length === 0) return;
     if (Object.prototype.hasOwnProperty.call(data, optionKey)) {
       normalized[optionKey] = data[optionKey];
       return;
     }
@@ -954,112 +1053,101 @@ function normalizeStoredOption(raw, expectedType) {
     typeof raw.name === 'string' && raw.name.trim().length ? raw.name : optionPn ?? (pnFromMetadata ?? undefined);
   const description = typeof raw.description === 'string' && raw.description.length ? raw.description : undefined;
   const id = typeof raw.id === 'string' ? raw.id : undefined;
 
   const data = raw.data && typeof raw.data === 'object' && !Array.isArray(raw.data)
     ? normalizePresetDataForOption(raw.data, metadata?.fieldMap)
     : extractOptionData(raw);
 
   const pn = optionPn ?? optionName;
   if (!pn || typeof pn !== 'string') {
     return null;
   }
 
   const option = {
     pn,
     name: optionName ?? pn,
     ...(description ? { description } : {}),
     ...data
   };
 
   if (id) {
     option.id = id;
   }
 
   if (metadata) {
-    option.metadata = metadata;
+    option.metadata = { ...metadata };
+  }
+
+  if (raw.data && typeof raw.data === 'object' && !Array.isArray(raw.data)) {
+    option.data = { ...raw.data };
   }
 
   return option;
 }
 
 function getComponentStorage() {
   if (cachedComponentStorage !== undefined) return cachedComponentStorage;
   if (typeof window === 'undefined' || !window.localStorage) {
     cachedComponentStorage = null;
     return cachedComponentStorage;
   }
   try {
     const { localStorage } = window;
     const probe = `${COMPONENT_STORAGE_PREFIX}__probe__`;
     localStorage.setItem(probe, '1');
     localStorage.removeItem(probe);
     cachedComponentStorage = localStorage;
   } catch (err) {
     console.warn('Component preset storage disabled:', err);
     cachedComponentStorage = null;
   }
   return cachedComponentStorage;
 }
 
 function loadCustomOptions(type) {
   const storage = getComponentStorage();
   if (storage) {
     try {
       const raw = storage.getItem(`${COMPONENT_STORAGE_PREFIX}${type}`);
       if (raw) {
         const parsed = JSON.parse(raw);
         if (Array.isArray(parsed)) {
           return parsed
             .map(opt => normalizeStoredOption(opt, type))
             .filter((opt) => opt && typeof opt.pn === 'string')
             .map(opt => ({ ...opt, name: opt.name ?? opt.pn }));
         }
       }
     } catch (err) {
       console.warn(`Unable to read custom ${type} options:`, err);
     }
   }
-  const fallback = memoryCustomOptions.get(type);
-  return fallback
-    ? fallback
-        .map(opt => normalizeStoredOption(opt, type))
-        .filter((opt) => opt && typeof opt.pn === 'string')
-        .map(opt => ({ ...opt, name: opt.name ?? opt.pn }))
-    : [];
-}
-
-function saveCustomOptions(type, options) {
-  const clean = options.map(opt => ({ ...opt }));
-  memoryCustomOptions.set(type, clean);
-  const storage = getComponentStorage();
-  if (!storage) return;
-  try {
-    storage.setItem(`${COMPONENT_STORAGE_PREFIX}${type}`, JSON.stringify(clean));
-  } catch (err) {
-    console.warn(`Unable to persist custom ${type} options:`, err);
-  }
+  return getRememberedCustomOptions(type)
+    .map(opt => normalizeStoredOption(opt, type))
+    .filter((opt) => opt && typeof opt.pn === 'string')
+    .map(opt => ({ ...opt, name: opt.name ?? opt.pn }));
 }
 
 function allOptions(config) {
   const base = Array.isArray(config.options) ? config.options : [];
   const custom = Array.isArray(config.customOptions) ? config.customOptions : [];
   return base.concat(custom);
 }
 
 function findOption(config, pn) {
   return allOptions(config).find(opt => opt.pn === pn);
 }
 
 function readFieldValue(inputId) {
   const el = /** @type {HTMLElement|null} */ (document.getElementById(inputId));
   if (!el) return undefined;
   if (el instanceof HTMLInputElement) {
     if (el.type === 'checkbox') {
       return el.checked;
     }
     if (el.type === 'number') {
       if (el.value === '') return undefined;
       const num = Number(el.value);
       return Number.isNaN(num) ? undefined : num;
     }
     return el.value;
@@ -1181,66 +1269,84 @@ async function handleCreateNew(config, selectEl) {
         // Ignore JSON parsing errors; fall back to generic message.
       }
       window.alert(message);
       return null;
     }
 
     let body;
     try {
       body = await response.json();
     } catch (err) {
       window.alert('Failed to parse server response when creating preset.');
       return null;
     }
 
     const preset = body?.preset;
     if (!preset || typeof preset.id !== 'string') {
       window.alert('Server response did not include the created preset.');
       return null;
     }
 
     const presetData =
       preset && typeof preset.data === 'object' && preset.data !== null && !Array.isArray(preset.data)
         ? preset.data
         : values;
 
+    const serverMetadata =
+      preset.metadata && typeof preset.metadata === 'object' && !Array.isArray(preset.metadata)
+        ? preset.metadata
+        : undefined;
+    const mergedMetadata = {
+      ...metadata,
+      ...(serverMetadata ?? {})
+    };
+    if (!mergedMetadata.pn) {
+      mergedMetadata.pn = pn;
+    }
+    if (config.type && !mergedMetadata.type) {
+      mergedMetadata.type = config.type;
+    }
+    if (config.label && !mergedMetadata.label) {
+      mergedMetadata.label = config.label;
+    }
+
+    const normalizedOptionData = normalizePresetDataForOption(presetData, mergedMetadata?.fieldMap);
+
     /** @type {ComponentOption} */
     const option = {
       pn,
       name: preset.name ?? pn,
       ...(preset.description ? { description: preset.description } : {}),
-      ...presetData,
+      ...normalizedOptionData,
       id: preset.id,
-      metadata
+      metadata: { ...mergedMetadata },
+      data: { ...presetData }
     };
 
-    if (!Array.isArray(config.customOptions)) {
-      config.customOptions = [];
+    if (config.type) {
+      upsertCustomOption(config.type, option);
     }
-    config.customOptions.push(option);
-    saveCustomOptions(config.type, config.customOptions);
-    populateSelectOptions(selectEl, config, { selectedValue: pn });
     return pn;
   } catch (err) {
     const message = err instanceof Error ? err.message : String(err);
     window.alert(`Unable to create ${label} preset: ${message}`);
     return null;
   } finally {
     selectEl.disabled = wasDisabled;
   }
 }
 
 function describeOption(config, option) {
   const parts = [option.name ?? option.pn];
   if (option.description) parts.push(option.description);
   return parts.join(' â€” ');
 }
 
 function attachWatcher(inputId) {
   if (watchedInputs.has(inputId)) return;
   const el = /** @type {HTMLElement|null} */ (document.getElementById(inputId));
   if (!el) return;
   const handler = () => {
     if (el.dataset.componentSuppress === '1') return;
     const selectId = el.dataset.componentSelect;
     if (!selectId) return;
     delete el.dataset.componentSelect;
@@ -1299,78 +1405,171 @@ function applySelection(config, pn, { skipEvents = false } = {}) {
       if (inputEl.type === 'checkbox') {
         inputEl.checked = Boolean(value);
       } else {
         inputEl.value = String(value);
       }
     } else if (inputEl instanceof HTMLSelectElement || inputEl instanceof HTMLTextAreaElement) {
       inputEl.value = String(value);
     } else {
       inputEl.textContent = String(value);
     }
     if (!skipEvents) {
       if (inputEl instanceof HTMLInputElement) {
         if (inputEl.type !== 'checkbox' && inputEl.type !== 'radio' && inputEl.type !== 'range' && inputEl.type !== 'color') {
           inputEl.dispatchEvent(new Event('input', { bubbles: true }));
         }
         inputEl.dispatchEvent(new Event('change', { bubbles: true }));
       } else {
         inputEl.dispatchEvent(new Event('change', { bubbles: true }));
       }
     }
     delete inputEl.dataset.componentSuppress;
   });
 }
 
 export function setupComponentSelectors() {
+  const initializedTypes = new Set();
+  SELECT_CONFIGS.forEach(config => {
+    const type = config.type;
+    if (!type || initializedTypes.has(type)) return;
+    const loaded = loadCustomOptions(type);
+    rememberCustomOptions(type, loaded);
+    initializedTypes.add(type);
+  });
+
   SELECT_CONFIGS.forEach(config => {
     const selectEl = /** @type {HTMLSelectElement|null} */ (document.getElementById(config.selectId));
     if (!selectEl) return;
-    config.customOptions = loadCustomOptions(config.type);
+
+    const customOptions = getRememberedCustomOptions(config.type);
+    config.customOptions = customOptions;
 
     const initialValue = selectEl.value;
     const { initialSkipEvents = true } = config;
 
     populateSelectOptions(selectEl, config, { selectedValue: initialValue });
 
     Object.keys(config.fieldMap).forEach(inputId => attachWatcher(inputId));
 
     let previousValue = selectEl.value && selectEl.value !== CREATE_NEW_VALUE ? selectEl.value : '';
     let suppressNext = false;
 
     const ensureOptionApplied = (value, { skipEvents = false } = {}) => {
       applySelection(config, value, { skipEvents });
     };
 
     selectEl.addEventListener('change', async () => {
       if (suppressNext) {
         suppressNext = false;
         previousValue = selectEl.value;
         ensureOptionApplied(selectEl.value);
         return;
       }
 
       const value = selectEl.value;
       if (value === CREATE_NEW_VALUE) {
         selectEl.value = previousValue;
         const createdPn = await handleCreateNew(config, selectEl);
         if (createdPn) {
           previousValue = createdPn;
           suppressNext = true;
           selectEl.value = createdPn;
           ensureOptionApplied(createdPn);
           selectEl.dispatchEvent(new Event('change', { bubbles: true }));
         } else {
           ensureOptionApplied(previousValue);
         }
         return;
       }
 
       previousValue = value;
       ensureOptionApplied(value);
     });
 
     // Apply persisted selection if present
     if (selectEl.value) {
       ensureOptionApplied(selectEl.value, { skipEvents: initialSkipEvents });
     }
   });
+
+  void fetchAndApplyServerPresets();
+}
+
+async function fetchAndApplyServerPresets() {
+  if (typeof window === 'undefined' || typeof window.fetch !== 'function') {
+    return;
+  }
+
+  let response;
+  try {
+    response = await fetch('/api/presets');
+  } catch (err) {
+    console.warn('Unable to fetch presets from server:', err);
+    return;
+  }
+
+  if (!response.ok) {
+    console.warn('Failed to load presets from server.');
+    return;
+  }
+
+  let body;
+  try {
+    body = await response.json();
+  } catch (err) {
+    console.warn('Unable to parse presets response from server:', err);
+    return;
+  }
+
+  const presets = Array.isArray(body?.presets) ? body.presets : [];
+  if (!presets.length) {
+    return;
+  }
+
+  /** @type {Map<string, ComponentOption[]>} */
+  const grouped = new Map();
+
+  presets.forEach(preset => {
+    if (!preset || typeof preset !== 'object' || Array.isArray(preset)) {
+      return;
+    }
+    const metadata =
+      preset.metadata && typeof preset.metadata === 'object' && !Array.isArray(preset.metadata)
+        ? preset.metadata
+        : undefined;
+    const type = metadata && typeof metadata.type === 'string' ? metadata.type : undefined;
+    if (!type) {
+      return;
+    }
+    const option = normalizeStoredOption(preset, type);
+    if (!option) {
+      return;
+    }
+    if (metadata) {
+      option.metadata = { ...metadata, ...(option.metadata ?? {}) };
+    }
+    if (!option.metadata) {
+      option.metadata = {};
+    }
+    if (typeof option.metadata.pn !== 'string') {
+      option.metadata.pn = option.pn;
+    }
+    if (type && option.metadata.type !== type) {
+      option.metadata.type = type;
+    }
+    if (preset.data && typeof preset.data === 'object' && !Array.isArray(preset.data)) {
+      option.data = { ...preset.data };
+    }
+    const list = grouped.get(type) ?? [];
+    list.push(option);
+    grouped.set(type, list);
+  });
+
+  grouped.forEach((options, type) => {
+    if (!options.length) {
+      return;
+    }
+    const existing = getRememberedCustomOptions(type);
+    const merged = mergeCustomOptionLists(existing, options);
+    replaceCustomOptions(type, merged, { persist: true });
+  });
 }
