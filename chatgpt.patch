diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index 901aa65d819c817d9c7dd8d7f5f9d943a4526c41..c2b81cf3314ab09e310fd48735b8c07e8cb618a1 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -171,70 +171,73 @@ export function drawDepthProfiles(svgSpeed, svgTension, {
 function drawSpeedProfile(svg, segments, depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs = null, options = {}) {
   if (svg && svg._depthSpeedHoverHandlers) {
     const { move, leave } = svg._depthSpeedHoverHandlers;
     svg.removeEventListener('pointermove', move);
     svg.removeEventListener('pointerleave', leave);
     svg.removeEventListener('pointerenter', move);
     delete svg._depthSpeedHoverHandlers;
   }
 
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const ML = 64, MR = 18, MT = 18, MB = 46;
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
   const H = svg.viewBox.baseVal.height || svg.clientHeight || 540;
   const innerW = W - ML - MR, innerH = H - MT - MB;
 
   const clampDepth = d => Math.min(Math.max(d, depthMin), depthMax);
   const clampSpeed = v => Math.min(Math.max(v, speedMin), speedMax);
   const depthSpan = Math.max(1e-9, depthMax - depthMin);
   const speedSpan = Math.max(1e-9, speedMax - speedMin);
 
   const sx = d => ML + (clampDepth(d) - depthMin) / depthSpan * innerW;
   const sy = v => MT + (1 - (clampSpeed(v) - speedMin) / speedSpan) * innerH;
 
   const extraProfiles = Array.isArray(options.extraProfiles) ? options.extraProfiles : [];
+  const showLegend = options && options.showLegend !== undefined ? Boolean(options.showLegend) : true;
   const legendEntries = [];
-  if (options.primaryLabel) {
+  if (showLegend && options.primaryLabel) {
     legendEntries.push({ label: options.primaryLabel, color: accentColor, strokeWidth: 4.8, strokeDasharray: null });
   }
-  extraProfiles.forEach(profile => {
-    if (!profile || !profile.label) return;
-    const defaultDash = '6 4';
-    const strokeDash = (profile.legendStrokeDasharray === undefined)
-      ? ((profile.strokeDasharray === undefined) ? defaultDash : profile.strokeDasharray)
-      : profile.legendStrokeDasharray;
-    const strokeWidth = Number.isFinite(profile.legendStrokeWidth)
-      ? profile.legendStrokeWidth
-      : (Number.isFinite(profile.strokeWidth) ? profile.strokeWidth : 3);
-    legendEntries.push({
-      label: profile.label,
-      color: profile.color || '#555',
-      strokeDasharray: strokeDash,
-      strokeWidth
+  if (showLegend) {
+    extraProfiles.forEach(profile => {
+      if (!profile || !profile.label) return;
+      const defaultDash = '6 4';
+      const strokeDash = (profile.legendStrokeDasharray === undefined)
+        ? ((profile.strokeDasharray === undefined) ? defaultDash : profile.strokeDasharray)
+        : profile.legendStrokeDasharray;
+      const strokeWidth = Number.isFinite(profile.legendStrokeWidth)
+        ? profile.legendStrokeWidth
+        : (Number.isFinite(profile.strokeWidth) ? profile.strokeWidth : 3);
+      legendEntries.push({
+        label: profile.label,
+        color: profile.color || '#555',
+        strokeDasharray: strokeDash,
+        strokeWidth
+      });
     });
-  });
+  }
 
   svg.appendChild(svgEl('rect', { x: ML, y: MT, width: innerW, height: innerH, fill: '#fff', stroke: '#ccc' }));
 
   niceTicks(depthMin, depthMax, 8).ticks.forEach(dx => {
     if (dx < depthMin - 1e-9 || dx > depthMax + 1e-9) return;
     const X = sx(dx);
     svg.appendChild(svgEl('line', { x1: X, y1: MT, x2: X, y2: H - MB, stroke: '#eee' }));
     const t = svgEl('text', { x: X, y: H - 8, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' });
     t.textContent = formatDepthLabel(dx);
     svg.appendChild(t);
   });
   niceTicks(speedMin, speedMax, 6).ticks.forEach(v => {
     if (v < speedMin - 1e-9 || v > speedMax + 1e-9) return;
     const Y = sy(v);
     svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#eee' }));
     const t = svgEl('text', { x: ML - 6, y: Y + 4, 'text-anchor': 'end', 'font-size': '12', fill: '#444' });
     t.textContent = String(Math.round(v * 100) / 100);
     svg.appendChild(t);
   });
 
   svg.appendChild(svgEl('text', { x: ML + innerW / 2, y: H - 4, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' }))
     .textContent = 'Depth (m)';
   svg.appendChild(svgEl('text', {
     x: 18, y: MT + innerH / 2, transform: `rotate(-90,18,${MT + innerH / 2})`,
     'text-anchor': 'middle', 'font-size': '12', fill: '#444'
@@ -530,51 +533,52 @@ function drawSpeedProfile(svg, segments, depthMin, depthMax, speedMin, speedMax,
         y2: 0,
         stroke: entry.color || '#555',
         'stroke-width': Number.isFinite(entry.strokeWidth) ? entry.strokeWidth : 3
       };
       if (entry.strokeDasharray) lineAttrs['stroke-dasharray'] = entry.strokeDasharray;
       g.appendChild(svgEl('line', lineAttrs));
       const text = svgEl('text', { x: 28, y: 4, 'font-size': '12', fill: '#333' });
       text.textContent = entry.label;
       g.appendChild(text);
       legendGroup.appendChild(g);
       offsetY += 18;
     });
     svg.appendChild(legendGroup);
   }
 }
 
 export function drawStandaloneSpeedProfiles(svg, {
   segments = [],
   extraProfiles = [],
   depthMin: depthMinOverride,
   depthMax: depthMaxOverride,
   speedMin: speedMinOverride,
   speedMax: speedMaxOverride,
   ratedSpeedMs = null,
   primaryLabel = null,
-  accentColor: accentOverride
+  accentColor: accentOverride,
+  showLegend = true
 } = {}) {
   if (!svg) return;
 
   const allSegments = [];
   const collectSegment = seg => {
     if (!seg) return;
     const d0 = Number.isFinite(seg.depth_start) ? seg.depth_start : null;
     const d1 = Number.isFinite(seg.depth_end) ? seg.depth_end : null;
     const speed = Number.isFinite(seg.speed_ms) ? seg.speed_ms : null;
     if (Number.isFinite(d0)) allSegments.push({ type: 'depth', value: d0 });
     if (Number.isFinite(d1)) allSegments.push({ type: 'depth', value: d1 });
     if (Number.isFinite(speed)) allSegments.push({ type: 'speed', value: speed });
   };
 
   (segments || []).forEach(collectSegment);
   (extraProfiles || []).forEach(profile => {
     if (!profile || !Array.isArray(profile.segments)) return;
     profile.segments.forEach(collectSegment);
   });
 
   let depthMin = Number.isFinite(depthMinOverride) ? Math.max(0, depthMinOverride) : 0;
   let depthMax;
   if (Number.isFinite(depthMaxOverride)) {
     depthMax = Math.max(depthMin + 0.1, depthMaxOverride);
   } else {
@@ -583,51 +587,52 @@ export function drawStandaloneSpeedProfiles(svg, {
       if (entry.type === 'depth' && Number.isFinite(entry.value)) depthCandidates.push(entry.value);
     });
     const autoDepthMax = Math.max(...depthCandidates);
     depthMax = Number.isFinite(autoDepthMax) ? autoDepthMax : depthMin + 1;
   }
   if (!Number.isFinite(depthMax) || depthMax <= depthMin) depthMax = depthMin + 1;
 
   let speedMin = Number.isFinite(speedMinOverride) ? Math.max(0, speedMinOverride) : 0;
   let speedMax;
   if (Number.isFinite(speedMaxOverride)) {
     speedMax = Math.max(speedMin + 0.1, speedMaxOverride);
   } else {
     const speedCandidates = [speedMin + 0.1, 3];
     allSegments.forEach(entry => {
       if (entry.type === 'speed' && Number.isFinite(entry.value)) speedCandidates.push(entry.value);
     });
     const autoSpeedMax = Math.max(...speedCandidates);
     speedMax = Number.isFinite(autoSpeedMax) ? autoSpeedMax : speedMin + 1;
   }
   if (!Number.isFinite(speedMax) || speedMax <= speedMin) speedMax = speedMin + 1;
 
   const accentColor = accentOverride || getAccentColor();
 
   drawSpeedProfile(svg, segments || [], depthMin, depthMax, speedMin, speedMax, accentColor, ratedSpeedMs, {
     primaryLabel,
-    extraProfiles: Array.isArray(extraProfiles) ? extraProfiles : []
+    extraProfiles: Array.isArray(extraProfiles) ? extraProfiles : [],
+    showLegend
   });
 }
 
 function findRatedDepthLimit(segments, ratedSpeedMs) {
   if (!Array.isArray(segments) || !Number.isFinite(ratedSpeedMs) || ratedSpeedMs <= 0) return null;
   const ranges = segments
     .filter(S => Number.isFinite(S.speed_ms))
     .map(S => ({
       d0: Math.min(S.depth_start, S.depth_end),
       d1: Math.max(S.depth_start, S.depth_end),
       speed: S.speed_ms
     }))
     .sort((a, b) => a.d0 - b.d0);
 
   if (!ranges.length) return null;
 
   let deepestReach = null;
   let hasReachable = false;
 
   for (const range of ranges) {
     if (isRatedBelowAvailable(ratedSpeedMs, range.speed)) {
       hasReachable = true;
       deepestReach = (deepestReach === null) ? range.d1 : Math.max(deepestReach, range.d1);
       continue;
     }
