diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index 0cc41821adeea92aaa1285a08a5a1f8cde412dc0..6211e04e1a463fb102d756253a0a62440f805e07 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -256,63 +256,66 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
     ? meta.wraps_per_layer_used
     : (cable_dia_in > 0 ? (Math.max(flange_to_flange_in || 0, 0) / Math.max(cable_dia_in, 1e-9)) : 0);
 
   const wrapsByLayer = new Map();
   for (const row of rows) {
     wrapsByLayer.set(row.layer_no, (wrapsByLayer.get(row.layer_no) || 0) + 1);
   }
 
   if (cableRadiusPx > 0 && coreWidthPx > 0) {
     layersForViz.forEach(layer => {
       const actualWraps = wrapsByLayer.get(layer.layer_no) || 0;
       if (actualWraps <= 0) return;
       const centerOffsetPx = layer.center_radius_in * scale;
       const topY = centerY - centerOffsetPx;
       const bottomY = centerY + centerOffsetPx;
 
       const wrapSlots = Number.isFinite(theoreticalWrapsPerLayer) && theoreticalWrapsPerLayer > 0
         ? theoreticalWrapsPerLayer
         : actualWraps;
       const spacingDivisor = wrapSlots > 1 ? wrapSlots - 1 : 0;
       const spacingIn = spacingDivisor > 0
         ? (Math.max(flange_to_flange_in || 0, 0) - Math.max(cable_dia_in, 0)) / spacingDivisor
         : 0;
       const spacingPx = Math.max(spacingIn, 0) * scale;
       const startFromLeft = (layer.layer_no % 2) === 1;
-      const startCx = startFromLeft
+      let startCx = startFromLeft
         ? spoolLeft + cableRadiusPx
         : spoolRight - cableRadiusPx;
       const delta = startFromLeft ? spacingPx : -spacingPx;
 
       let wrapsToDraw = actualWraps;
       if (
         Number.isFinite(theoreticalWrapsPerLayer) &&
         isWhole(theoreticalWrapsPerLayer) &&
         (layer.layer_no % 2 === 0)
       ) {
         const evenLayerMax = Math.max(Math.round(theoreticalWrapsPerLayer) - 1, 0);
         wrapsToDraw = Math.min(wrapsToDraw, evenLayerMax);
+        if (!startFromLeft && spacingPx > 0) {
+          startCx -= spacingPx / 2;
+        }
       }
 
       for (let w = 0; w < wrapsToDraw; w++) {
         const cx = startCx + w * delta;
         if (cx - cableRadiusPx < spoolLeft - 1e-3) continue;
         if (cx + cableRadiusPx > spoolRight + 1e-3) continue;
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: topY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
         }));
 
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: bottomY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: layer.fillColor,
           stroke: layer.strokeColor,
           'stroke-width': strokeWidthAttr,
           'vector-effect': 'non-scaling-stroke'
