diff --git a/src/js/plots/rpm-torque.mjs b/src/js/plots/rpm-torque.mjs
index e37a47abffb6ba3d68ea5dd512b97820f907b2ab..794087270b0237cfcc9472c541ec89aa1df6a175 100644
--- a/src/js/plots/rpm-torque.mjs
+++ b/src/js/plots/rpm-torque.mjs
@@ -109,53 +109,43 @@ export function drawHydraulicRpmTorque(svg, { wraps = [] } = {}) {
       .map(d => [d.torque, d[field]])
       .filter(([torque, rpm]) => Number.isFinite(torque) && Number.isFinite(rpm));
 
     if (!points.length) return '';
 
     if (dropAtMaxTorque) {
       const lastPoint = points[points.length - 1];
       if (lastPoint && lastPoint[1] > rpmMin + 1e-9) {
         points.push([lastPoint[0], rpmMin]);
       }
     }
 
     return svgPathFromPoints(points.map(([torque, rpm]) => [sx(torque), sy(rpm)]));
   };
 
   const availPath = pathFor('rpmAvail', { dropAtMaxTorque: true });
   if (availPath) {
     svg.appendChild(svgEl('path', {
       d: availPath,
       fill: 'none',
       stroke: accent,
       'stroke-width': 3
     }));
   }
 
-  data.forEach(d => {
-    svg.appendChild(svgEl('circle', {
-      cx: sx(d.torque),
-      cy: sy(d.rpmAvail),
-      r: 3,
-      fill: '#fff',
-      stroke: accent,
-      'stroke-width': 1.5
-    }));
-  });
 }
 
 function toNumber(val) {
   if (val === null || val === undefined) return NaN;
   if (typeof val === 'string') {
     const trimmed = val.trim();
     if (!trimmed) return NaN;
     const parsed = Number(trimmed);
     return Number.isFinite(parsed) ? parsed : NaN;
   }
   const num = Number(val);
   return Number.isFinite(num) ? num : NaN;
 }
 
 function formatNumber(val, decimals = 0) {
   const factor = Math.pow(10, decimals);
   return String(Math.round(val * factor) / factor);
 }
