diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index ff6dac38f6a6f78cd3737fe18b4713c8b044387f..483226ca5208089dba0f0e27587ccc4070543dd6 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -310,113 +310,126 @@ function buildTensionSegments(segments, payload_kg, cable_w_kgpm, maxDepth, {
     const firstColor = above0 ? colorAbove : colorBelow;
     const secondColor = above0 ? colorBelow : colorAbove;
 
     pieces.push({ d0, d1: clamped, color: firstColor, T0, T1: Tcross });
     pieces.push({ d0: clamped, d1, color: secondColor, T0: Tcross, T1 });
   }
 
   // Merge adjacent pieces of same color
   const merged = [];
   for (const piece of pieces) {
     if (!merged.length) {
       merged.push({ ...piece });
       continue;
     }
     const last = merged[merged.length - 1];
     if (piece.color === last.color && Math.abs(piece.d0 - last.d1) < 1e-6) {
       last.d1 = piece.d1;
       last.T1 = piece.T1;
     } else {
       merged.push({ ...piece });
     }
   }
   return merged;
 }
 
+function coerceNumeric(wrap, field) {
+  if (!wrap) return null;
+  const raw = wrap[field];
+  if (Number.isFinite(raw)) return raw;
+  if (typeof raw === 'string') {
+    const cleaned = raw.replace(/,/g, '').trim();
+    if (!cleaned) return null;
+    const parsed = Number.parseFloat(cleaned);
+    return Number.isFinite(parsed) ? parsed : null;
+  }
+  return null;
+}
+
 function wrapsToDepthSegments(wraps, speedField, tensionField, deadEnd = 0, scenario = 'electric') {
   /** @type {Array<Object>} */
   const segments = [];
   let fallbackStart = null;
 
   for (const wrap of wraps) {
     if (!wrap) continue;
-    const totalLen = Number.isFinite(wrap.total_cable_len_m) ? wrap.total_cable_len_m : null;
-    const preOn = Number.isFinite(wrap.pre_spooled_len_m) ? wrap.pre_spooled_len_m : null;
-    let depthEnd = Number.isFinite(wrap.deployed_len_m) ? wrap.deployed_len_m : null;
+    const totalLen = coerceNumeric(wrap, 'total_cable_len_m');
+    const preOn = coerceNumeric(wrap, 'pre_spooled_len_m');
+    let depthEnd = coerceNumeric(wrap, 'deployed_len_m');
 
     if (!Number.isFinite(depthEnd)) {
       fallbackStart = null;
       continue;
     }
 
     let depthStart = null;
     if (Number.isFinite(totalLen) && Number.isFinite(preOn)) {
       depthStart = totalLen - preOn;
     } else if (Number.isFinite(fallbackStart)) {
       depthStart = fallbackStart;
     }
 
     if (!Number.isFinite(depthStart)) {
       depthStart = depthEnd;
     }
 
     if (depthStart < depthEnd) {
       const tmp = depthStart;
       depthStart = depthEnd;
       depthEnd = tmp;
     }
 
     const toDepth = (v) => {
       if (!Number.isFinite(v)) return 0;
       const adj = v - deadEnd;
       return +Math.max(0, adj).toFixed(3);
     };
     depthStart = toDepth(depthStart);
     depthEnd = toDepth(depthEnd);
 
-    const speedValMpm = Number.isFinite(wrap[speedField]) ? wrap[speedField] : null;
+    const speedValMpm = coerceNumeric(wrap, speedField);
     const candidateFields = (scenario === 'hydraulic')
       ? [
           { field: 'hyd_speed_power_mpm', kind: 'power' },
           { field: 'hyd_speed_flow_mpm', kind: 'flow' }
         ]
       : [];
     /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
     const candidateSpeedsMs = [];
     for (const { field, kind } of candidateFields) {
-      const val = Number.isFinite(wrap[field]) ? wrap[field] : null;
+      const val = coerceNumeric(wrap, field);
       if (!Number.isFinite(val)) continue;
       const ms = val / 60;
       if (Number.isFinite(ms)) candidateSpeedsMs.push({ kind, value_ms: ms });
     }
 
     const speedMs = Number.isFinite(speedValMpm) ? speedValMpm / 60 : null;
     /** @type {{kind: 'power'|'flow', value_ms: number}[]} */
     const filteredCandidates = [];
     const seenKeys = new Set();
     for (const candidate of candidateSpeedsMs) {
       if (speedMs !== null && Math.abs(candidate.value_ms - speedMs) <= 1e-6) {
         continue;
       }
       const key = `${candidate.kind}:${candidate.value_ms.toFixed(6)}`;
       if (seenKeys.has(key)) continue;
       seenKeys.add(key);
       filteredCandidates.push(candidate);
     }
-    const tensionVal = Number.isFinite(wrap[tensionField]) ? wrap[tensionField] : null;
+    const tensionVal = coerceNumeric(wrap, tensionField);
 
     segments.push({
       depth_start: depthStart,
       depth_end: depthEnd,
       speed_ms: speedMs,
       candidate_speeds_ms: filteredCandidates,
       avail_tension_kgf: Number.isFinite(tensionVal) ? tensionVal : null,
       label: Number.isFinite(wrap.wrap_no)
         ? `W${wrap.wrap_no}`
         : (Number.isFinite(wrap.layer_no) ? `L${wrap.layer_no}` : '')
     });
 
     fallbackStart = depthEnd + deadEnd;
   }
 
   return segments;
 }
