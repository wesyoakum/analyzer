diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index 307c4e4aa97a637466183b24d47c3d4f8668652c..6bcc42832bdd9584dbb1c7aa631169e6c8c6707d 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -157,90 +157,99 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
     lebus_thk_in
   } = cfg;
 
   svg.setAttribute('viewBox', `0 0 ${SVG_SIZE} ${SVG_SIZE}`);
   while (svg.firstChild) svg.removeChild(svg.firstChild);
   metricsEl.textContent = '';
   layerListEl.textContent = '';
 
   const styles = getComputedStyle(document.documentElement);
   const accentRgb = parseCssColor(cssVar(styles, '--accent', FALLBACK_HEX.accent), FALLBACK_COLORS.accent);
   const accentLightRgb = parseCssColor(cssVar(styles, '--accent-light', FALLBACK_HEX.accentLight), FALLBACK_COLORS.accentLight);
   const ink500Rgb = parseCssColor(cssVar(styles, '--ink-500', FALLBACK_HEX.ink500), FALLBACK_COLORS.ink500);
   const ink700Rgb = parseCssColor(cssVar(styles, '--ink-700', FALLBACK_HEX.ink700), FALLBACK_COLORS.ink700);
   const ink900Rgb = parseCssColor(cssVar(styles, '--ink-900', FALLBACK_HEX.ink900), FALLBACK_COLORS.ink900);
   const paperRgb = parseCssColor(cssVar(styles, '--paper', FALLBACK_HEX.paper), FALLBACK_COLORS.paper);
 
   const uniqueLayers = [];
   const seen = new Set();
   for (const row of rows) {
     if (seen.has(row.layer_no)) continue;
     seen.add(row.layer_no);
     uniqueLayers.push({ layer_no: row.layer_no, outer_dia_in: row.layer_dia_in });
   }
   uniqueLayers.sort((a, b) => a.layer_no - b.layer_no);
 
-  const maxRadiusIn = (full_drum_dia_in || 0) / 2;
-  const scale = maxRadiusIn > 0 ? (SVG_SIZE / 2 - SVG_MARGIN) / maxRadiusIn : 1;
+  const maxRadiusIn = Math.max(0, (full_drum_dia_in || 0) / 2);
+  const halfWidthIn = Math.max(0, (flange_to_flange_in || 0) / 2);
+  const maxExtentHalfIn = Math.max(maxRadiusIn, halfWidthIn);
+  const scale = maxExtentHalfIn > 0 ? (SVG_SIZE / 2 - SVG_MARGIN) / maxExtentHalfIn : 1;
   const center = SVG_SIZE / 2;
   const maxRadiusPx = Math.max(0, maxRadiusIn * scale);
+  const halfWidthPx = Math.max(0, halfWidthIn * scale);
+  const axisHorizontalExtent = Math.max(maxRadiusPx, halfWidthPx);
+  const axisVerticalExtent = maxRadiusPx;
 
   const axisEls = [];
-  if (maxRadiusPx > 0) {
-    const outerFill = mixRgb(accentLightRgb, paperRgb, 0.25);
-    svg.appendChild(svgEl('circle', {
-      cx: center,
-      cy: center,
-      r: maxRadiusPx.toFixed(2),
-      fill: rgbToCss(outerFill, 0.9),
-      stroke: rgbToCss(accentRgb, 0.4),
-      'stroke-width': 2
-    }));
+  if (maxRadiusPx > 0 || halfWidthPx > 0) {
+    if (maxRadiusPx > 0) {
+      const outerFill = mixRgb(accentLightRgb, paperRgb, 0.25);
+      svg.appendChild(svgEl('circle', {
+        cx: center,
+        cy: center,
+        r: maxRadiusPx.toFixed(2),
+        fill: rgbToCss(outerFill, 0.9),
+        stroke: rgbToCss(accentRgb, 0.4),
+        'stroke-width': 2
+      }));
+    }
 
     const axisColor = rgbToCss(ink700Rgb, 0.18);
     axisEls.push(svgEl('line', {
-      x1: (center - maxRadiusPx).toFixed(2),
+      x1: (center - axisHorizontalExtent).toFixed(2),
       y1: center.toFixed(2),
-      x2: (center + maxRadiusPx).toFixed(2),
+      x2: (center + axisHorizontalExtent).toFixed(2),
       y2: center.toFixed(2),
       stroke: axisColor,
       'stroke-width': 1,
       'stroke-dasharray': '6 6'
     }));
     axisEls.push(svgEl('line', {
       x1: center.toFixed(2),
-      y1: (center - maxRadiusPx).toFixed(2),
+      y1: (center - axisVerticalExtent).toFixed(2),
       x2: center.toFixed(2),
-      y2: (center + maxRadiusPx).toFixed(2),
+      y2: (center + axisVerticalExtent).toFixed(2),
       stroke: axisColor,
       'stroke-width': 1,
       'stroke-dasharray': '6 6'
     }));
   }
 
   const coreRadius = Math.max(0, (core_dia_in || 0) / 2 * scale);
   const lebusOuterRadius = Math.max(0, (core_dia_in + 2 * (lebus_thk_in || 0)) / 2 * scale);
+  const coreHeightPx = coreRadius * 2;
+  const coreWidthPx = Math.max(0, (flange_to_flange_in || 0) * scale);
 
   const layerVisuals = uniqueLayers.map((layer, idx) => {
     const t = uniqueLayers.length > 1 ? idx / (uniqueLayers.length - 1) : 0;
     const baseColor = mixRgb(accentRgb, accentLightRgb, 0.25 + 0.55 * t);
     const fillColor = mixRgb(baseColor, paperRgb, 0.55);
     const outerRadius = Math.max(0, (layer.outer_dia_in || 0) / 2 * scale);
     return {
       layer_no: layer.layer_no,
       outerRadius,
       fillColor: rgbToCss(fillColor, 0.82),
       strokeColor: rgbToCss(baseColor, 0.94)
     };
   });
 
   // Filled discs from outermost to innermost to emulate rings.
   layerVisuals
     .slice()
     .sort((a, b) => b.outerRadius - a.outerRadius)
     .forEach(layer => {
       svg.appendChild(svgEl('circle', {
         cx: center,
         cy: center,
         r: layer.outerRadius.toFixed(2),
         fill: layer.fillColor,
         stroke: 'none'
@@ -257,55 +266,56 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
       r: Math.max(0, layer.outerRadius).toFixed(2),
       fill: 'none',
       stroke: layer.strokeColor,
       'stroke-width': 1.6
     }));
   });
 
   // Lebus liner (dashed ring) if thickness exists.
   if (lebusOuterRadius > coreRadius + 0.5) {
     const inner = coreRadius;
     const outer = lebusOuterRadius;
     const mid = (inner + outer) / 2;
     const strokeWidth = Math.max(outer - inner, 0.8);
     svg.appendChild(svgEl('circle', {
       cx: center,
       cy: center,
       r: mid.toFixed(2),
       fill: 'none',
       stroke: rgbToCss(ink500Rgb, 0.55),
       'stroke-width': strokeWidth.toFixed(2),
       'stroke-dasharray': '10 6'
     }));
   }
 
   // Core fill.
-  if (coreRadius > 0) {
-    svg.appendChild(svgEl('circle', {
-      cx: center,
-      cy: center,
-      r: coreRadius.toFixed(2),
+  if (coreRadius > 0 && coreWidthPx > 0) {
+    svg.appendChild(svgEl('rect', {
+      x: (center - coreWidthPx / 2).toFixed(2),
+      y: (center - coreHeightPx / 2).toFixed(2),
+      width: coreWidthPx.toFixed(2),
+      height: coreHeightPx.toFixed(2),
       fill: rgbToCss(ink900Rgb, 0.5),
       stroke: rgbToCss(ink900Rgb, 0.7),
       'stroke-width': 1
     }));
   }
 
   // Metrics grid
   const cableLenDigits = cable_len_m >= 1000 ? 0 : cable_len_m >= 10 ? 1 : 2;
   const cableDiaDigits = cable_dia_mm >= 50 ? 0 : cable_dia_mm >= 10 ? 1 : 2;
   const metrics = [
     ['Cable on drum', `${fmt(cable_len_m, cableLenDigits)} m`],
     ['Cable Ø', `${fmt(cable_dia_mm, cableDiaDigits)} mm`],
     ['Layers', fmt(total_layers, 0)],
     ['Total wraps', fmt(total_wraps, 0)],
     ['Wraps / layer', meta && Number.isFinite(meta.wraps_per_layer_used) ? fmt(meta.wraps_per_layer_used, 1) : '–'],
     ['Full drum Ø', `${fmt(full_drum_dia_in, 2)} in`],
     ['Core Ø', `${fmt(core_dia_in, 2)} in`],
     ['Lebus liner', `${fmt(lebus_thk_in, 3)} in`],
     ['Flange-to-flange', `${fmt(flange_to_flange_in, 2)} in`]
   ];
 
   for (const [label, value] of metrics) {
     metricsEl.appendChild(createMetric(label, value));
   }
 
