diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index 05655ef08d1d45c2f5b9fdb5e7b1646d815b7ca6..1cd653d3542ff849f43b117950eb043caf31f1e3 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -193,60 +193,68 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
   const centerY = SVG_MARGIN + heightPx / 2;
 
   const coreHeightPx = Math.max(0, (core_dia_in || 0) * scale);
   const coreWidthPx = Math.max(0, (flange_to_flange_in || 0) * scale);
   const flangeDiaIn = Math.max(0, flange_dia_in || 0);
   const flangeHeightPx = flangeDiaIn * scale;
   const flangeWidthPx = flangeDiaIn * 0.01 * scale;
 
   const strokeWidth = 0.85;
   const strokeWidthAttr = strokeWidth.toFixed(3);
 
   if (coreHeightPx > 0 && coreWidthPx > 0) {
     svg.appendChild(svgEl('rect', {
       x: spoolLeft.toFixed(2),
       y: (centerY - coreHeightPx / 2).toFixed(2),
       width: coreWidthPx.toFixed(2),
       height: coreHeightPx.toFixed(2),
       fill: 'none',
       stroke: rgbToCss(ink900Rgb, 0.72),
       'stroke-width': strokeWidthAttr,
       'vector-effect': 'non-scaling-stroke'
     }));
   }
 
   if (flangeHeightPx > 0 && flangeWidthPx > 0) {
-    const centerX = spoolLeft + widthPx / 2;
-    svg.appendChild(svgEl('rect', {
-      x: (centerX - flangeWidthPx / 2).toFixed(2),
+    const flangeRectAttrs = {
       y: (centerY - flangeHeightPx / 2).toFixed(2),
       width: flangeWidthPx.toFixed(2),
       height: flangeHeightPx.toFixed(2),
       fill: rgbToCss(accentRgb, 0.12),
       stroke: rgbToCss(accentRgb, 0.5),
       'stroke-width': strokeWidthAttr,
       'vector-effect': 'non-scaling-stroke'
+    };
+
+    svg.appendChild(svgEl('rect', {
+      ...flangeRectAttrs,
+      x: (spoolLeft - flangeWidthPx).toFixed(2)
+    }));
+
+    svg.appendChild(svgEl('rect', {
+      ...flangeRectAttrs,
+      x: spoolRight.toFixed(2)
     }));
   }
 
   const axisColor = rgbToCss(ink700Rgb, 0.18);
   svg.appendChild(svgEl('line', {
     x1: spoolLeft.toFixed(2),
     y1: centerY.toFixed(2),
     x2: spoolRight.toFixed(2),
     y2: centerY.toFixed(2),
     stroke: axisColor,
     'stroke-width': strokeWidthAttr,
     'vector-effect': 'non-scaling-stroke',
     'stroke-dasharray': '6 6'
   }));
 
   const cableRadiusPx = cable_dia_in > 0 ? (cable_dia_in / 2) * scale : 0;
   const cablePitchPx = cable_dia_in > 0 ? cable_dia_in * scale : 0;
 
   const wrapsByLayer = new Map();
   for (const row of rows) {
     wrapsByLayer.set(row.layer_no, (wrapsByLayer.get(row.layer_no) || 0) + 1);
   }
 
   if (cableRadiusPx > 0 && cablePitchPx > 0 && coreWidthPx > 0) {
     layersForViz.forEach(layer => {
