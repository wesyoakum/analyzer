diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index a54e4c3c2acd09f9941a2e2b0359f667332b5c8d..4af651eb21138f955d7b0101bb6ed4178f8aca2b 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -1,31 +1,31 @@
 // ===== plots/depth-profiles.mjs  Speed vs Depth & Tension vs Depth (DOM-agnostic) =====
 import { niceTicks, svgEl, TENSION_SAFETY_FACTOR } from '../utils.mjs';
 
 const LIGHT_CANDIDATE_COLOR = '#b9c3d8';
 const EXCEED_COLOR = '#c65353';
-const THEORETICAL_COLOR = '#7c8fc5';
+const TENSION_OK_COLOR = '#1b5e20';
 
 function getAccentColor() {
   if (typeof window !== 'undefined' && typeof document !== 'undefined' && window.getComputedStyle) {
     const val = window.getComputedStyle(document.documentElement).getPropertyValue('--accent');
     if (val) return val.trim();
   }
   return '#2c56a3';
 }
 
 /**
  * Draw both depth profile plots (speed & tension).
  *
  * @param {SVGSVGElement} svgSpeed
  * @param {SVGSVGElement} svgTension
  * @param {Object} opts
  * @param {'electric'|'hydraulic'} opts.scenario
  * @param {Array<Object>} opts.elWraps
  * @param {Array<Object>} opts.hyWraps
  * @param {number} opts.payload_kg
  * @param {number} opts.cable_w_kgpm
  * @param {number} [opts.dead_end_m=0]
  */
 export function drawDepthProfiles(svgSpeed, svgTension, {
   scenario = 'electric',
   elWraps = [],
@@ -210,58 +210,58 @@ function drawTensionProfile(svg, segments, maxDepth, maxTension, payload_kg, cab
     }));
   });
 
   const drawPieces = (pieces, { strokeWidth = 2, dash = null } = {}) => {
     pieces.forEach(seg => {
       const d0 = Math.max(0, Math.min(seg.d0, maxDepth));
       const d1 = Math.max(0, Math.min(seg.d1, maxDepth));
       if (Math.abs(d1 - d0) < 1e-6) return;
       const pts = [
         [sx(d0), sy(seg.T0)],
         [sx(d1), sy(seg.T1)]
       ];
       const attrs = {
         d: pathFrom(pts),
         fill: 'none',
         stroke: seg.color,
         'stroke-width': strokeWidth
       };
       if (dash) attrs['stroke-dasharray'] = dash;
       svg.appendChild(svgEl('path', attrs));
     });
   };
 
   const theoreticalPieces = buildTensionSegments(normalizedSegments, payload_kg, cable_w_kgpm, maxDepth, {
     factor: 1,
-    colorBelow: THEORETICAL_COLOR,
-    colorAbove: THEORETICAL_COLOR
+    colorBelow: TENSION_OK_COLOR,
+    colorAbove: EXCEED_COLOR
   });
   drawPieces(theoreticalPieces, { strokeWidth: 2, dash: '6 4' });
 
   const requiredPieces = buildTensionSegments(normalizedSegments, payload_kg, cable_w_kgpm, maxDepth, {
     factor: TENSION_SAFETY_FACTOR,
-    colorBelow: accentColor,
+    colorBelow: TENSION_OK_COLOR,
     colorAbove: EXCEED_COLOR
   });
   drawPieces(requiredPieces, { strokeWidth: 2.4 });
 
   svg.appendChild(svgEl('line', { x1: ML, y1: sy(0), x2: W - MR, y2: sy(0), stroke: '#bbb', 'stroke-dasharray': '4 4' }));
 
   function pathFrom(pts) {
     if (!pts.length) return '';
     let d = `M ${pts[0][0]} ${pts[0][1]}`;
     for (let i = 1; i < pts.length; i++) d += ` L ${pts[i][0]} ${pts[i][1]}`;
     return d;
   }
 }
 
 function buildTensionSegments(segments, payload_kg, cable_w_kgpm, maxDepth, {
   factor = 1,
   colorBelow,
   colorAbove
 } = {}) {
   const boundaries = new Set([0, maxDepth]);
   segments.forEach(S => {
     boundaries.add(Math.max(0, S.depth_end));
     boundaries.add(Math.max(0, S.depth_start));
   });
   const sorted = [...boundaries].sort((a, b) => a - b);
