diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index a54e4c3c2acd09f9941a2e2b0359f667332b5c8d..e85148a3e52412571f55c9fe17c39c7e4360bc07 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -1,29 +1,30 @@
 // ===== plots/depth-profiles.mjs  Speed vs Depth & Tension vs Depth (DOM-agnostic) =====
 import { niceTicks, svgEl, TENSION_SAFETY_FACTOR } from '../utils.mjs';
 
-const LIGHT_CANDIDATE_COLOR = '#b9c3d8';
+const CANDIDATE_POWER_COLOR = '#b7e4c7';
+const CANDIDATE_FLOW_COLOR = '#d8b4fe';
 const EXCEED_COLOR = '#c65353';
 const THEORETICAL_COLOR = '#7c8fc5';
 
 function getAccentColor() {
   if (typeof window !== 'undefined' && typeof document !== 'undefined' && window.getComputedStyle) {
     const val = window.getComputedStyle(document.documentElement).getPropertyValue('--accent');
     if (val) return val.trim();
   }
   return '#2c56a3';
 }
 
 /**
  * Draw both depth profile plots (speed & tension).
  *
  * @param {SVGSVGElement} svgSpeed
  * @param {SVGSVGElement} svgTension
  * @param {Object} opts
  * @param {'electric'|'hydraulic'} opts.scenario
  * @param {Array<Object>} opts.elWraps
  * @param {Array<Object>} opts.hyWraps
  * @param {number} opts.payload_kg
  * @param {number} opts.cable_w_kgpm
  * @param {number} [opts.dead_end_m=0]
  */
 export function drawDepthProfiles(svgSpeed, svgTension, {
@@ -82,90 +83,91 @@ function drawSpeedProfile(svg, segments, maxDepth, maxSpeed, accentColor) {
   svg.appendChild(svgEl('rect', { x: ML, y: MT, width: innerW, height: innerH, fill: '#fff', stroke: '#ccc' }));
 
   // grid/ticks
   niceTicks(0, maxDepth, 8).ticks.forEach(dx => {
     const X = sx(dx);
     svg.appendChild(svgEl('line', { x1: X, y1: MT, x2: X, y2: H - MB, stroke: '#eee' }));
     const t = svgEl('text', { x: X, y: H - 8, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' });
     t.textContent = String(Math.round(dx));
     svg.appendChild(t);
   });
   niceTicks(0, maxSpeed, 6).ticks.forEach(v => {
     const Y = sy(v);
     svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#eee' }));
     const t = svgEl('text', { x: ML - 6, y: Y + 4, 'text-anchor': 'end', 'font-size': '12', fill: '#444' });
     t.textContent = String(Math.round(v * 100) / 100);
     svg.appendChild(t);
   });
 
   svg.appendChild(svgEl('text', { x: ML + innerW / 2, y: H - 4, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' }))
      .textContent = 'Depth (m)';
   svg.appendChild(svgEl('text', {
     x: 18, y: MT + innerH / 2, transform: `rotate(-90,18,${MT + innerH / 2})`,
     'text-anchor': 'middle', 'font-size': '12', fill: '#444'
   })).textContent = 'Speed (m/s)';
 
-  // candidate speeds (light gray, dashed)
+  // available speed (accent)
+  segments.forEach(S => {
+    if (!Number.isFinite(S.speed_ms)) return;
+    const y = sy(S.speed_ms);
+    const depthEnd = Math.min(S.depth_start, S.depth_end);
+    const depthStart = Math.max(S.depth_start, S.depth_end);
+    const x0 = sx(depthEnd);
+    const x1 = sx(depthStart);
+    svg.appendChild(svgEl('line', {
+      x1: x0,
+      y1: y,
+      x2: x1,
+      y2: y,
+      stroke: accentColor,
+      'stroke-width': 4.8
+    }));
+  });
+
+  // candidate speeds (Vp light green, Vq light purple, dashed)
   segments.forEach(S => {
     if (!Array.isArray(S.candidate_speeds_ms)) return;
     const depthEnd = Math.min(S.depth_start, S.depth_end);
     const depthStart = Math.max(S.depth_start, S.depth_end);
-    S.candidate_speeds_ms.forEach(val => {
+    S.candidate_speeds_ms.forEach((val, idx) => {
       if (!Number.isFinite(val)) return;
       const y = sy(val);
       const x0 = sx(depthEnd);
       const x1 = sx(depthStart);
+      const stroke = (idx === 0) ? CANDIDATE_POWER_COLOR : CANDIDATE_FLOW_COLOR;
       svg.appendChild(svgEl('line', {
         x1: x0,
         y1: y,
         x2: x1,
         y2: y,
-        stroke: LIGHT_CANDIDATE_COLOR,
+        stroke,
         'stroke-width': 2,
         'stroke-dasharray': '5 4'
       }));
     });
   });
 
-  // available speed (accent)
-  segments.forEach(S => {
-    if (!Number.isFinite(S.speed_ms)) return;
-    const y = sy(S.speed_ms);
-    const depthEnd = Math.min(S.depth_start, S.depth_end);
-    const depthStart = Math.max(S.depth_start, S.depth_end);
-    const x0 = sx(depthEnd);
-    const x1 = sx(depthStart);
-    svg.appendChild(svgEl('line', {
-      x1: x0,
-      y1: y,
-      x2: x1,
-      y2: y,
-      stroke: accentColor,
-      'stroke-width': 2.4
-    }));
-  });
-
   // zero line
   svg.appendChild(svgEl('line', { x1: ML, y1: sy(0), x2: W - MR, y2: sy(0), stroke: '#bbb', 'stroke-dasharray': '4 4' }));
 }
 
 // ---------- Tension vs Depth ----------
 function drawTensionProfile(svg, segments, maxDepth, maxTension, payload_kg, cable_w_kgpm, accentColor) {
   while (svg.firstChild) svg.removeChild(svg.firstChild);
 
   const ML = 64, MR = 18, MT = 18, MB = 46;
   const W = svg.viewBox.baseVal.width || svg.clientWidth || 1000;
   const H = svg.viewBox.baseVal.height || svg.clientHeight || 540;
   const innerW = W - ML - MR, innerH = H - MT - MB;
 
   const sx = d => ML + (d / Math.max(1e-9, maxDepth)) * innerW;        // X depth
   const sy = T => MT + (1 - T / Math.max(1e-9, maxTension)) * innerH;  // Y tension
 
   svg.appendChild(svgEl('rect', { x: ML, y: MT, width: innerW, height: innerH, fill: '#fff', stroke: '#ccc' }));
 
   // grid/ticks
   niceTicks(0, maxDepth, 8).ticks.forEach(dx => {
     const X = sx(dx);
     svg.appendChild(svgEl('line', { x1: X, y1: MT, x2: X, y2: H - MB, stroke: '#eee' }));
     const t = svgEl('text', { x: X, y: H - 8, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' });
     t.textContent = String(Math.round(dx));
     svg.appendChild(t);
