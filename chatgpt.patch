diff --git a/src/js/drum-visual.mjs b/src/js/drum-visual.mjs
index 2e8782648b4ecf4fb9d34a3a0ce9bef19a80c289..ee052eb502039e079c970cc1837da8285e551093 100644
--- a/src/js/drum-visual.mjs
+++ b/src/js/drum-visual.mjs
@@ -73,118 +73,83 @@ function cssVar(styles, name, fallbackHex) {
   return value && value.trim() ? value.trim() : fallbackHex;
 }
 
 function mixRgb(a, b, t) {
   const k = Math.max(0, Math.min(1, t));
   return {
     r: clamp255(a.r + (b.r - a.r) * k),
     g: clamp255(a.g + (b.g - a.g) * k),
     b: clamp255(a.b + (b.b - a.b) * k)
   };
 }
 
 function rgbToCss(rgb, alpha = 1) {
   const a = typeof alpha === 'number' ? Math.max(0, Math.min(1, alpha)) : 1;
   if (a < 1) {
     return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a.toFixed(3)})`;
   }
   return `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
 }
 
 function fmt(value, digits = 0) {
   if (!Number.isFinite(value)) return '–';
   return value.toLocaleString('en-US', { maximumFractionDigits: digits });
 }
 
-function emptyState(summaryEl, metricsEl, layersEl, titleEl, svg) {
+function emptyState(summaryEl, titleEl, svg) {
   if (titleEl) titleEl.textContent = 'Winch drum cross-section (awaiting inputs)';
   if (svg) svg.setAttribute('aria-label', 'Winch drum cross-section awaiting inputs');
   if (summaryEl) summaryEl.textContent = 'Enter drum and cable inputs to view the drum visualization.';
-  if (metricsEl) metricsEl.textContent = '';
-  if (layersEl) layersEl.textContent = '';
   if (svg) {
     while (svg.firstChild) svg.removeChild(svg.firstChild);
   }
 }
 
-function createMetric(label, value) {
-  const wrap = document.createElement('div');
-  wrap.className = 'metric';
-  const lab = document.createElement('div');
-  lab.className = 'metric__label';
-  lab.textContent = label;
-  const val = document.createElement('div');
-  val.className = 'metric__value';
-  val.textContent = value;
-  wrap.append(lab, val);
-  return wrap;
-}
-
-function createLayerItem(color, label, value) {
-  const li = document.createElement('li');
-  li.className = 'drum-layer-list__item';
-  const swatch = document.createElement('span');
-  swatch.className = 'drum-layer-list__swatch';
-  swatch.style.backgroundColor = color;
-  const labelEl = document.createElement('span');
-  labelEl.className = 'drum-layer-list__label';
-  labelEl.textContent = label;
-  const valueEl = document.createElement('span');
-  valueEl.className = 'drum-layer-list__value';
-  valueEl.textContent = value;
-  li.append(swatch, labelEl, valueEl);
-  return li;
-}
-
 export function renderDrumVisualization(rows, summary, cfg, meta) {
   const svg = /** @type {SVGSVGElement|null} */ (document.getElementById('drum_visual_svg'));
   const summaryEl = /** @type {HTMLParagraphElement|null} */ (document.getElementById('drum_summary'));
-  const metricsEl = /** @type {HTMLDivElement|null} */ (document.getElementById('drum_metrics'));
-  const layerListEl = /** @type {HTMLOListElement|null} */ (document.getElementById('drum_layer_list'));
   const titleEl = /** @type {SVGTitleElement|null} */ (document.getElementById('drum_visual_title'));
 
-  if (!svg || !summaryEl || !metricsEl || !layerListEl || !titleEl) return;
+  if (!svg || !summaryEl || !titleEl) return;
 
   if (!rows || !rows.length || !summary || !cfg) {
-    emptyState(summaryEl, metricsEl, layerListEl, titleEl, svg);
+    emptyState(summaryEl, titleEl, svg);
     return;
   }
 
   const { total_layers, total_wraps, cable_len_m, full_drum_dia_in } = summary;
   const {
     cable_dia_mm,
     core_dia_in,
     flange_to_flange_in,
     lebus_thk_in
   } = cfg;
 
   const cable_dia_in = Math.max(0, (cable_dia_mm || 0) * IN_PER_MM);
 
   svg.setAttribute('viewBox', `0 0 ${SVG_SIZE} ${SVG_SIZE}`);
   while (svg.firstChild) svg.removeChild(svg.firstChild);
-  metricsEl.textContent = '';
-  layerListEl.textContent = '';
 
   const styles = getComputedStyle(document.documentElement);
   const accentRgb = parseCssColor(cssVar(styles, '--accent', FALLBACK_HEX.accent), FALLBACK_COLORS.accent);
   const accentLightRgb = parseCssColor(cssVar(styles, '--accent-light', FALLBACK_HEX.accentLight), FALLBACK_COLORS.accentLight);
   const ink500Rgb = parseCssColor(cssVar(styles, '--ink-500', FALLBACK_HEX.ink500), FALLBACK_COLORS.ink500);
   const ink700Rgb = parseCssColor(cssVar(styles, '--ink-700', FALLBACK_HEX.ink700), FALLBACK_COLORS.ink700);
   const ink900Rgb = parseCssColor(cssVar(styles, '--ink-900', FALLBACK_HEX.ink900), FALLBACK_COLORS.ink900);
   const paperRgb = parseCssColor(cssVar(styles, '--paper', FALLBACK_HEX.paper), FALLBACK_COLORS.paper);
 
   const uniqueLayers = [];
   const seen = new Set();
   for (const row of rows) {
     if (seen.has(row.layer_no)) continue;
     seen.add(row.layer_no);
     uniqueLayers.push({ layer_no: row.layer_no, outer_dia_in: row.layer_dia_in });
   }
   
   const derivedOuterRadiusIn = Math.max(0, (core_dia_in || 0) / 2 + (lebus_thk_in || 0) + cable_dia_in * uniqueLayers.length);
   const maxRadiusIn = Math.max(0, Math.max((full_drum_dia_in || 0) / 2, derivedOuterRadiusIn));
   const halfWidthIn = Math.max(0, (flange_to_flange_in || 0) / 2);
   const maxExtentHalfIn = Math.max(maxRadiusIn, halfWidthIn);
   const scale = maxExtentHalfIn > 0 ? (SVG_SIZE / 2 - SVG_MARGIN) / maxExtentHalfIn : 1;
   const center = SVG_SIZE / 2;
   const maxRadiusPx = Math.max(0, maxRadiusIn * scale);
   const halfWidthPx = Math.max(0, halfWidthIn * scale);
@@ -285,83 +250,56 @@ export function renderDrumVisualization(rows, summary, cfg, meta) {
         svg.appendChild(svgEl('circle', {
           cx: cx.toFixed(2),
           cy: bottomY.toFixed(2),
           r: cableRadiusPx.toFixed(2),
           fill: style.fillColor,
           stroke: style.strokeColor,
           'stroke-width': 1.4
         }));
       }
     });
   }
 
   // Core fill.
   if (coreRadius > 0 && coreWidthPx > 0) {
     svg.appendChild(svgEl('rect', {
       x: (center - coreWidthPx / 2).toFixed(2),
       y: (center - coreHeightPx / 2).toFixed(2),
       width: coreWidthPx.toFixed(2),
       height: coreHeightPx.toFixed(2),
       fill: rgbToCss(ink900Rgb, 0.5),
       stroke: rgbToCss(ink900Rgb, 0.7),
       'stroke-width': 1
     }));
   }
 
-  // Metrics grid
+  // Summary & accessibility copy
   const cableLenDigits = cable_len_m >= 1000 ? 0 : cable_len_m >= 10 ? 1 : 2;
   const cableDiaDigits = cable_dia_mm >= 50 ? 0 : cable_dia_mm >= 10 ? 1 : 2;
-  const metrics = [
-    ['Cable on drum', `${fmt(cable_len_m, cableLenDigits)} m`],
-    ['Cable Ø', `${fmt(cable_dia_mm, cableDiaDigits)} mm`],
-    ['Layers', fmt(total_layers, 0)],
-    ['Total wraps', fmt(total_wraps, 0)],
-    ['Wraps / layer', meta && Number.isFinite(meta.wraps_per_layer_used) ? fmt(meta.wraps_per_layer_used, 1) : '–'],
-    ['Full drum Ø', `${fmt(full_drum_dia_in, 2)} in`],
-    ['Core Ø', `${fmt(core_dia_in, 2)} in`],
-    ['Lebus liner', `${fmt(lebus_thk_in, 3)} in`],
-    ['Flange-to-flange', `${fmt(flange_to_flange_in, 2)} in`]
-  ];
-
-  for (const [label, value] of metrics) {
-    metricsEl.appendChild(createMetric(label, value));
-  }
-
-  // Wraps per layer list
-  uniqueLayers.forEach((layer, idx) => {
-    const wraps = wrapsByLayer.get(layer.layer_no) || 0;
-    const style = layerStyles[idx];
-    const label = `Layer ${layer.layer_no}`;
-    const value = `${fmt(wraps, 0)} ${wraps === 1 ? 'wrap' : 'wraps'}`;
-    const li = createLayerItem(style.strokeColor, label, value);
-    const outerDiaIn = layer.outer_dia_in || 0;
-    li.title = `Layer ${layer.layer_no}: outer diameter ${fmt(outerDiaIn, 2)} in`;
-    layerListEl.appendChild(li);
-  });
-
-  // Summary & accessibility copy
   const layerWord = total_layers === 1 ? 'layer' : 'layers';
   const wrapWord = total_wraps === 1 ? 'wrap' : 'wraps';
   const summaryLine = `${fmt(cable_len_m, cableLenDigits)} m of ${fmt(cable_dia_mm, cableDiaDigits)} mm cable on ${fmt(total_layers, 0)} ${layerWord} with ${fmt(total_wraps, 0)} total ${wrapWord}`;
+  const wrapsPerLayer = meta && Number.isFinite(meta.wraps_per_layer_used)
+    ? ` (≈${fmt(meta.wraps_per_layer_used, 1)} wraps per layer)`
+    : '';
   const geometryParts = [
     `core Ø ${fmt(core_dia_in, 2)} in`,
     `flange-to-flange ${fmt(flange_to_flange_in, 2)} in`,
     `Lebus liner ${fmt(lebus_thk_in, 3)} in`,
     `full drum Ø ${fmt(full_drum_dia_in, 2)} in`
   ];
-  const summaryPlain = `${summaryLine}. Drum geometry: ${geometryParts.join(', ')}.`;
+  const geometryLine = `Drum geometry: ${geometryParts.join(', ')}.`;
+  const summaryPlain = `${summaryLine}${wrapsPerLayer}. ${geometryLine}`;
 
-  summaryEl.innerHTML = `<strong>${summaryLine}.</strong> Drum geometry: ${geometryParts.join(', ')}.`;
+  summaryEl.innerHTML = `<strong>${summaryLine}${wrapsPerLayer}.</strong> ${geometryLine}`;
   titleEl.textContent = `Winch drum cross-section with ${fmt(total_layers, 0)} ${layerWord}`;
   svg.setAttribute('aria-label', summaryPlain);
 }
 
 export function clearDrumVisualization() {
   const svg = /** @type {SVGSVGElement|null} */ (document.getElementById('drum_visual_svg'));
   const summaryEl = /** @type {HTMLParagraphElement|null} */ (document.getElementById('drum_summary'));
-  const metricsEl = /** @type {HTMLDivElement|null} */ (document.getElementById('drum_metrics'));
-  const layerListEl = /** @type {HTMLOListElement|null} */ (document.getElementById('drum_layer_list'));
   const titleEl = /** @type {SVGTitleElement|null} */ (document.getElementById('drum_visual_title'));
-  if (svg && summaryEl && metricsEl && layerListEl && titleEl) {
-    emptyState(summaryEl, metricsEl, layerListEl, titleEl, svg);
+  if (svg && summaryEl && titleEl) {
+    emptyState(summaryEl, titleEl, svg);
   }
 }
\ No newline at end of file
