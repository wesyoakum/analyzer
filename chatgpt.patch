diff --git a/src/js/component-selectors.mjs b/src/js/component-selectors.mjs
index 26fed08f9a55ebef7534ee7d2bc6cccf87e937c7..2c204b8dd28af4bbe7f6e8c1b92d71c3f7b090dd 100644
--- a/src/js/component-selectors.mjs
+++ b/src/js/component-selectors.mjs
@@ -994,89 +994,157 @@ function populateSelectOptions(selectEl, config, { selectedValue } = {}) {
   manualOpt.value = '';
   manualOpt.textContent = 'Custom (manual input)';
   selectEl.appendChild(manualOpt);
 
   allOptions(config).forEach(option => {
     const opt = document.createElement('option');
     opt.value = option.pn;
     opt.textContent = describeOption(config, option);
     selectEl.appendChild(opt);
   });
 
   const createOpt = document.createElement('option');
   createOpt.value = CREATE_NEW_VALUE;
   createOpt.textContent = 'Create New';
   selectEl.appendChild(createOpt);
 
   if (prior && prior !== CREATE_NEW_VALUE && findOption(config, prior)) {
     selectEl.value = prior;
   } else if (prior === '') {
     selectEl.value = '';
   } else {
     selectEl.value = '';
   }
 }
 
-function handleCreateNew(config, selectEl) {
+async function handleCreateNew(config, selectEl) {
   const label = config.label || 'component';
   const pnInput = window.prompt(`Enter a part number for the new ${label} preset:`);
   if (pnInput == null) {
     return null;
   }
   const pn = pnInput.trim();
   if (!pn) {
     window.alert('A part number is required to create a preset.');
     return null;
   }
 
   const existing = allOptions(config).find(opt => opt.pn.toLowerCase() === pn.toLowerCase());
   if (existing) {
     window.alert(`A preset with part number "${pn}" already exists.`);
     return null;
   }
 
   const descriptionInput = window.prompt(`Enter a description for ${pn}:`);
   const description = descriptionInput == null ? '' : descriptionInput.trim();
 
   const values = collectValuesForConfig(config);
-  /** @type {ComponentOption} */
-  const option = {
-    pn,
+  const metadata = { pn };
+  if (config.type) {
+    metadata.type = config.type;
+  }
+  if (config.label) {
+    metadata.label = config.label;
+  }
+
+  const payload = {
     name: pn,
-    ...values
+    ...(description ? { description } : {}),
+    data: values,
+    metadata
   };
-  if (description) {
-    option.description = description;
-  }
 
-  if (!Array.isArray(config.customOptions)) {
-    config.customOptions = [];
+  const wasDisabled = selectEl.disabled;
+  selectEl.disabled = true;
+  try {
+    const response = await fetch('/api/presets', {
+      method: 'POST',
+      headers: {
+        'Content-Type': 'application/json'
+      },
+      body: JSON.stringify(payload)
+    });
+
+    if (!response.ok) {
+      let message = `Failed to create ${label} preset.`;
+      try {
+        const errorBody = await response.json();
+        if (errorBody?.error?.message) {
+          message = errorBody.error.message;
+          if (Array.isArray(errorBody.error.details) && errorBody.error.details.length) {
+            message = `${message}\n- ${errorBody.error.details.join('\n- ')}`;
+          }
+        }
+      } catch (err) {
+        // Ignore JSON parsing errors; fall back to generic message.
+      }
+      window.alert(message);
+      return null;
+    }
+
+    let body;
+    try {
+      body = await response.json();
+    } catch (err) {
+      window.alert('Failed to parse server response when creating preset.');
+      return null;
+    }
+
+    const preset = body?.preset;
+    if (!preset || typeof preset.id !== 'string') {
+      window.alert('Server response did not include the created preset.');
+      return null;
+    }
+
+    const presetData =
+      preset && typeof preset.data === 'object' && preset.data !== null && !Array.isArray(preset.data)
+        ? preset.data
+        : values;
+
+    /** @type {ComponentOption} */
+    const option = {
+      pn,
+      name: preset.name ?? pn,
+      ...(preset.description ? { description: preset.description } : {}),
+      ...presetData,
+      id: preset.id
+    };
+
+    if (!Array.isArray(config.customOptions)) {
+      config.customOptions = [];
+    }
+    config.customOptions.push(option);
+    saveCustomOptions(config.type, config.customOptions);
+    populateSelectOptions(selectEl, config, { selectedValue: pn });
+    return pn;
+  } catch (err) {
+    const message = err instanceof Error ? err.message : String(err);
+    window.alert(`Unable to create ${label} preset: ${message}`);
+    return null;
+  } finally {
+    selectEl.disabled = wasDisabled;
   }
-  config.customOptions.push(option);
-  saveCustomOptions(config.type, config.customOptions);
-  populateSelectOptions(selectEl, config, { selectedValue: pn });
-  return pn;
 }
 
 function describeOption(config, option) {
   const parts = [option.name ?? option.pn];
   if (option.description) parts.push(option.description);
   return parts.join(' â€” ');
 }
 
 function attachWatcher(inputId) {
   if (watchedInputs.has(inputId)) return;
   const el = /** @type {HTMLElement|null} */ (document.getElementById(inputId));
   if (!el) return;
   const handler = () => {
     if (el.dataset.componentSuppress === '1') return;
     const selectId = el.dataset.componentSelect;
     if (!selectId) return;
     delete el.dataset.componentSelect;
     delete el.dataset.componentPn;
     const selectEl = /** @type {HTMLSelectElement|null} */ (document.getElementById(selectId));
     if (selectEl && selectEl.value) {
       selectEl.value = '';
       selectEl.dispatchEvent(new Event('change', { bubbles: true }));
     }
   };
   if (el instanceof HTMLInputElement) {
@@ -1146,59 +1214,59 @@ function applySelection(config, pn, { skipEvents = false } = {}) {
     }
     delete inputEl.dataset.componentSuppress;
   });
 }
 
 export function setupComponentSelectors() {
   SELECT_CONFIGS.forEach(config => {
     const selectEl = /** @type {HTMLSelectElement|null} */ (document.getElementById(config.selectId));
     if (!selectEl) return;
     config.customOptions = loadCustomOptions(config.type);
 
     const initialValue = selectEl.value;
     const { initialSkipEvents = true } = config;
 
     populateSelectOptions(selectEl, config, { selectedValue: initialValue });
 
     Object.keys(config.fieldMap).forEach(inputId => attachWatcher(inputId));
 
     let previousValue = selectEl.value && selectEl.value !== CREATE_NEW_VALUE ? selectEl.value : '';
     let suppressNext = false;
 
     const ensureOptionApplied = (value, { skipEvents = false } = {}) => {
       applySelection(config, value, { skipEvents });
     };
 
-    selectEl.addEventListener('change', () => {
+    selectEl.addEventListener('change', async () => {
       if (suppressNext) {
         suppressNext = false;
         previousValue = selectEl.value;
         ensureOptionApplied(selectEl.value);
         return;
       }
 
       const value = selectEl.value;
       if (value === CREATE_NEW_VALUE) {
         selectEl.value = previousValue;
-        const createdPn = handleCreateNew(config, selectEl);
+        const createdPn = await handleCreateNew(config, selectEl);
         if (createdPn) {
           previousValue = createdPn;
           suppressNext = true;
           selectEl.value = createdPn;
           ensureOptionApplied(createdPn);
           selectEl.dispatchEvent(new Event('change', { bubbles: true }));
         } else {
           ensureOptionApplied(previousValue);
         }
         return;
       }
 
       previousValue = value;
       ensureOptionApplied(value);
     });
 
     // Apply persisted selection if present
     if (selectEl.value) {
       ensureOptionApplied(selectEl.value, { skipEvents: initialSkipEvents });
     }
   });
 }
