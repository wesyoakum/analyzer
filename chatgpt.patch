diff --git a/src/js/plots/wave-contours.mjs b/src/js/plots/wave-contours.mjs
index c575954716eeb0802d5d56f8e047682b57a063f5..33be62f10f9c31cd8a13d82ddfae6faa72dfd7bf 100644
--- a/src/js/plots/wave-contours.mjs
+++ b/src/js/plots/wave-contours.mjs
@@ -74,74 +74,88 @@ function renderWavePlot(svg, {
     const X = sx(tx);
     svg.appendChild(svgEl('line', { x1: X, y1: MT, x2: X, y2: H - MB, stroke: '#eee' }));
     const t = svgEl('text', { x: X, y: H - 8, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' });
     t.textContent = (Math.round(tx * 100) / 100).toString();
     svg.appendChild(t);
   });
   yt.forEach(v => {
     const Y = sy(v);
     svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#eee' }));
     const t = svgEl('text', { x: ML - 6, y: Y + 4, 'text-anchor': 'end', 'font-size': '12', fill: '#444' });
     t.textContent = (Math.round(v * 100) / 100).toString();
     svg.appendChild(t);
   });
 
   // axis labels
   svg.appendChild(svgEl('text', { x: ML + innerW / 2, y: H - 4, 'text-anchor': 'middle', 'font-size': '12', fill: '#444' }))
      .textContent = 'Period T (s)';
   const yLabel = mode === 'speed' ? 'Speed (m/s)' : 'Wave Height (m)';
   svg.appendChild(svgEl('text', {
     x: 18, y: MT + innerH / 2, transform: `rotate(-90,18,${MT + innerH / 2})`,
     'text-anchor': 'middle', 'font-size': '12', fill: '#444'
   })).textContent = yLabel;
 
   const Hstep = 0.5;
 
+  const accentColor = (() => {
+    if (typeof window !== 'undefined' && typeof document !== 'undefined' && window.getComputedStyle) {
+      const val = window.getComputedStyle(document.documentElement).getPropertyValue('--accent');
+      if (val) return val.trim();
+    }
+    return '#2c56a3';
+  })();
+
   if (mode === 'speed') {
     // contour lines for H from 0.5 to Hmax in 0.5 m step
     for (let Hm = Hstep; Hm <= Hmax + 1e-9; Hm += Hstep) {
       const pts = [];
       const samples = 200;
       for (let i = 0; i <= samples; i++) {
         const T = Tmin + (Tmax - Tmin) * i / samples;
         const v = Math.PI * Hm / Math.max(T, 1e-9);
         pts.push([sx(T), sy(v)]);
       }
       svg.appendChild(svgEl('path', {
         d: svgPathFromPoints(pts),
         fill: 'none',
-        stroke: '#000',
+        stroke: '#999',
         'stroke-width': 1.5,
         'stroke-dasharray': (Math.abs(Hm - Math.round(Hm)) < 1e-9) ? '0' : '6 6'
       }));
     }
 
-    // horizontal gray lines for each layer speed
+    // horizontal lines for each layer speed
     layerSpeeds.forEach(L => {
       const Y = sy(L.v_ms);
-      svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: '#999', 'stroke-width': 1.5 }));
-      const lbl = svgEl('text', { x: W - MR - 2, y: Y - 3, 'text-anchor': 'end', 'font-size': '11', fill: '#666' });
+      svg.appendChild(svgEl('line', { x1: ML, y1: Y, x2: W - MR, y2: Y, stroke: accentColor, 'stroke-width': 1.5 }));
+      const lbl = svgEl('text', {
+        x: W - MR - 2,
+        y: Y - 3,
+        'text-anchor': 'end',
+        'font-size': '11',
+        fill: accentColor
+      });
       lbl.textContent = `L${L.layer_no} (${L.v_ms.toFixed(2)} m/s)`;
       svg.appendChild(lbl);
     });
   } else {
     // iso-speed contour lines (H = v·T / π) for integer and half-integer speeds
     const speedStep = 0.5;
     const maxIsoSpeed = Math.PI * Hmax / Math.max(Tmin, 1e-9);
     for (let v = speedStep; v <= maxIsoSpeed + 1e-9; v += speedStep) {
       const TmaxForLine = Math.min(Tmax, (Hmax * Math.PI) / Math.max(v, 1e-12));
       if (TmaxForLine <= Tmin + 1e-6) continue;
 
       const pts = [];
       const samples = 200;
       for (let i = 0; i <= samples; i++) {
         const T = Tmin + (TmaxForLine - Tmin) * i / samples;
         const Hline = (v * T) / Math.PI;
         pts.push([sx(T), sy(Hline)]);
       }
 
       const isIntegerSpeed = Math.abs(v - Math.round(v)) < 1e-9;
       svg.appendChild(svgEl('path', {
         d: svgPathFromPoints(pts),
         fill: 'none',
         stroke: '#bbb',
         'stroke-width': isIntegerSpeed ? 1.4 : 1,
@@ -156,47 +170,47 @@ function renderWavePlot(svg, {
           'text-anchor': 'start',
           'font-size': '10',
           fill: '#888'
         });
         lbl.textContent = `${v.toFixed(1)} m/s`;
         svg.appendChild(lbl);
       }
     }
 
     // contour lines for each layer speed (H = vÂ·T / Ï€)
     layerSpeeds.forEach(L => {
       if (!Number.isFinite(L.v_ms) || L.v_ms <= 0) return;
       const TmaxForLine = Math.min(Tmax, (Hmax * Math.PI) / Math.max(L.v_ms, 1e-12));
       if (TmaxForLine <= Tmin + 1e-6) return;
 
       const pts = [];
       const samples = 200;
       for (let i = 0; i <= samples; i++) {
         const T = Tmin + (TmaxForLine - Tmin) * i / samples;
         const Hline = (L.v_ms * T) / Math.PI;
         pts.push([sx(T), sy(Hline)]);
       }
       svg.appendChild(svgEl('path', {
         d: svgPathFromPoints(pts),
         fill: 'none',
-        stroke: '#999',
+        stroke: accentColor,
         'stroke-width': 1.6
       }));
 
       const lastPt = pts[pts.length - 1];
       if (lastPt) {
         const lbl = svgEl('text', {
           x: lastPt[0] - 4,
           y: lastPt[1] - 6,
           'text-anchor': 'end',
           'font-size': '11',
-          fill: '#666'
+          fill: accentColor
         });
         lbl.textContent = `L${L.layer_no} (${L.v_ms.toFixed(2)} m/s)`;
         svg.appendChild(lbl);
       }
     });
   }
 
   // zero line
   svg.appendChild(svgEl('line', { x1: ML, y1: sy(0), x2: W - MR, y2: sy(0), stroke: '#bbb', 'stroke-dasharray': '4 4' }));
 }
