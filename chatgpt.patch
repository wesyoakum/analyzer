diff --git a/src/js/main.mjs b/src/js/main.mjs
index 930108b0d719d575f8e2b02cbaadb0b0cb92918e..784b1913ff816b5e937a16e9a8cd7266d345458e 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -368,58 +368,58 @@ function updateScenarioOptions(selectId, electricEnabled, hydraulicEnabled) {
       if (opt.hidden !== disabled) opt.hidden = disabled;
       if (disabled && opt.selected) needsChange = true;
     } else if (opt.value === 'hydraulic') {
       const disabled = !hydraulicEnabled;
       if (opt.disabled !== disabled) opt.disabled = disabled;
       if (opt.hidden !== disabled) opt.hidden = disabled;
       if (disabled && opt.selected) needsChange = true;
     }
   });
 
   if (needsChange) {
     if (electricEnabled) {
       selectEl.value = 'electric';
     } else if (hydraulicEnabled) {
       selectEl.value = 'hydraulic';
     } else {
       const first = Array.from(selectEl.options).find(opt => !opt.disabled);
       if (first) selectEl.value = first.value;
     }
     selectEl.dispatchEvent(new Event('change', { bubbles: true }));
   }
 }
 
 // ---- Core compute + render ----
 function computeAll() {
-  const errBox = q('err');
+  const errBox = /** @type {HTMLElement|null} */ (document.getElementById('err'));
   const status = /** @type {HTMLElement|null} */ (document.getElementById('status'));
-  errBox.textContent = '';
+  if (errBox) errBox.textContent = '';
   if (status) status.textContent = 'computingâ€¦';
 
   try {
     // Geometry & load inputs
-        const wraps_override_input = read('wraps_override');
+    const wraps_override_input = read('wraps_override');
     const wraps_per_layer_override = (
       Number.isFinite(wraps_override_input) && wraps_override_input > 0
     ) ? wraps_override_input : undefined;
 
     const cfg = {
       cable_dia_mm: read('c_mm'),
       operating_depth_m: read('depth_m'),
       dead_end_m: read('dead_m'),
       core_dia_in: read('core_in'),
       flange_to_flange_in: read('ftf_in'),
       lebus_thk_in: read('lebus_in'),
       packing_factor: read('pack'),
       wraps_per_layer_override
     };
     const payload_kg = read('payload_kg');
     const cable_w_kgpm = read('c_w_kgpm');
 
     const rated_speed_mpm = read('rated_speed_mpm');
     const rated_swl_kgf = read('rated_swl_kgf');
     const system_efficiency = read('system_efficiency');
 
     updateMinimumSystemHp(rated_speed_mpm, rated_swl_kgf, system_efficiency);
 
     const positiveOr = (value, fallback) => (Number.isFinite(value) && value > 0 ? value : fallback);
 
@@ -580,63 +580,63 @@ function computeAll() {
       }
     }
 
     // ---- Drum visualization ----
     renderDrumVisualization(rows, summary, cfg, meta);
 
     // ---- Aggregate into per-layer tables ----
     lastElLayer = electricEnabled ? rowsToElectricLayer(rows, payload_kg, cable_w_kgpm, gr1, gr2, motors) : [];
     lastHyLayer = hydraulicEnabled ? rowsToHydraulicLayer(rows) : [];
     lastElWraps = electricEnabled ? projectElectricWraps(rows) : [];
     lastHyWraps = hydraulicEnabled ? projectHydraulicWraps(rows) : [];
 
     // ---- Render tables ----
     renderElectricTables(lastElLayer, lastElWraps, q('tbody_el_layer'), q('tbody_el_wraps'));
     renderHydraulicTables(lastHyLayer, lastHyWraps, q('tbody_hy_layer'), q('tbody_hy_wraps'));
 
     updateCsvButtonStates();
 
     // ---- Update status ----
     if (status) status.textContent = 'results updated';
 
     // ---- Draw plots ----
     redrawPlots();
   } catch (e) {
     console.error(e);
-    q('err').textContent = 'ERROR: ' + (e && e.message ? e.message : e);
+    if (errBox) errBox.textContent = 'ERROR: ' + (e && e.message ? e.message : e);
     if (status) status.textContent = 'error';
     clearMinimumSystemHp();
     lastElLayer = lastElWraps = lastHyLayer = lastHyWraps = [];
     clearDrumVisualization();
     clearPlots();
     updateCsvButtonStates();
   }
 }
 
 // ---- Plot redraw helper (uses decoupled plotting modules) ----
 function redrawPlots() {
-    // Wave contours (optional - skip if controls/SVGs absent)
+  // Wave contours (optional - skip if controls/SVGs absent)
   const waveScenarioEl = /** @type {HTMLSelectElement|null} */ (document.getElementById('wave_scenario'));
   const waveTminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmin'));
   const waveTmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_tmax'));
   const waveVminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_vmin'));
   const waveVmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_vmax'));
   const waveHminEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_hmin'));
   const waveHmaxEl = /** @type {HTMLInputElement|null} */ (document.getElementById('wave_hmax'));
   const waveSvg = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg'));
   const waveSvgHeight = /** @type {SVGSVGElement|null} */ (document.getElementById('wave_svg_height'));
 
   const parseInput = (el) => {
     if (!el) return NaN;
     return parseFloat((el.value || '').replace(',', '.'));
   };
 
   if (waveScenarioEl && waveTminEl && waveTmaxEl && waveHmaxEl && waveSvg && waveSvgHeight) {
     const TminVal = parseInput(waveTminEl);
     const TmaxVal = parseInput(waveTmaxEl);
     const speedMinVal = parseInput(waveVminEl);
     const speedMaxVal = parseInput(waveVmaxEl);
     const HminVal = parseInput(waveHminEl);
     const HmaxVal = parseInput(waveHmaxEl);
     const waveOpts = {
       scenario: waveScenarioEl.value || 'electric',
       Tmin: Number.isFinite(TminVal) ? TminVal : 4,
