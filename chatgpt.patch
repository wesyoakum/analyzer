diff --git a/src/js/main.mjs b/src/js/main.mjs
index b92dd9f9d0b8395e4d48e41138cebdb9f7dc53c6..b19edbc925f8110888d7e724d554cb11d3bf3486 100644
--- a/src/js/main.mjs
+++ b/src/js/main.mjs
@@ -144,54 +144,61 @@ document.addEventListener('DOMContentLoaded', () => {
     });
   });
 
   // Wave plot controls
   q('wave_scenario').addEventListener('change', () => redrawPlots());
   ['wave_tmin', 'wave_tmax', 'wave_vmin', 'wave_vmax', 'wave_hmin', 'wave_hmax']
     .forEach(id => q(id).addEventListener('change', () => redrawPlots()));
 
   // Depth plot controls
   q('depth_scenario').addEventListener('change', () => redrawPlots());
   ['depth_xmin', 'depth_xmax', 'depth_speed_ymin', 'depth_speed_ymax', 'depth_tension_ymin', 'depth_tension_ymax', 'depth_rated_speed_ms']
     .forEach(id => q(id).addEventListener('change', () => redrawPlots()));
 
   // Initial compute
   computeAll();
 });
 
 const computeTimerLabel = 'computeAll total';
 
 /**
  * Emit a console debug log that is easy to spot when tracing hangs.
  * @param {string} message
  * @param {Record<string, unknown>} [context]
  */
 function logCompute(message, context) {
+  const logFn =
+    (typeof console !== 'undefined' && typeof console.info === 'function' && console.info.bind(console)) ||
+    (typeof console !== 'undefined' && typeof console.log === 'function' && console.log.bind(console)) ||
+    (typeof console !== 'undefined' && typeof console.debug === 'function' && console.debug.bind(console));
+
+  if (!logFn) return;
+
   if (context && Object.keys(context).length) {
-    console.debug(`[computeAll] ${message}`, context);
+    logFn(`[computeAll] ${message}`, context);
   } else {
-    console.debug(`[computeAll] ${message}`);
+    logFn(`[computeAll] ${message}`);
   }
 }
 
 function updateBuildIndicator() {
   const indicator = /** @type {HTMLElement|null} */ (document.getElementById('build-info'));
   if (!indicator) return;
 
   const lastModified = new Date(document.lastModified);
   if (Number.isNaN(lastModified.getTime())) {
     indicator.textContent = `Updated ${document.lastModified}`;
     return;
   }
 
   const formatter = new Intl.DateTimeFormat('en-US', {
     year: 'numeric',
     month: 'short',
     day: '2-digit',
     hour: '2-digit',
     minute: '2-digit',
     second: '2-digit',
     hour12: false,
     timeZone: 'UTC'
   });
 
   indicator.textContent = `Updated ${formatter.format(lastModified)} UTC`;
