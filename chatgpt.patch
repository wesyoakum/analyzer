diff --git a/src/js/plots/depth-profiles.mjs b/src/js/plots/depth-profiles.mjs
index 417022d72e0acb5179fbfa40473b92c6d67e1bd4..f806bd98b8f57eb614a8ed7003fc2fbe358ff1ca 100644
--- a/src/js/plots/depth-profiles.mjs
+++ b/src/js/plots/depth-profiles.mjs
@@ -1,36 +1,43 @@
 // ===== plots/depth-profiles.mjs  Speed vs Depth & Tension vs Depth (DOM-agnostic) =====
 import { niceTicks, svgEl, TENSION_SAFETY_FACTOR } from '../utils.mjs';
 
 const CANDIDATE_POWER_COLOR = '#9249c6'; // purple
 const CANDIDATE_FLOW_COLOR = '#eed500'; // yellow
 const EXCEED_COLOR = '#c65353'; // red
 const TENSION_OK_COLOR = '#76be4e'; // green
 const RATED_SPEED_COLOR = '#76be4e'; // green
 const PITA_PINK = 'e056e8'; // pink
 const CLARS_BLUE = '#2163a5'; // blue
 
+const RATED_AVAILABLE_TOLERANCE = 1e-6;
+
+function isRatedBelowAvailable(ratedSpeedMs, availableSpeedMs) {
+  if (!Number.isFinite(ratedSpeedMs) || !Number.isFinite(availableSpeedMs)) return false;
+  return ratedSpeedMs + RATED_AVAILABLE_TOLERANCE < availableSpeedMs;
+}
+
 function getAccentColor() {
   if (typeof window !== 'undefined' && typeof document !== 'undefined' && window.getComputedStyle) {
     const val = window.getComputedStyle(document.documentElement).getPropertyValue('--accent');
     if (val) return val.trim();
   }
   return '#2c56a3';
 }
 
 /**
  * Draw both depth profile plots (speed & tension).
  *
  * @param {SVGSVGElement} svgSpeed
  * @param {SVGSVGElement} svgTension
  * @param {Object} opts
  * @param {'electric'|'hydraulic'} opts.scenario
  * @param {Array<Object>} opts.elWraps
  * @param {Array<Object>} opts.hyWraps
  * @param {number} opts.payload_kg
  * @param {number} opts.cable_w_kgpm
  * @param {number} [opts.dead_end_m=0]
  */
 export function drawDepthProfiles(svgSpeed, svgTension, {
   scenario = 'electric',
   elWraps = [],
   hyWraps = [],
@@ -138,51 +145,51 @@ function drawSpeedProfile(svg, segments, maxDepth, maxSpeed, accentColor, ratedS
   // candidate speeds (Vp power-limited purple, Vq flow-limited green, dashed)
   segments.forEach(S => {
     if (!Array.isArray(S.candidate_speeds_ms)) return;
     const depthEnd = Math.min(S.depth_start, S.depth_end);
     const depthStart = Math.max(S.depth_start, S.depth_end);
     S.candidate_speeds_ms.forEach(candidate => {
       if (!candidate || !Number.isFinite(candidate.value_ms)) return;
       const y = sy(candidate.value_ms);
       const x0 = sx(depthEnd);
       const x1 = sx(depthStart);
       const stroke = (candidate.kind === 'flow') ? CANDIDATE_FLOW_COLOR : CANDIDATE_POWER_COLOR;
 
       svg.appendChild(svgEl('line', {
         x1: x0,
         y1: y,
         x2: x1,
         y2: y,
         stroke,
         'stroke-width': 2,
         'stroke-dasharray': '5 4'
       }));
     });
   });
 
   if (Number.isFinite(ratedSpeedMs) && ratedSpeedMs > 0) {
-    const ratedExceeded = segments.some(S => Number.isFinite(S.speed_ms) && (S.speed_ms + 1e-6) < ratedSpeedMs);
+    const ratedExceeded = segments.some(S => Number.isFinite(S.speed_ms) && !isRatedBelowAvailable(ratedSpeedMs, S.speed_ms));
     const ratedStroke = ratedExceeded ? EXCEED_COLOR : RATED_SPEED_COLOR;
     const yRated = sy(ratedSpeedMs);
     svg.appendChild(svgEl('line', {
       x1: ML,
       y1: yRated,
       x2: W - MR,
       y2: yRated,
       stroke: ratedStroke,
       'stroke-width': 3
     }));
 
     if (ratedExceeded) {
       const limit = findRatedDepthLimit(segments, ratedSpeedMs);
       if (limit && Number.isFinite(limit.depth)) {
         const clampedDepth = Math.max(0, Math.min(limit.depth, maxDepth));
         const x = sx(clampedDepth);
         const axisY = H - MB;
         svg.appendChild(svgEl('line', {
           x1: x,
           y1: yRated,
           x2: x,
           y2: axisY,
           stroke: EXCEED_COLOR,
           'stroke-width': 2,
           'stroke-dasharray': '4 6'
@@ -203,51 +210,51 @@ function drawSpeedProfile(svg, segments, maxDepth, maxSpeed, accentColor, ratedS
       }
     }
   }
 
   // zero line
   svg.appendChild(svgEl('line', { x1: ML, y1: sy(0), x2: W - MR, y2: sy(0), stroke: '#bbb', 'stroke-dasharray': '4 4' }));
 }
 
 function findRatedDepthLimit(segments, ratedSpeedMs) {
   if (!Array.isArray(segments) || !Number.isFinite(ratedSpeedMs) || ratedSpeedMs <= 0) return null;
   const ranges = segments
     .filter(S => Number.isFinite(S.speed_ms))
     .map(S => ({
       d0: Math.min(S.depth_start, S.depth_end),
       d1: Math.max(S.depth_start, S.depth_end),
       speed: S.speed_ms
     }))
     .sort((a, b) => a.d0 - b.d0);
 
   if (!ranges.length) return null;
 
   let deepestReach = null;
   let hasReachable = false;
 
   for (const range of ranges) {
-    if (range.speed + 1e-6 >= ratedSpeedMs) {
+    if (isRatedBelowAvailable(ratedSpeedMs, range.speed)) {
       hasReachable = true;
       deepestReach = (deepestReach === null) ? range.d1 : Math.max(deepestReach, range.d1);
       continue;
     }
 
     if (!hasReachable) {
       return { depth: range.d0 };
     }
 
     return { depth: deepestReach ?? range.d0 };
   }
 
   return null;
 }
 
 function formatDepthLabel(depth) {
   if (!Number.isFinite(depth)) return '';
   if (Math.abs(depth) >= 100) return String(Math.round(depth));
   if (Math.abs(depth) >= 10) return removeTrailingZeros(depth.toFixed(1));
   return removeTrailingZeros(depth.toFixed(2));
 }
 
 function removeTrailingZeros(text) {
   return text.replace(/\.0+$/, '').replace(/(\.\d*[1-9])0+$/, '$1');
 }
