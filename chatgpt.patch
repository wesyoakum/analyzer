diff --git a/main.js b/main.js
index 896e980c785e43cf3289570d7e9dcf02bab94df8..60b1396bd3c306f8d37fa0c7275661f3a930c702 100644
--- a/main.js
+++ b/main.js
@@ -436,50 +436,51 @@ function calculateRequiredAHCSpeed(waveHeight_m, wavePeriod_s, avgSpeed_mpm) {
     requiredSpeed_mps,
     requiredSpeed_mpm
   };
 }
 
 function displayResults(results, inputs) {
   clearResults();
   if (!results || !results.combined.length) return;
 
   const summary = document.getElementById('summary');
   summary.innerHTML =
     `Bare Drum Diameter: ${results.bareDrumDiameter_in.toFixed(2)} in<br>` +
     `Full Drum Diameter: ${results.fullDrumDiameter_in.toFixed(2)} in<br>` +
     `Required Free Flange: ${results.reqFreeFlange_in.toFixed(2)} in<br>` +
     `Free Flange: ${results.freeFlange_in.toFixed(2)} in`;
 
   const tbody = document.querySelector('#resultsTable tbody');
   const lastWraps = results.combined.filter((r, idx, arr) => {
     const next = arr[idx + 1];
     return !next || next.layer !== r.layer;
   });
   lastWraps.forEach(r => {
       const row = document.createElement('tr');
     row.innerHTML =
       `<td>${r.layer}</td>` +
+      `<td>${r.wrap}</td>` +
       `<td>${r.diameter_in.toFixed(2)}</td>` +
       `<td>${r.wrap_length_m.toFixed(2)}</td>` +
       `<td>${r.cumulative_length_m.toFixed(0)}</td>` +
       `<td>${r.depth_m.toFixed(0)}</td>` +
       `<td>${r.tension_kgf.toFixed(0)}</td>` +
       `<td>${r.available_tension_kgf.toFixed(0)}</td>` +
       `<td>${r.actual_speed_mpm.toFixed(2)}</td>` +
       `<td>${r.rpm_speed_mpm.toFixed(2)}</td>` +
       `<td>${r.power_speed_mpm.toFixed(2)}</td>` +
       `<td>${r.required_pressure_psi !== null ? r.required_pressure_psi.toFixed(0) : '-'}</td>`;
     tbody.appendChild(row);
   });
 
   const depths = results.combined.map(r => r.depth_m).slice().reverse();
   const tensionData = results.combined.map(r => r.tension_kgf).slice().reverse();
   const availTensionData = results.combined.map(r => r.available_tension_kgf).slice().reverse();
   const actualSpeedData = results.combined.map(r => r.actual_speed_mpm).slice().reverse();
   const rpmSpeedData = results.combined.map(r => r.rpm_speed_mpm).slice().reverse();
   const powerSpeedData = results.combined.map(r => r.power_speed_mpm).slice().reverse();
 
     const transitionDepths = results.layers
     .map(l => ({ layer: l.layer, depth: l.depth_m }))
     .filter(t => depths.includes(t.depth));
 
   renderCharts(
@@ -674,64 +675,72 @@ function drawDrumVisualization(wraps, inputs, baseWraps) {
   const extY = (flangeDia - extHeight) / 2;
 
   drumCtx.beginPath();
   drumCtx.rect(toX(-extWidth), toY(extY + extHeight), extWidth * scale, extHeight * scale);
   drumCtx.fill();
   drumCtx.stroke();
 
   drumCtx.beginPath();
   drumCtx.rect(toX(flangeSpacing + 2 * flangeThickness), toY(extY + extHeight), extWidth * scale, extHeight * scale);
   drumCtx.fill();
   drumCtx.stroke();
 
   // core
   drumCtx.fillStyle = '#5c82a4';
   const coreBottom = (flangeDia - coreDia) / 2;
   drumCtx.beginPath();
   drumCtx.rect(toX(flangeThickness), toY(coreBottom + coreDia), flangeSpacing * scale, coreDia * scale);
   drumCtx.fill();
   drumCtx.stroke();
 
     // wraps
   drumCtx.strokeStyle = '#6d4688';
   drumCtx.lineWidth = 1;
   const centerY = flangeDia / 2;
 
-  const spacingWhole = (flangeSpacing - cableDia) / (baseWraps - 1);
-  const spacingHalf = (flangeSpacing - cableDia / 2) / (baseWraps - 0.5);
+  const isSingleWrap = baseWraps <= 1 + 1e-6;
+  const spacingWhole = isSingleWrap
+    ? 0
+    : (flangeSpacing - cableDia) / (baseWraps - 1);
+  const spacingHalf = isSingleWrap
+    ? 0
+    : (flangeSpacing - cableDia / 2) / (baseWraps - 0.5);
   const isHalf = Math.abs(baseWraps % 1 - 0.5) < 1e-6;
 
   wraps.forEach(wrap => {
     const row = wrap.layer - 1;
     const spacing = isHalf ? spacingHalf : spacingWhole;
 
     const offset = coreRadius + lebus + cableDia / 2 + row * vertSpacing;
     const yTop = centerY + offset;
     const yBottom = centerY - offset;
 
     let startX, step;
-    if (row % 2 === 0) {
+    if (isSingleWrap) {
+      startX = flangeThickness + flangeSpacing / 2;
+      step = 0;
+    } else if (row % 2 === 0) {
       startX = flangeThickness + cableDia / 2;
       step = spacing;
     } else {
       startX =
         flangeThickness +
         flangeSpacing -
         cableDia / 2 -
         (isHalf ? 0 : spacing / 2);
       step = -spacing;
     }
 
    const x = startX + step * (wrap.wrap - 1);
     const px = toX(x);
     const r = (cableDia / 2) * scale;
     drumCtx.beginPath();
     drumCtx.arc(px, toY(yTop), r, 0, Math.PI * 2);
     drumCtx.stroke();
     drumCtx.beginPath();
     drumCtx.arc(px, toY(yBottom), r, 0, Math.PI * 2);
     drumCtx.stroke();
   });
 
   }
 
 
